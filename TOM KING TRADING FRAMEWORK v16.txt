TOM KING TRADING FRAMEWORK v16.0 - COMPLETE INTEGRATION
?? TABLE OF CONTENTS
CORE FRAMEWORK SECTIONS
1. Framework Purpose & Modes
2. PDF Reference Guide
3. Required User Input
4. Required Data Structure
5. Execution Sequence
6. Core Calculation Rules
7. Error Handling
8. Output Format Sections
9. Framework Limitations
10. Troubleshooting Guide
API INTEGRATION SECTIONS
11. TastyTrade API Setup
12. API Authentication
13. API Data Collection
14. API Order Execution
15. WebSocket Streaming
16. API Mode Integration
IMPLEMENTATION SECTIONS
17. Complete Pattern Analysis Code v16.0
18. HTML Dashboard Template
19. Testing Procedures

FRAMEWORK PURPOSE & MODES
This framework executes the Tom King trading methodology by analyzing positions, calculating opportunities, and generating specific trade recommendations based on real market data. It bridges strategy documentation with live market execution through automated pattern analysis and position management.
Three Execution Modes
1. API Mode - Real-time data from TastyTrade
2. Manual Mode - Web searches
3. Test Mode - Simulated data
Version 16.0 Features
* ? ALL v14.0 functionality preserved
* ? Complete TastyTrade API integration
* ? Real-time position tracking
* ? Automated order preparation
* ? Greeks monitoring
* ? WebSocket streaming
* ? Seamless mode switching
* ? Complete HTML dashboard
* ? Pound sterling (£) pricing throughout
Critical Requirement
This framework REQUIRES the analysis tool (REPL) to execute the JavaScript pattern analysis code. The framework cannot function without executing this code.

PDF REFERENCE GUIDE
The framework references the "Tom King Complete Trading System Documentation" PDF. Use this guide to locate specific information:
SectionPDF PagesFramework UsageKey Quotes & Principles1-2Tom's philosophy, risk management mindsetMathematical Formulas2-5Position sizing, Kelly Criterion, strike calculationsRisk Metrics3-4Health scores, expectancy, drawdown toleranceCorrelation Calculations3-4Group exposure, coefficient checksVIX-Adjusted Formulas4-5Sizing by volatility, butterfly debitsWeekly Iron Condor Variations4-50DTE structures, broken wings, Batman spreadsComplete Margin & BP Requirements5-6Micro/Mini/Full futures, ETF requirementsNever Trade List6-7Products/strategies Tom avoidsAugust 5, 2024 Lesson7-8The £308k loss, correlation disasterWin Rate Targets8-9Strategy-specific expectationsManagement Protocols by DTE9-1021 DTE rule, 50% rule, defensive linesTax Optimization10-11UK/US considerations, Section 1256Critical Foundation11-13Non-negotiable rules, correlation groups, VIX regimesPhase 1: £30-40k13-15Foundation strategies, 0DTE, IPMCC, stranglesPhase 2: £40-60k15-18Scaling, enhanced 0DTE, LT112, ratio spreadsPhase 3: £60-75k18-22Optimization, butterflies, ES futures upgradePhase 4: £75k+22-24Professional deployment, full systemComplete Specifications24-36Detailed specs for all 10 strategiesDaily Execution Checklist37-38Day-by-day tasksAutomation Triggers38-39Entry/exit/risk triggersP&L Expectations39-40Monthly targets by account sizeCritical Success Factors40-41Non-negotiables, optimizations, reality checksLegal Disclaimer41-42Risk warnings, prerequisitesCommon Mistakes42-43Fatal errors, profit killersMonthly Checklist43-44Weekly and monthly tasksTom's 40-Year Wisdom45-49Account blowups, lessons, final rules
REQUIRED USER INPUT
Option 1: Manual Mode Input
Provide your trading data in this EXACT format:
Account Value: £[amount]
Current Positions: [strategy ticker (DTE, entry price, current P&L%)] or "none"
Buying Power Used: [%]
Current Date/Time: [Day, Date, Time EST]
VIX Level: [current]
Portfolio Margin: [Yes/No]
Month P&L: £[amount] (optional)
Example Input Format (DO NOT USE THESE VALUES):
£75000 | ES LT112 (85 DTE, 6420, +5%), MCL strangle (55 DTE, 2.80, +15%), MGC strangle (55 DTE, 3.20, +8%), QQQ IPMCC (280 DTE, 380/weekly, -2%) | 32% | Friday Jan 10 10:15 AM EST | VIX 15.2 | No | £2450
Option 2: API Mode Input
Mode: API
Client Secret: [your_oauth2_secret] 
Refresh Token: [your_refresh_token]
Environment: [sandbox/production]
Option 3: Test Mode Override
To test specific day scenarios, add: "Pretend it's [Day] [Date] [Time]" to your input. Example: £40000 | none | 0% | Pretend it's Friday 01/10 9:15 AM EST | VIX 15.2 | No

REQUIRED DATA STRUCTURE
SearchedData Structure Definition
The framework requires searchedData object with this EXACT structure (populated from searches OR API):
const searchedDataStructure = {
  ES: {
    // Basic Price Data
    currentPrice: number,        // Search: "ES current price" OR API: /market-data
    openPrice: number,           // Search: "ES opening price" OR API: /market-data
    previousClose: number,       // Search: "ES yesterday close" OR API: /market-data
    
    // Range Data
    high5d: number,              // Search: "ES 5-day high" OR API: calculated
    low5d: number,               // Search: "ES 5-day low" OR API: calculated
    high20d: number,             // Search: "ES 20-day high" OR API: calculated
    low20d: number,              // Search: "ES 20-day low" OR API: calculated
    
    // Technical Indicators
    atr: number,                 // Search: "ES ATR" OR API: calculated
    rsi: number,                 // Search: "ES RSI" OR API: calculated
    ema8: number,                // Search: "ES 8 EMA" OR API: calculated
    ema21: number,               // Search: "ES 21 EMA" OR API: calculated
    vwap: number,                // Search: "ES VWAP" OR API: streaming
    
    // Volatility Data
    iv: number,                  // Search: "ES implied volatility" OR API: /option-chains
    ivRank: number,              // Search: "ES IV rank" OR API: calculated
    ivPercentile: number,        // Search: "ES IV percentile" OR API: calculated
    
    // Option Chain Data
    optionChain: {
      // Strangle strikes (90 DTE)
      put5Delta: number,         // Search: "ES 90 DTE 5 delta put strike" OR API: /option-chains
      put5DeltaBid: number,      // Search: "ES 90 DTE 5 delta put bid" OR API: /market-data
      call5Delta: number,        // Search: "ES 90 DTE 5 delta call strike" OR API: /option-chains
      call5DeltaBid: number,     // Search: "ES 90 DTE 5 delta call bid" OR API: /market-data
      
      // 0DTE spreads (Friday only)
      atmStrike: number,         // Search: "ES 0DTE ATM strike" OR API: calculated
      call30Wide: {
        shortStrike: number,     // Search: "ES 0DTE call spread strikes" OR API: calculated
        longStrike: number,
        credit: number           // Search: "ES 0DTE call spread credit" OR API: /market-data
      },
      put30Wide: {
        shortStrike: number,     // Search: "ES 0DTE put spread strikes" OR API: calculated
        longStrike: number,
        credit: number           // Search: "ES 0DTE put spread credit" OR API: /market-data
      },
      ironCondor: {
        credit: number           // Search: "ES 0DTE iron condor credit" OR API: calculated
      }
    }
  },
  // Additional tickers follow same structure
  SPY: { /* same structure */ },
  VIX: { currentLevel: number, avg20d: number },
  DXY: { currentLevel: number, trend: string },
  TIME: { 
    currentEST: string,          // Search: "current time EST" OR API: Date.now()
    currentUK: string,           // Search: "current UK time" OR API: calculated
    marketStatus: string         // Derived from time OR API: /trading-status
  }
};
How to Parse Search Results (Manual Mode)
Price Data Parsing:
* Search result: "ES is currently trading at $6,468.50, up $48.50 from the open"
* currentPrice: 6468.50 // Extract number after "trading at $"
* dayChange: 48.50 // Extract number after "up $" or "down $"
Range Data Parsing:
* Search result: "5-day range: 6380 - 6485"
* high5d: 6485 // Number after dash
* low5d: 6380 // Number before dash
Technical Indicators Parsing:
* Search result: "ATR(14) is 45 points"
* atr: 45 // Extract number before "points"
* Search result: "RSI reading: 58.3 (neutral)"
* rsi: 58 // Round to integer
Volatility Data Parsing:
* Search result: "Implied Volatility: 15.2%"
* iv: 15.2 // Number before "%"
* Search result: "IV Rank: 35th percentile"
* ivRank: 35 // Number before "th" or "%"
Option Chain Parsing:
* Search result: "90 DTE 5-delta put: 6200 strike, bid 2.50, ask 2.75"
* put5Delta: 6200 // Number before "strike"
* put5DeltaBid: 2.50 // Number after "bid"
For spread credits: Credit = Short Bid - Long Ask Example: Short 6450 bid 4.25, Long 6480 ask 1.75 Spread credit = 4.25 - 1.75 = 2.50
Handling Missing or Failed Searches:
// If search fails or returns no results:
ivRank: null         // Mark as null
// Framework will show "NO DATA" and continue

// If partial data returned:
optionChain: {
  put5Delta: 6200,   // Found this
  put5DeltaBid: null, // But not this
  call5Delta: 6700,   // Found this
  call5DeltaBid: null // But not this
}

EXECUTION SEQUENCE
STEP 1: VALIDATE & PARSE
1. Parse user input for all required fields
2. Detect current day/time (or apply testing override if provided)
3. Verify day matches date
4. Identify allowed strategies for detected day
5. Calculate available buying power based on phase
6. In API mode: Authenticate with TastyTrade
7. In API mode: Fetch account balances and positions automatically
STEP 2: GATHER MARKET DATA
API Mode (Automatic)
// Automatic data collection via API
const api = new TastyTradeAPI(clientSecret, refreshToken);
await api.authenticate();
const searchedData = await api.buildSearchedData();
Manual Mode (Web Searches)
MANDATORY SEARCHES - NO EXCEPTIONS:
Core Market Searches (ALWAYS):
1. Search: "current time EST and UK time"
2. Search: "ES futures current price opening price 5-day high low 20-day range ATR"
3. Search: "SPY current price support resistance RSI 8 EMA 21 EMA"
4. Search: "VIX current level 20-day average regime"
5. Search: "DXY dollar index level trend"
Phase-Based Ticker Searches: Based on account value phase (See PDF Pages 13-24):
* Phase 1 (£30-40k): MCL, MGC, GLD, TLT
* Phase 2 (£40-60k): Add MES, MNQ, 6A, M6E, SLV, XOP
* Phase 3 (£60-75k): Add ES upgrade, CL, GC, LE, HE, ZC, ZS, ZW, 6E, 6B
* Phase 4 (£75k+): All products available
FOR EACH QUALIFIED TICKER (based on phase): IF ticker not at concentration limit:
* Search: "[TICKER] current price 20-day high low"
* Search: "[TICKER] IV rank IV percentile ATR"
* Search: "[TICKER] 90 DTE 5 delta put strike bid"
* Search: "[TICKER] 90 DTE 5 delta call strike bid"
Progressive Friday Pre-Market Analysis (Before 10:30 AM):
+--- 9:00-9:30 AM: OVERNIGHT ASSESSMENT PHASE ---+
Search: "ES overnight high low current from yesterday close"
Search: "ES Globex volume overnight session"
Search: "Economic calendar today Fed speakers data releases"

+--- 9:30-10:00 AM: OPENING RANGE DEVELOPMENT ---+
Search: "ES opening range first 30 minutes volume VWAP"
Search: "SPY opening price 30-minute range"
Search: "ES order flow imbalance buying selling pressure"

+--- 10:00-10:30 AM: FINAL 0DTE PREPARATION ---+
Search: "ES current position from open percentage move"
Search: "ES 0DTE option chain 30-point spreads current bid ask"
Search: "ES gamma exposure levels for pinning"
Calculate: Exact triggers (±0.5% from open per PDF Page 25)
Display: Countdown timer to 10:30 AM execution window
STEP 3: CALCULATE WITH REAL DATA
Execute pattern analysis code in the analysis tool using searched/API data to calculate:
* Position health scores using PDF formulas (Pages 3-4)
* Pattern quality ratings for each ticker with specific strikes
* Concentration group usage per PDF limits (Page 12)
* VIX regime BP limits per PDF (Pages 11-12)
* Optimal position sizing by phase (Pages 13-24)
* Expected returns based on win rates (Pages 8-9)
* Generate Position Allocation Table based on current phase
STEP 4: OUTPUT RESULTS
Generate comprehensive analysis with:
* Text-based position analysis with health scores
* SPECIFIC trade recommendations with exact strikes and credits
* Position allocation table showing BP optimization by phase
* HTML dashboard with calculated values
* In API mode: Prepared order payloads ready for submission
* NO PLACEHOLDERS - ONLY REAL DATA FROM SEARCHES OR API

CORE CALCULATION RULES
The 10 Essential Rules (from PDF Pages 11-13):
1. BP LIMIT: Never exceed phase-specific BP usage (40-50% Phase 1, up to 80% Phase 4)
2. VIX REGIME: Adjust BP deployment per PDF Page 12
3. CONCENTRATION: Maximum 2 positions per correlation group (3 for Phase 4)
4. DAY MATCHING: Only trade strategies allowed on current day
5. DATA FIRST: No recommendations without actual market data
6. EXIT PRIORITY: Use PDF exit rules (Pages 9-10)
7. PATTERN QUALITY: Only trade EXCELLENT or GOOD setups
8. EXACT STRIKES: Calculate specific strikes from real chains
9. SUSTAINABILITY: Alert if monthly return exceeds 12% (PDF Page 41)
10. POSITION SIZING: Use phase-based maximums (Pages 13-24)
BP Maximization by Phase:
function getBPTargetByPhase(accountValue, vixLevel) {
  if (accountValue < 40000) {
    // Phase 1: Conservative
    return { min: 40, max: 50 };
  } else if (accountValue < 60000) {
    // Phase 2: Scaling
    return { min: 55, max: 65 };
  } else if (accountValue < 75000) {
    // Phase 3: Optimization
    return { min: 60, max: 75 };
  } else {
    // Phase 4: Professional
    return getVIXRegimeLimits(vixLevel);
  }
}
Complete BP Requirements Table (PDF Pages 5-6, 13-24):
Strategy    | Micro BP | Full BP | Phase 1 | Phase 2 | Phase 3 | Phase 4
------------|----------|---------|---------|---------|---------|--------
STRANGLE    | 2.5%     | 3.5%    | 1       | 3       | 4       | 5
LT112       | 3% (MES) | 6% (ES) | 0       | 4       | 1       | 3
IPMCC       | 8%       | 8%      | 1       | 2       | 3       | 4
0DTE        | 2%       | 2%      | 1       | 2       | 3       | 4
BUTTERFLY   | 0.5%     | 0.5%    | 0       | 0       | 2       | 4
RATIO       | 2%       | 2%      | 0       | 2       | 4       | 5
DIAGONAL    | 1.5%     | 1.5%    | 0       | 0       | 2       | 4
LEAP        | 2%       | 2%      | 0       | 2       | 3       | 10
BOX         | 0%       | 0%      | 0       | 0       | 1       | 2

ERROR HANDLING
Unified Error System:
* ? ERROR: Critical issues requiring immediate attention
* ?? BLOCKED: Cannot proceed without resolution
* ?? WARNING: Important but non-blocking issues
* ?? INFO: Informational messages
Common Errors:
* NO DATA: "Cannot recommend without market data - initiating searches"
* BP EXCEEDED: "Would use X%, phase maximum Y% - reduce position size"
* GROUP LIMIT: "Correlation group at maximum per PDF Page 12"
* WRONG DAY: "Strategy only available on [Day] per phase schedule"
* EXIT TRIGGER: "Position requires immediate closure per PDF Pages 9-10"
* API FAILURE: "API connection failed - falling back to manual mode"

OUTPUT FORMAT SECTIONS
Position Allocation Table (MANDATORY):
+---------------------------------------------------------------+
¦      POSITION ALLOCATION & BP OPTIMIZATION TABLE              ¦
¦              Phase [X]: £[Account Value]                      ¦
+---------------------------------------------------------------+

Strategy    | Max Pos | Current | Avail | BP/Pos | BP Used | Can Add | Priority
------------|---------|---------|-------|--------|---------|---------|----------
[Phase-specific strategies based on PDF Pages 13-24]

VIX REGIME ([Level]): [Regime] - Target [Min]-[Max]% BP usage
Current: [X]% | Gap to Min: [Y]% | Available: [Z]%

OPTIMIZATION PLAN TO REACH PHASE TARGET:
[Phase-specific recommendations]
Friday Pre-Market Analysis (Before 10:30 AM):
+---------------------------------------------------------------+
¦         PRE-MARKET 0DTE ANALYSIS - [Time] EST                 ¦
¦            (See PDF Page 25 for Specifications)               ¦
+---------------------------------------------------------------+

ES OVERNIGHT MOVEMENT:
+- Range: $[Low] - $[High] ([Range] points)
+- Current: $[Price] ([Change]% from close)
+- Direction: [BULLISH/BEARISH/NEUTRAL]

+---------------------------------------------------------------+
¦      KEY LEVELS FOR 10:30 AM EXECUTION                        ¦
¦         (Per Tom King 0DTE Rules - PDF Page 25)               ¦
¦---------------------------------------------------------------¦
¦ ?? CALL SPREAD TRIGGER: ES above $[Price] (+0.5%)            ¦
¦    • Strikes: [Short]/[Long] (30pt width)                    ¦
¦    • Expected Credit: £[Amount]                              ¦
¦---------------------------------------------------------------¦
¦ ?? PUT SPREAD TRIGGER: ES below $[Price] (-0.5%)             ¦
¦    • Strikes: [Short]/[Long] (30pt width)                    ¦
¦    • Expected Credit: £[Amount]                              ¦
¦---------------------------------------------------------------¦
¦ ?? IRON CONDOR ZONE: ES between $[Low] and $[High]           ¦
¦    • Combined Credit: £[Amount]                              ¦
+---------------------------------------------------------------+

? COUNTDOWN: [Minutes] minutes until 10:30 AM execution
Pattern Analysis with Phase-Specific Strikes:
+---------------------------------------------------------------+
¦     PATTERN QUALITY ANALYSIS - PHASE [X] TICKERS              ¦
+---------------------------------------------------------------+

?? EXCELLENT SETUPS ([Count]):
[Phase-appropriate tickers with specific strikes and credits]

?? GOOD SETUPS ([Count]):
[Tickers meeting partial criteria]

?? AVOID ([Count]):
[Tickers on Tom's Never Trade List - PDF Page 6-7]

? NO DATA ([Count]):
[Tickers requiring searches]

FRAMEWORK LIMITATIONS
Technical Limitations:
* Manual Search Parsing: Requires extraction from search results
* Time Zone: Assumes EST unless specified
* Data Completeness: Full analysis requires complete market data
* Weekend/Holiday: Limited functionality when markets closed
* Option Chain: Requires manual bid/ask searches (Manual mode)
* API Rate Limits: 120 requests/minute (API mode)
Operational Limitations:
* Analysis Tool Required: Cannot function without JavaScript execution
* Real-Time Data: Framework uses searched data or API feeds
* PDF Reference: Requires separate PDF document for complete rules
* Browser Environment: Dashboard requires modern browser
* Phase Progression: Must follow account value phases

TROUBLESHOOTING GUIDE
Common Issues & Solutions:
"No market data provided"
* Solution: Execute all phase-specific searches (Manual) OR check API connection
* Required: Core market data + phase-qualified tickers
* Format: Parse results into searchedData structure
"API authentication failed"
* Solution: Verify credentials are correct
* Check: Token hasn't expired
* Try: Refresh token generation
"Pattern analysis failed"
* Solution: Check data structure has required fields
* Minimum fields: currentPrice, high20d, low20d
* Verify: No undefined values in critical fields
"Dashboard shows NO DATA"
* Solution: Ensure executeFramework() completed
* Check: Browser console for errors
* Verify: window.frameworkResults exists
"Position health undefined"
* Solution: Check position format matches specification
* Format: TICKER STRATEGY (DTE, entry, P&L%)
* Example: ES LT112 (85 DTE, 6420, +5%)
"Phase not detected"
* Solution: Verify account value provided
* Check: getPhaseByAccountValue() function
* Ranges: £30k, £40k, £60k, £75k+ thresholds

TASTYTRADE API SETUP
OAuth2 Credentials (Store Securely!)
const API_CREDENTIALS = {
  CLIENT_ID: 'bfca2bd1-b3f3-4941-b542-0267812f1b2f',
  CLIENT_SECRET: '98911c87a7287ac6665fc96a9a467d54fd02f7ed',
  REFRESH_TOKEN: 'eyJhbGciOiJFZERTQSIsInR5cCI6InJ0K2p3dCIsImtpZCI6IkZqVTdUT25qVEQ2WnVySlg2cVlwWmVPbzBDQzQ5TnIzR1pUN1E4MTc0cUkiLCJqa3UiOiJodHRwczovL2ludGVyaW9yLWFwaS5hcjIudGFzdHl0cmFkZS5zeXN0ZW1zL29hdXRoL2p3a3MifQ.eyJpc3MiOiJodHRwczovL2FwaS50YXN0eXRyYWRlLmNvbSIsInN1YiI6IlUyYTUyMWEwZS0zZmNmLTQzMjgtOGI5NS02MjA1ZDY4ODUwOGUiLCJpYXQiOjE3NTY0MTE3NzcsImF1ZCI6ImJmY2EyYmQxLWIzZjMtNDk0MS1iNTQyLTAyNjc4MTJmMWIyZiIsImdyYW50X2lkIjoiRzRmMzdmMTZjLWNlYTktNDhlYi05N2FiLTA1YzI0YjdiMDQ2OCIsInNjb3BlIjoicmVhZCB0cmFkZSBvcGVuaWQifQ.bA7Mt0YbQj5aCptb3BlxD67YnzdlWysWzqGYbNChCTMV1VfmRxsQMQ7yGMcrv28izZuIihzC7_-tWKkLhxZTAw'
};
Environments
const ENVIRONMENTS = {
  SANDBOX: {
    API_BASE: 'https://api.cert.tastyworks.com',
    STREAMER: 'wss://streamer.cert.tastyworks.com',
    DXLINK: 'wss://tasty-openapi-ws.dxfeed.com/realtime'
  },
  PRODUCTION: {
    API_BASE: 'https://api.tastyworks.com',
    STREAMER: 'wss://streamer.tastyworks.com',
    DXLINK: 'wss://tasty-openapi-ws.dxfeed.com/realtime'
  }
};

API AUTHENTICATION
Token Manager Class
class TokenManager {
  constructor(refreshToken, clientSecret) {
    this.refreshToken = refreshToken;
    this.clientSecret = clientSecret;
    this.accessToken = null;
    this.tokenExpiry = null;
  }
  
  async getValidToken() {
    const now = Date.now();
    if (!this.accessToken || now >= this.tokenExpiry) {
      this.accessToken = await this.generateAccessToken();
      this.tokenExpiry = now + (14 * 60 * 1000); // Refresh 1 minute early
    }
    return this.accessToken;
  }
  
  async generateAccessToken() {
    const response = await fetch(`${CURRENT_ENV.API_BASE}/oauth/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'TomKingFramework/1.0'
      },
      body: JSON.stringify({
        grant_type: 'refresh_token',
        refresh_token: this.refreshToken,
        client_secret: this.clientSecret
      })
    });
    
    const data = await response.json();
    return data.access_token;
  }
}

API DATA COLLECTION
TastyTrade API Client
class TastyTradeAPI {
  constructor(tokenManager, environment = 'production') {
    this.tokenManager = tokenManager;
    this.env = environment;
    this.baseURL = ENVIRONMENTS[environment.toUpperCase()].API_BASE;
    this.accountNumber = null;
    this.positions = [];
    this.balance = null;
    this.marketDataCache = new Map();
    this.cacheTTL = 5000; // 5 seconds
  }
  
  async initialize() {
    // Get account info
    const accounts = await this.request('/customers/me/accounts');
    this.accountNumber = accounts.data.items[0]['account-number'];
    
    // Load positions and balance
    await this.refreshPositions();
    await this.refreshBalance();
    
    return true;
  }
  
  async request(endpoint, options = {}) {
    const token = await this.tokenManager.getValidToken();
    
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${token}`,
        'User-Agent': 'TomKingFramework/1.0',
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  async refreshPositions() {
    const data = await this.request(`/accounts/${this.accountNumber}/positions`);
    this.positions = data.data.items;
    return this.positions;
  }
  
  async refreshBalance() {
    const data = await this.request(`/accounts/${this.accountNumber}/balances`);
    this.balance = {
      netLiq: parseFloat(data.data['net-liquidating-value']),
      buyingPower: parseFloat(data.data['derivative-buying-power']),
      cashBalance: parseFloat(data.data['cash-balance']),
      bpUsed: parseFloat(data.data['derivative-buying-power-used']),
      totalBP: parseFloat(data.data['derivative-buying-power']) + 
               parseFloat(data.data['derivative-buying-power-used'])
    };
    return this.balance;
  }
  
  async getQuotes(symbols) {
    const params = new URLSearchParams();
    symbols.forEach(symbol => {
      if (symbol.startsWith('/')) {
        params.append('future', symbol);
      } else if (symbol.includes(' ')) {
        params.append('equity-option', symbol);
      } else {
        params.append('equity', symbol);
      }
    });
    
    return this.request(`/market-data/by-type?${params}`);
  }
  
  async getOptionChain(symbol) {
    const chain = await this.request(`/option-chains/${symbol}/nested`);
    return this.parseOptionChain(chain);
  }
  
  parseOptionChain(chainData) {
    // Parse and structure option chain for framework use
    const expirations = chainData.data.items[0].expirations;
    return expirations.map(exp => ({
      date: exp['expiration-date'],
      dte: exp['days-to-expiration'],
      strikes: exp.strikes.map(strike => ({
        strike: strike['strike-price'],
        call: strike.call,
        put: strike.put,
        callStreamer: strike['call-streamer-symbol'],
        putStreamer: strike['put-streamer-symbol']
      }))
    }));
  }
  
  formatPositionsForFramework() {
    return this.positions.map(pos => {
      const ticker = pos.symbol.replace('/', '');
      const strategy = this.identifyStrategy(pos);
      const dte = pos['days-to-expiration'] || 0;
      const entry = pos['average-open-price'] || 0;
      const pl = pos['unrealized-day-gain-percent'] || 0;
      
      return `${ticker} ${strategy} (${dte} DTE, ${entry}, ${pl >= 0 ? '+' : ''}${pl}%)`;
    }).join(', ') || 'none';
  }
  
  identifyStrategy(position) {
    const dte = position['days-to-expiration'] || 0;
    
    if (dte === 0) return '0DTE';
    if (dte > 100 && dte < 130) return 'LT112';
    if (dte > 80 && dte < 100) return 'STRANGLE';
    if (dte > 300) return 'LEAP';
    if (position['underlying-symbol']) return 'IPMCC';
    
    return 'UNKNOWN';
  }
  
  async buildSearchedData() {
    try {
      // Fetch all required market data
      const [esData, spyData, vixData] = await Promise.all([
        this.getQuotes(['/ES']),
        this.getQuotes(['SPY']),
        this.getQuotes(['VIX'])
      ]);
      
      // Get option chains for 0DTE analysis
      const esChain = await this.getOptionChain('ES');
      
      // Structure data for framework
      const searchedData = {
        ES: {
          currentPrice: parseFloat(esData.data.items[0].last),
          openPrice: parseFloat(esData.data.items[0].open),
          previousClose: parseFloat(esData.data.items[0]['previous-close']),
          high20d: parseFloat(esData.data.items[0]['20-day-high']),
          low20d: parseFloat(esData.data.items[0]['20-day-low']),
          iv: parseFloat(esData.data.items[0]['implied-volatility']),
          optionChain: this.extract0DTEStrikes(esChain)
        },
        SPY: {
          currentPrice: parseFloat(spyData.data.items[0].last),
          openPrice: parseFloat(spyData.data.items[0].open),
          ivRank: parseFloat(spyData.data.items[0]['iv-rank'])
        },
        VIX: {
          currentLevel: parseFloat(vixData.data.items[0].last),
          avg20d: parseFloat(vixData.data.items[0]['20-day-average'])
        },
        TIME: {
          currentEST: new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' }),
          currentUK: new Date().toLocaleTimeString('en-GB', { timeZone: 'Europe/London' }),
          marketStatus: await this.getMarketStatus()
        }
      };
      
      return searchedData;
    } catch (error) {
      console.error('Error building searchedData:', error);
      throw error;
    }
  }
  
  extract0DTEStrikes(chain) {
    // Find today's expiration
    const today = new Date().toISOString().split('T')[0];
    const todayChain = chain.find(exp => exp.date === today);
    
    if (!todayChain) return null;
    
    // Calculate ATM and spread strikes
    const atmStrike = todayChain.strikes.find(s => 
      Math.abs(s.strike - this.currentESPrice) < 5
    );
    
    return {
      atmStrike: atmStrike?.strike,
      call30Wide: {
        shortStrike: atmStrike?.strike + 20,
        longStrike: atmStrike?.strike + 50
      },
      put30Wide: {
        shortStrike: atmStrike?.strike - 20,
        longStrike: atmStrike?.strike - 50
      }
    };
  }
  
  async getMarketStatus() {
    const status = await this.request(`/accounts/${this.accountNumber}/trading-status`);
    return status.data['is-frozen'] ? 'CLOSED' : 'OPEN';
  }
}

API ORDER EXECUTION
Order Builder Class
class OrderBuilder {
  constructor(api) {
    this.api = api;
  }
  
  async build0DTESpread(direction, strikes, credit) {
    const order = {
      'time-in-force': 'Day',
      'order-type': 'Limit',
      'price': credit.toFixed(2),
      'price-effect': 'Credit',
      'legs': []
    };
    
    if (direction === 'CALL') {
      order.legs = [
        {
          'instrument-type': 'Future Option',
          'symbol': `./ESZ4 EW4Z4 241227C${strikes.short}`,
          'quantity': 1,
          'action': 'Sell to Open'
        },
        {
          'instrument-type': 'Future Option',
          'symbol': `./ESZ4 EW4Z4 241227C${strikes.long}`,
          'quantity': 1,
          'action': 'Buy to Open'
        }
      ];
    } else {
      order.legs = [
        {
          'instrument-type': 'Future Option',
          'symbol': `./ESZ4 EW4Z4 241227P${strikes.short}`,
          'quantity': 1,
          'action': 'Sell to Open'
        },
        {
          'instrument-type': 'Future Option',
          'symbol': `./ESZ4 EW4Z4 241227P${strikes.long}`,
          'quantity': 1,
          'action': 'Buy to Open'
        }
      ];
    }
    
    return order;
  }
  
  async dryRun(order) {
    return this.api.request(`/accounts/${this.api.accountNumber}/orders/dry-run`, {
      method: 'POST',
      body: JSON.stringify(order)
    });
  }
  
  async submit(order) {
    // Dry run first
    const dryRunResult = await this.dryRun(order);
    
    // Check BP impact
    const bpImpact = Math.abs(dryRunResult.data['buying-power-effect']['change-in-buying-power']);
    
    console.log(`Order will use £${bpImpact} BP`);
    
    // Actually submit (only in production mode)
    if (this.api.env === 'production') {
      return this.api.request(`/accounts/${this.api.accountNumber}/orders`, {
        method: 'POST',
        body: JSON.stringify(order)
      });
    } else {
      return { message: 'Sandbox mode - order not submitted', order, bpImpact };
    }
  }
}

WEBSOCKET STREAMING
DXLink Streamer
class DXLinkStreamer {
  constructor(url, token) {
    this.url = url;
    this.token = token;
    this.ws = null;
    this.channel = 3;
    this.keepaliveInterval = null;
    this.callbacks = new Map();
  }
  
  async connect() {
    this.ws = new WebSocket(this.url);
    
    return new Promise((resolve, reject) => {
      this.ws.onopen = () => {
        this.setup();
        resolve();
      };
      
      this.ws.onerror = reject;
      
      this.ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      };
    });
  }
  
  setup() {
    this.send({
      type: 'SETUP',
      channel: 0,
      version: '0.1-DXF-JS/0.3.0',
      keepaliveTimeout: 60,
      acceptKeepaliveTimeout: 60
    });
  }
  
  handleMessage(data) {
    switch(data.type) {
      case 'SETUP':
        this.authorize();
        break;
        
      case 'AUTH_STATE':
        if (data.state === 'AUTHORIZED') {
          this.openChannel();
          this.startKeepalive();
        }
        break;
        
      case 'CHANNEL_OPENED':
        this.setupFeed();
        break;
        
      case 'FEED_CONFIG':
        // Ready to subscribe
        if (this.callbacks.has('ready')) {
          this.callbacks.get('ready')();
        }
        break;
        
      case 'FEED_DATA':
        if (this.callbacks.has('data')) {
          this.callbacks.get('data')(data.data);
        }
        break;
    }
  }
  
  authorize() {
    this.send({
      type: 'AUTH',
      channel: 0,
      token: this.token
    });
  }
  
  openChannel() {
    this.send({
      type: 'CHANNEL_REQUEST',
      channel: this.channel,
      service: 'FEED',
      parameters: { contract: 'AUTO' }
    });
  }
  
  setupFeed() {
    this.send({
      type: 'FEED_SETUP',
      channel: this.channel,
      acceptAggregationPeriod: 0.1,
      acceptDataFormat: 'COMPACT',
      acceptEventFields: {
        Quote: ['eventSymbol', 'bidPrice', 'askPrice', 'bidSize', 'askSize'],
        Greeks: ['eventSymbol', 'delta', 'gamma', 'theta', 'vega', 'volatility'],
        Trade: ['eventSymbol', 'price', 'size', 'time'],
        Summary: ['eventSymbol', 'openInterest', 'dayOpenPrice', 'dayHighPrice', 'dayLowPrice']
      }
    });
  }
  
  subscribe(symbols, events = ['Quote', 'Greeks']) {
    const subscriptions = [];
    symbols.forEach(symbol => {
      events.forEach(type => {
        subscriptions.push({ type, symbol });
      });
    });
    
    this.send({
      type: 'FEED_SUBSCRIPTION',
      channel: this.channel,
      reset: true,
      add: subscriptions
    });
  }
  
  onReady(callback) {
    this.callbacks.set('ready', callback);
  }
  
  onData(callback) {
    this.callbacks.set('data', callback);
  }
  
  startKeepalive() {
    this.keepaliveInterval = setInterval(() => {
      this.send({ type: 'KEEPALIVE', channel: 0 });
    }, 30000);
  }
  
  send(message) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }
  
  disconnect() {
    if (this.keepaliveInterval) {
      clearInterval(this.keepaliveInterval);
    }
    if (this.ws) {
      this.ws.close();
    }
  }
}
Greeks Monitor
class GreeksMonitor {
  constructor(api, dxlink) {
    this.api = api;
    this.dxlink = dxlink;
    this.greeks = new Map();
  }
  
  async subscribeToPositionGreeks() {
    const positions = await this.api.refreshPositions();
    const optionSymbols = positions
      .filter(p => p['instrument-type'].includes('Option'))
      .map(p => p['streamer-symbol']);
    
    // Subscribe via DXLink
    this.dxlink.subscribe(optionSymbols, ['Greeks', 'Quote']);
    
    // Handle updates
    this.dxlink.onData((data) => {
      if (data[0] === 'Greeks') {
        this.updateGreeks(data[1]);
      }
    });
  }
  
  updateGreeks(greeksData) {
    greeksData.forEach(greek => {
      this.greeks.set(greek.eventSymbol, {
        delta: greek.delta,
        gamma: greek.gamma,
        theta: greek.theta,
        vega: greek.vega,
        iv: greek.volatility,
        timestamp: Date.now()
      });
    });
  }
  
  getPortfolioGreeks() {
    let totalDelta = 0;
    let totalGamma = 0;
    let totalTheta = 0;
    let totalVega = 0;
    
    this.greeks.forEach((greek, symbol) => {
      const position = this.api.positions.find(p => 
        p['streamer-symbol'] === symbol
      );
      
      if (position) {
        const multiplier = position.quantity * position.multiplier;
        totalDelta += greek.delta * multiplier;
        totalGamma += greek.gamma * multiplier;
        totalTheta += greek.theta * multiplier;
        totalVega += greek.vega * multiplier;
      }
    });
    
    return { totalDelta, totalGamma, totalTheta, totalVega };
  }
}

API MODE INTEGRATION
Complete API Mode Execution
async function executeFrameworkWithAPI(clientSecret, refreshToken, environment = 'production') {
  console.log('+---------------------------------------------------------------+');
  console.log('¦           ?? API MODE - TASTYWORKS INTEGRATION                ¦');
  console.log('+---------------------------------------------------------------+');
  
  try {
    // Initialize API components
    const tokenManager = new TokenManager(refreshToken, clientSecret);
    const api = new TastyTradeAPI(tokenManager, environment);
    const orderBuilder = new OrderBuilder(api);
    
    // Authenticate and initialize
    console.log('Authenticating with TastyWorks...');
    await api.initialize();
    console.log('? Connected to TastyWorks API');
    
    // Get account data
    console.log(`Account: ${api.accountNumber}`);
    console.log(`Net Liq: £${api.balance.netLiq.toLocaleString()}`);
    console.log(`BP Used: ${((api.balance.bpUsed / api.balance.totalBP) * 100).toFixed(1)}%`);
    
    // Build framework input from API data
    const userInput = [
      `£${Math.round(api.balance.netLiq)}`,
      api.formatPositionsForFramework(),
      `${((api.balance.bpUsed / api.balance.totalBP) * 100).toFixed(1)}%`,
      new Date().toLocaleDateString('en-US', { 
        weekday: 'long', 
        month: 'numeric', 
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        timeZone: 'America/New_York'
      }) + ' EST',
      'VIX ' + (await api.getQuotes(['VIX'])).data.items[0].last,
      api.balance.netLiq > 111000 ? 'Yes' : 'No'
    ].join(' | ');
    
    console.log('');
    console.log('Framework Input:', userInput);
    
    // Build market data from API
    console.log('');
    console.log('Fetching market data...');
    const searchedData = await api.buildSearchedData();
    console.log('? Market data collected');
    
    // Initialize streaming (optional)
    console.log('');
    console.log('Setting up real-time streaming...');
    const quoteToken = await api.request('/api-quote-tokens');
    const dxlink = new DXLinkStreamer(
      ENVIRONMENTS[environment.toUpperCase()].DXLINK,
      quoteToken.data.token
    );
    await dxlink.connect();
    
    // Subscribe to position Greeks
    const greeksMonitor = new GreeksMonitor(api, dxlink);
    await greeksMonitor.subscribeToPositionGreeks();
    console.log('? Streaming connected');
    
    // Execute framework analysis
    console.log('');
    console.log('Running pattern analysis...');
    const results = executeFramework(userInput, searchedData);
    
    // Enhance results with API capabilities
    if (results.success) {
      results.apiMode = true;
      results.api = api;
      results.orderBuilder = orderBuilder;
      results.greeksMonitor = greeksMonitor;
      
      // Add executable orders for recommendations
      if (results.strikeRecommendation && results.userData.dayOfWeek === 'Friday') {
        const order = await orderBuilder.build0DTESpread(
          results.strikeRecommendation.recommendation.includes('CALL') ? 'CALL' : 'PUT',
          results.strikeRecommendation.strikes,
          5.00 // Target credit
        );
        
        const dryRun = await orderBuilder.dryRun(order);
        results.strikeRecommendation.executable = {
          order,
          bpImpact: Math.abs(dryRun.data['buying-power-effect']['change-in-buying-power']),
          ready: true
        };
        
        console.log('');
        console.log('?? Order prepared for 0DTE - BP Impact: £' + 
          results.strikeRecommendation.executable.bpImpact);
      }
    }
    
    return results;
    
  } catch (error) {
    console.error('? API Error:', error.message);
    console.log('');
    console.log('Falling back to manual mode...');
    return null;
  }
}
Mode Selection Helper
function selectExecutionMode(input) {
  // Check if API mode requested
  if (input.toLowerCase().includes('mode: api')) {
    const lines = input.split('\n');
    let clientSecret, refreshToken, environment = 'production';
    
    lines.forEach(line => {
      if (line.includes('Client Secret:')) {
        clientSecret = line.split(':')[1].trim();
      }
      if (line.includes('Refresh Token:')) {
        refreshToken = line.split(':')[1].trim();
      }
      if (line.includes('Environment:')) {
        environment = line.split(':')[1].trim();
      }
    });
    
    if (clientSecret && refreshToken) {
      return { mode: 'API', clientSecret, refreshToken, environment };
    }
  }
  
  // Check if test mode
  if (input.toLowerCase().includes('test mode') || input.toLowerCase().includes("pretend it's")) {
    return { mode: 'TEST' };
  }
  
  // Default to manual mode
  return { mode: 'MANUAL', input };
}

COMPLETE PATTERN ANALYSIS CODE v16.0
// ============================================
// TOM KING PATTERN ANALYSIS - COMPLETE v16.0
// With Full API Integration Support
// ============================================
// Execute this ENTIRE code block in the analysis tool

// Configuration flags
const DEBUG = false;
const PRODUCTION = true;
const API_MODE = window.apiMode || false;

// ============================================
// SECTION 1: INPUT PARSING & VALIDATION
// ============================================

function parseAndValidateInput(inputString) {
  try {
    // Check for API mode
    if (API_MODE && window.apiData) {
      return parseAPIInput(window.apiData);
    }
    
    // Check for testing override - flexible patterns
    const testPatterns = [
      /Pretend it'?s (\w+day) (\d{1,2}\/\d{1,2}) (\d{1,2}:\d{2} [AP]M)/i,
      /Pretend it'?s (\w+) (\d{1,2}\/\d{1,2}) (\d{1,2}:\d{2})/i,
      /Pretend it'?s (\w+day) (\w+ \d{1,2})/i,
      /Pretend it'?s (\w+day)/i
    ];
    
    let overrideDay = null;
    let overrideTime = null;
    let overrideDate = null;
    let testMatch = null;
    
    for (const pattern of testPatterns) {
      testMatch = inputString.match(pattern);
      if (testMatch) {
        overrideDay = testMatch[1];
        overrideDate = testMatch[2] || new Date().toLocaleDateString();
        overrideTime = testMatch[3] || '10:15 AM';
        
        // Normalize day name
        if (overrideDay.length === 3) {
          const dayMap = {
            'Mon': 'Monday', 'Tue': 'Tuesday', 'Wed': 'Wednesday',
            'Thu': 'Thursday', 'Fri': 'Friday', 'Sat': 'Saturday', 'Sun': 'Sunday'
          };
          overrideDay = dayMap[overrideDay] || overrideDay;
        }
        
        inputString = inputString.replace(testMatch[0], '').trim();
        break;
      }
    }
    
    const parts = inputString.split('|').map(p => p.trim());
    
    if (parts.length < 6) {
      throw new Error('?? BLOCKED: Missing required input fields');
    }
    
    const parsed = {
      accountValue: parseInt(parts[0].replace(/[£,]/g, '')),
      positions: parsePositions(parts[1]),
      bpUsed: parseFloat(parts[2].replace('%', '')),
      dayOfWeek: overrideDay || parts[3].split(' ')[0],
      dateStr: overrideDate || parts[3],
      timeStr: overrideTime || extractTime(parts[3]),
      vixLevel: parseFloat(parts[4].split(' ')[1]),
      portfolioMargin: parts[5]?.toLowerCase() === 'yes',
      monthPL: parts[6] ? parseInt(parts[6].replace(/[£,]/g, '')) : 0,
      testingMode: !!overrideDay,
      apiMode: API_MODE
    };
    
    // Determine phase based on account value (PDF Pages 13-24)
    parsed.phase = getPhaseByAccountValue(parsed.accountValue);
    
    // Validate critical fields
    if (!parsed.accountValue || parsed.accountValue < 30000) {
      throw new Error('?? BLOCKED: Minimum account size £30,000 (Phase 1)');
    }
    
    if (!parsed.dayOfWeek || !['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'].includes(parsed.dayOfWeek)) {
      throw new Error('?? BLOCKED: Invalid or missing day of week');
    }
    
    // Weekend check
    if (parsed.dayOfWeek === 'Saturday' || parsed.dayOfWeek === 'Sunday') {
      parsed.isWeekend = true;
    }
    
    // Critical VIX check
    if (parsed.vixLevel == null || isNaN(parsed.vixLevel)) {
      throw new Error('? ERROR: VIX data is required - cannot proceed');
    }
    
    return { success: true, error: null, data: parsed };
  } catch (error) {
    return { success: false, error: error.message, data: null };
  }
}

function parseAPIInput(apiData) {
  return {
    success: true,
    error: null,
    data: {
      accountValue: apiData.netLiq,
      positions: apiData.positions,
      bpUsed: apiData.bpUsedPercent,
      dayOfWeek: apiData.dayOfWeek,
      dateStr: apiData.dateStr,
      timeStr: apiData.timeStr,
      vixLevel: apiData.vixLevel,
      portfolioMargin: apiData.portfolioMargin,
      monthPL: apiData.monthPL || 0,
      testingMode: false,
      apiMode: true,
      phase: getPhaseByAccountValue(apiData.netLiq)
    }
  };
}

function getPhaseByAccountValue(accountValue) {
  // Based on PDF Pages 13-24
  if (accountValue < 40000) return 1; // Phase 1: £30-40k
  if (accountValue < 60000) return 2; // Phase 2: £40-60k  
  if (accountValue < 75000) return 3; // Phase 3: £60-75k
  return 4; // Phase 4: £75k+
}

function extractTime(dateStr) {
  const timeMatch = dateStr.match(/(\d{1,2}:\d{2}\s*(?:AM|PM)?)/i);
  return timeMatch ? timeMatch[1] : '10:15 AM';
}

function parsePositions(positionsStr) {
  if (positionsStr == null || 
      positionsStr.toLowerCase() === 'none' || 
      positionsStr === '0' ||
      positionsStr.toLowerCase() === 'no positions') {
    return [];
  }
  
  const positions = [];
  
  // Flexible patterns to catch variations
  const patterns = [
    // Standard format: ES LT112 (85 DTE, 6420, +5%)
    /([A-Z0-9]+)\s+([A-Z0-9]+)\s*\((\d+)\s*DTE,\s*([0-9.]+)(?:\/weekly)?,\s*([+-]?\d+)%?\)/gi,
    // Alternative: ES strangle @ 2.80 (+15%)
    /([A-Z0-9]+)\s+([a-z]+)\s*@\s*£?([0-9.]+)\s*\(([+-]?\d+)%?\)/gi,
    // Simple format: ES LT112 +5%
    /([A-Z0-9]+)\s+([A-Z0-9]+)\s*([+-]?\d+)%/gi
  ];
  
  patterns.forEach(pattern => {
    let match;
    const str = positionsStr.replace(/\s+/g, ' ');
    pattern.lastIndex = 0;
    
    while ((match = pattern.exec(str)) !== null) {
      const ticker = match[1].toUpperCase();
      const strategy = match[2].toUpperCase();
      const dte = parseInt(match[3]) || 90;
      const entry = parseFloat(match[4]) || parseFloat(match[3]) || 0;
      const plMatch = match[5] || match[4] || match[3];
      const pl = plMatch ? parseInt(plMatch.replace('%', '')) : 0;
      
      // Check for 0 DTE position (immediate exit trigger)
      if (dte === 0 && strategy !== '0DTE') {
        console.warn(`?? WARNING: ${ticker} ${strategy} at 0 DTE - requires immediate action`);
      }
      
      // Calculate entry week for LT112
      let entryWeek = null;
      if (strategy === 'LT112') {
        const daysHeld = 120 - dte;
        entryWeek = Math.ceil((daysHeld % 30) / 7) || 1;
      }
      
      const exists = positions.some(p => 
        p.ticker === ticker && p.strategy === strategy
      );
      
      if (!exists) {
        positions.push({
          ticker,
          strategy,
          dte,
          entry,
          pl,
          bpUsed: estimateBPForPosition(ticker, strategy),
          entryWeek
        });
      }
    }
  });
  
  return positions;
}

function estimateBPForPosition(ticker, strategy) {
  // References Position Sizing by Phase (PDF Pages 13-24)
  const isMicro = ticker.startsWith('M') || ticker === 'MCL' || ticker === 'MGC';
  
  const bpMap = {
    'STRANGLE': isMicro ? 2.5 : 3.5,
    'LT112': ticker === 'ES' ? 6 : ticker === 'MES' ? 3 : 4,
    'IPMCC': 8,
    '0DTE': 2,
    'LEAP': 2,
    'BUTTERFLY': 0.5,
    'RATIO': 2,
    'DIAGONAL': 1.5,
    'BOX': 0 // Self-financing
  };
  
  return bpMap[strategy.toUpperCase()] || 3;
}

// ============================================
// SECTION 2: PHASE-BASED TICKER QUALIFICATIONS
// ============================================

function getQualifiedTickersByPhase(phase, accountValue) {
  // References PDF Pages 13-24 for phase-specific products
  const tickers = {
    core: ['ES', 'SPY', 'VIX', 'DXY'],
    tradeable: []
  };
  
  switch(phase) {
    case 1: // £30-40k (PDF Pages 13-15)
      tickers.tradeable = ['MCL', 'MGC', 'GLD', 'TLT'];
      break;
      
    case 2: // £40-60k (PDF Pages 15-18)
      tickers.tradeable = ['MCL', 'MGC', 'GLD', 'TLT', 'MES', 'MNQ', 
                          'SLV', 'XOP', '6A', 'M6E'];
      break;
      
    case 3: // £60-75k (PDF Pages 18-22)
      tickers.tradeable = ['ES', 'CL', 'GC', 'LE', 'HE', 'ZC', 'ZS', 'ZW',
                          '6E', '6B', 'ZB', 'ZN', 'TLT', 'GLD', 'SLV'];
      break;
      
    case 4: // £75k+ (PDF Pages 22-24)
      tickers.tradeable = ['ES', 'NQ', 'RTY', 'CL', 'GC', 'SI', 'NG', 
                          'RB', 'HO', 'LE', 'HE', 'ZC', 'ZS', 'ZW', 
                          'KC', 'SB', 'CC', '6E', '6B', '6A', '6C', 
                          '6J', '6S', 'ZB', 'ZN', 'ZF', 'ZT', 
                          'SPY', 'QQQ', 'IWM', 'GLD', 'SLV', 'TLT', 
                          'XLE', 'XOP'];
      break;
  }
  
  return tickers;
}

function calculateMaxPositionsByPhase(strategy, phase, accountValue) {
  // References PDF Pages 36 (Position Sizing Quick Reference)
  const limits = {
    '0DTE': {
      1: 1,  // Phase 1: £30-40k
      2: 2,  // Phase 2: £40-60k
      3: 3,  // Phase 3: £60-75k
      4: 4   // Phase 4: £75k+
    },
    'LT112': {
      1: 0,  // Not available in Phase 1
      2: 4,  // MES positions
      3: 1,  // ES position
      4: 3   // Multiple ES positions
    },
    'STRANGLE': {
      1: 1,
      2: 3,
      3: 4,
      4: 5
    },
    'IPMCC': {
      1: 1,
      2: 2,
      3: 3,
      4: 4
    },
    'LEAP': {
      1: 0,
      2: 2,
      3: 3,
      4: 10  // Full ladder system
    },
    'RATIO': {
      1: 0,
      2: 2,
      3: 4,
      4: 5
    },
    'BUTTERFLY': {
      1: 0,
      2: 0,
      3: 2,
      4: 4
    },
    'DIAGONAL': {
      1: 0,
      2: 0,
      3: 2,
      4: 4
    },
    'BOX': {
      1: 0,
      2: 0,
      3: 1,
      4: 2
    }
  };
  
  return limits[strategy.toUpperCase()]?.[phase] || 0;
}

function generatePhaseAllocationTable(userData, searchedData, concentrationStatus) {
  const { accountValue, positions, bpUsed, vixLevel, dayOfWeek, phase } = userData;
  
  // Get phase-specific strategies
  const phaseStrategies = getPhaseStrategies(phase);
  const table = [];
  let totalBPAvailable = 0;
  
  phaseStrategies.forEach(strategy => {
    const maxPos = calculateMaxPositionsByPhase(strategy, phase, accountValue);
    const currentPos = positions.filter(p => p.strategy === strategy).length;
    const bpPerPos = getPhaseAdjustedBP(strategy, phase, accountValue);
    const currentBP = currentPos * bpPerPos;
    const availablePos = maxPos - currentPos;
    const canAddBP = availablePos * bpPerPos;
    
    // Determine priority based on day and phase
    let priority = getPhasePriority(strategy, dayOfWeek, phase);
    
    table.push({
      strategy,
      maxPos,
      currentPos,
      availablePos,
      bpPerPos,
      currentBP,
      canAddBP,
      priority
    });
    
    totalBPAvailable += canAddBP;
  });
  
  return { table, totalBPAvailable, phase };
}

function getPhaseStrategies(phase) {
  // Based on PDF phase descriptions
  const strategies = {
    1: ['0DTE', 'IPMCC', 'STRANGLE'],
    2: ['0DTE', 'LT112', 'STRANGLE', 'IPMCC', 'RATIO', 'LEAP'],
    3: ['0DTE', 'LT112', 'STRANGLE', 'IPMCC', 'RATIO', 'LEAP', 'BUTTERFLY', 'DIAGONAL', 'BOX'],
    4: ['0DTE', 'LT112', 'STRANGLE', 'IPMCC', 'RATIO', 'LEAP', 'BUTTERFLY', 'DIAGONAL', 'BOX']
  };
  
  return strategies[phase] || strategies[1];
}

function getPhaseAdjustedBP(strategy, phase, accountValue) {
  // Phase-specific BP requirements
  const requirements = {
    '0DTE': 2,
    'LT112': phase >= 3 && accountValue >= 55000 ? 6 : 3,
    'STRANGLE': 3,
    'IPMCC': 8,
    'LEAP': 2,
    'RATIO': 2,
    'BUTTERFLY': 0.5,
    'DIAGONAL': 1.5,
    'BOX': 0
  };
  
  return requirements[strategy] || 3;
}

function getPhasePriority(strategy, dayOfWeek, phase) {
  // Phase-specific priorities
  let priority = 'Monitor';
  
  if (strategy === '0DTE' && dayOfWeek === 'Friday') {
    priority = 'TODAY 10:30';
  } else if (strategy === 'LT112' && dayOfWeek === 'Wednesday' && phase >= 2) {
    priority = phase >= 3 ? 'WEEKLY STACK' : 'TODAY';
  } else if (strategy === 'STRANGLE' && dayOfWeek === 'Tuesday') {
    priority = 'TODAY';
  } else if (strategy === 'IPMCC' && dayOfWeek === 'Friday') {
    priority = 'Roll today';
  } else if (strategy === 'LEAP' && dayOfWeek === 'Monday' && phase >= 2) {
    priority = 'TODAY';
  } else if (strategy === 'BUTTERFLY' && dayOfWeek === 'Friday' && phase >= 3) {
    priority = 'After 0DTE';
  } else if (strategy === 'BOX' && phase >= 3) {
    priority = 'Check rates';
  }
  
  return priority;
}

// ============================================
// SECTION 3: CORRELATION GROUPS (PDF Page 12)
// ============================================

function getAllCorrelationGroups() {
  // From PDF Page 12 - Critical Foundation section
  return {
    'A1': { 
      name: 'Equity Index Futures',
      tickers: ['ES', 'MES', 'NQ', 'MNQ', 'RTY', 'M2K', 'MYM', 'YM'],
      limit: 2,
      correlation: 'HIGH (0.85+)'
    },
    'A2': { 
      name: 'Equity ETFs',
      tickers: ['SPY', 'QQQ', 'IWM', 'DIA', 'VOO', 'VTI'],
      limit: 3,
      correlation: 'HIGH (0.80+)'
    },
    'B1': { 
      name: 'Safe Haven Metals',
      tickers: ['GC', 'MGC', 'GLD', 'IAU'],
      limit: 2,
      correlation: 'TIGHT (0.95+)'
    },
    'B2': { 
      name: 'Industrial Metals',
      tickers: ['SI', 'SIL', 'SLV', 'HG', 'PL', 'PA'],
      limit: 2,
      correlation: 'MODERATE (0.60+)'
    },
    'C1': { 
      name: 'Crude Complex',
      tickers: ['CL', 'MCL', 'QM', 'XOP', 'USO', 'UCO'],
      limit: 2,
      correlation: 'VERY HIGH (0.95+)'
    },
    'C2': { 
      name: 'Natural Gas',
      tickers: ['NG', 'UNG', 'BOIL'],
      limit: 1,
      correlation: 'INDEPENDENT'
    },
    'D1': { 
      name: 'Grains',
      tickers: ['ZC', 'ZS', 'ZW', 'ZR'],
      limit: 2,
      correlation: 'WEATHER-DRIVEN'
    },
    'D2': { 
      name: 'Proteins',
      tickers: ['LE', 'HE', 'GF'],
      limit: 1,
      correlation: 'SEASONAL'
    },
    'E': { 
      name: 'Currencies',
      tickers: ['6E', '6B', '6A', '6C', '6J', '6S', 'M6E', 'M6A', 'DX', 'FXE', 'FXB'],
      limit: 2,
      correlation: 'DOLLAR-DEPENDENT'
    }
  };
}

function checkConcentrationLimits(positions, newTicker) {
  const groups = getAllCorrelationGroups();
  
  let tickerGroup = null;
  let groupData = null;
  
  for (const [groupId, data] of Object.entries(groups)) {
    if (data.tickers.includes(newTicker)) {
      tickerGroup = groupId;
      groupData = data;
      break;
    }
  }
  
  if (!tickerGroup) {
    return { allowed: true, message: 'Ticker not in correlation matrix' };
  }
  
  const currentInGroup = positions.filter(p => 
    groupData.tickers.includes(p.ticker)
  ).length;
  
  return {
    allowed: currentInGroup < groupData.limit,
    group: tickerGroup,
    groupName: groupData.name,
    current: currentInGroup,
    limit: groupData.limit,
    message: currentInGroup >= groupData.limit ? 
      `?? BLOCKED: ${groupData.name} at maximum (${groupData.limit}) per PDF Page 12` :
      `? ${groupData.name}: ${currentInGroup}/${groupData.limit} positions`
  };
}

// ============================================
// SECTION 4: VIX REGIME & BP MANAGEMENT
// ============================================

function getVIXRegimeLimits(vixLevel) {
  // References PDF Page 12 - VIX Regimes
  let regime = '';
  let min = 40;
  let max = 50;
  
  if (vixLevel < 13) {
    regime = 'LOW';
    min = 40;
    max = 50;
  } else if (vixLevel < 18) {
    regime = 'NORMAL';
    min = 60;
    max = 70;
  } else if (vixLevel < 25) {
    regime = 'ELEVATED';
    min = 75;
    max = 80;
  } else if (vixLevel < 30) {
    regime = 'HIGH';
    min = 50;
    max = 60;
  } else {
    regime = 'CRISIS';
    min = 80;
    max = 80;
  }
  
  return { 
    regime, 
    min, 
    max,
    optimal: (min + max) / 2,
    message: `VIX ${vixLevel} = ${regime} regime: Deploy ${min}-${max}% BP (PDF Page 12)`
  };
}

function checkVIXSpikeOpportunity(vixLevel, accountValue) {
  // References PDF Page 13 - VIX Spike Protocol
  if (vixLevel > 30) {
    return {
      triggered: true,
      protocol: 'VIX SPIKE OPPORTUNITY PROTOCOL (PDF Page 13)',
      actions: [
        '1. Close all profitable strangles immediately',
        '2. Close all call sales to prevent unlimited loss',
        '3. Deploy 80% of BP into 45 DTE, 20-delta puts',
        '4. Use SPX for tax efficiency',
        '5. Ladder entries over 3 days'
      ],
      expectedReturn: '15-20% in 30-45 days',
      deployment: Math.round(accountValue * 0.8),
      warning: '?? GENERATIONAL OPPORTUNITY - Act with discipline (PDF Page 13)'
    };
  }
  return { triggered: false };
}

function calculatePhaseBPOptimization(currentBP, phase, vixRegime, availableSlots, dayOfWeek) {
  // Phase-based BP targets override VIX in lower phases
  let targetRange = vixRegime;
  
  if (phase === 1) {
    targetRange = { min: 40, max: 50 };
  } else if (phase === 2) {
    targetRange = { min: 55, max: 65 };
  } else if (phase === 3) {
    targetRange = { min: 60, max: 75 };
  }
  // Phase 4 uses full VIX regime
  
  const gap = targetRange.min - currentBP;
  const plan = [];
  let projectedBP = currentBP;
  
  if (gap <= 0) {
    return {
      needed: false,
      message: `Already at ${currentBP}% - within Phase ${phase} target`,
      plan: []
    };
  }
  
  // Phase-specific priority order
  const priorities = getPhaseOptimizationPriorities(phase, dayOfWeek, availableSlots);
  
  priorities.forEach(item => {
    if (projectedBP >= targetRange.min) return;
    
    const canAdd = item.day === 'Any' || item.day === dayOfWeek;
    if (canAdd && item.slots > 0) {
      const positionsNeeded = Math.min(
        item.slots,
        Math.ceil((targetRange.min - projectedBP) / item.bp)
      );
      
      if (positionsNeeded > 0) {
        plan.push({
          strategy: item.strategy,
          positions: positionsNeeded,
          bpAdded: positionsNeeded * item.bp,
          when: item.day === dayOfWeek ? 'TODAY' : `Next ${item.day}`
        });
        projectedBP += positionsNeeded * item.bp;
      }
    }
  });
  
  return {
    needed: true,
    currentBP,
    targetMin: targetRange.min,
    targetMax: targetRange.max,
    gap,
    projectedBP,
    plan,
    phase,
    message: plan.length > 0 ? 
      `Phase ${phase}: Add ${plan.length} position types to reach ${projectedBP}% BP usage` :
      'No available slots for optimization in current phase'
  };
}

function getPhaseOptimizationPriorities(phase, dayOfWeek, availableSlots) {
  // Phase-specific optimization priorities
  const priorities = {
    1: [ // Phase 1 priorities
      { strategy: '0DTE', bp: 2, day: 'Friday', slots: availableSlots['0DTE'] || 0 },
      { strategy: 'IPMCC', bp: 8, day: 'Any', slots: availableSlots['IPMCC'] || 0 },
      { strategy: 'Strangle', bp: 3, day: 'Tuesday', slots: availableSlots['STRANGLE'] || 0 }
    ],
    2: [ // Phase 2 priorities
      { strategy: '0DTE', bp: 2, day: 'Friday', slots: availableSlots['0DTE'] || 0 },
      { strategy: 'LT112', bp: 3, day: 'Wednesday', slots: availableSlots['LT112'] || 0 },
      { strategy: 'Strangle', bp: 3, day: 'Any', slots: availableSlots['STRANGLE'] || 0 },
      { strategy: 'Ratio', bp: 2, day: 'Tuesday', slots: availableSlots['RATIO'] || 0 },
      { strategy: 'LEAP', bp: 2, day: 'Monday', slots: availableSlots['LEAP'] || 0 }
    ],
    3: [ // Phase 3 priorities
      { strategy: '0DTE', bp: 2, day: 'Friday', slots: availableSlots['0DTE'] || 0 },
      { strategy: 'LT112', bp: 6, day: 'Wednesday', slots: availableSlots['LT112'] || 0 },
      { strategy: 'Butterfly', bp: 0.5, day: 'Friday', slots: availableSlots['BUTTERFLY'] || 0 },
      { strategy: 'Box', bp: 0, day: 'Any', slots: availableSlots['BOX'] || 0 },
      { strategy: 'Diagonal', bp: 1.5, day: 'Any', slots: availableSlots['DIAGONAL'] || 0 }
    ],
    4: [ // Phase 4 - all strategies
      { strategy: '0DTE', bp: 2, day: 'Friday', slots: availableSlots['0DTE'] || 0 },
      { strategy: 'LT112', bp: 6, day: 'Wednesday', slots: availableSlots['LT112'] || 0 },
      { strategy: 'Strangle', bp: 3, day: 'Any', slots: availableSlots['STRANGLE'] || 0 },
      { strategy: 'IPMCC', bp: 8, day: 'Any', slots: availableSlots['IPMCC'] || 0 },
      { strategy: 'LEAP', bp: 2, day: 'Monday', slots: availableSlots['LEAP'] || 0 }
    ]
  };
  
  return priorities[phase] || priorities[1];
}

// ============================================
// SECTION 5: POSITION HEALTH ANALYSIS
// ============================================

function getPDFExitTarget(strategy, targetType) {
  // References PDF Pages 9-10 - Management Protocols by DTE
  const pdfTargets = {
    'STRANGLE': { 
      profit: 50,
      dte: 21,
      reference: 'PDF Page 9 - 50% Rule'
    },
    'LT112': { 
      nakedProfit: 90,
      manageDTE: 30,
      spreadHold: true,
      reference: 'PDF Page 26 - LT112 Specs'
    },
    'IPMCC': { 
      maxLoss: -30,
      rollDTE: 90,
      weeklyTarget: 90,
      reference: 'PDF Pages 28-31 - IPMCC Specs'
    },
    '0DTE': { 
      profit: 50,
      stopMultiple: 2,
      timeStopHour: 15,
      reference: 'PDF Page 25 - 0DTE Specs'
    },
    'LEAP': {
      profit: 30,
      avgDays: 40,
      reference: 'PDF Page 28 - LEAP Specs'
    },
    'RATIO': {
      profit: 50,
      defenseDelta: 25,
      reference: 'PDF Page 32 - Ratio Specs'
    },
    'BUTTERFLY': {
      holdToExpiry: true,
      reference: 'PDF Pages 31-32 - Butterfly Specs'
    },
    'DIAGONAL': {
      profit: 50,
      vixLimit: 15,
      reference: 'PDF Pages 32-33 - Diagonal Specs'
    }
  };
  
  const strategy_upper = strategy.toUpperCase();
  if (!pdfTargets[strategy_upper]) {
    return null;
  }
  
  return pdfTargets[strategy_upper][targetType] || null;
}

function analyzePositionHealth(position) {
  let score = 100;
  let action = 'HOLD';
  let exitTrigger = false;
  
  // Check for 0 DTE emergency
  if (position.dte === 0 && position.strategy !== '0DTE') {
    exitTrigger = true;
    action = `? ERROR: 0 DTE - CLOSE IMMEDIATELY`;
    score = 0;
    return { score, action, exitTrigger };
  }
  
  try {
    switch(position.strategy.toUpperCase()) {
      case 'STRANGLE':
        const strangleProfit = getPDFExitTarget('STRANGLE', 'profit');
        const strangleDTE = getPDFExitTarget('STRANGLE', 'dte');
        const strangleRef = getPDFExitTarget('STRANGLE', 'reference');
        
        if (position.pl >= strangleProfit) {
          exitTrigger = true;
          action = `EXIT - ${strangleProfit}% TARGET (${strangleRef})`;
        } else if (position.dte <= strangleDTE) {
          exitTrigger = true;
          action = `EXIT - ${strangleDTE} DTE RULE (${strangleRef})`;
        } else if (position.pl >= 30 && position.dte <= 45) {
          action = `CONSIDER - Near profit zone`;
        }
        score = Math.max(0, 100 - (90 - position.dte) - (strangleProfit - position.pl));
        break;
        
      case 'LT112':
        const nakedTarget = getPDFExitTarget('LT112', 'nakedProfit');
        const manageDTE = getPDFExitTarget('LT112', 'manageDTE');
        const lt112Ref = getPDFExitTarget('LT112', 'reference');
        
        if (position.pl >= nakedTarget && position.dte > manageDTE) {
          action = `CLOSE NAKED PUTS - ${nakedTarget}% TARGET (${lt112Ref})`;
        } else if (position.dte <= manageDTE) {
          action = `CLOSE NAKED PUTS - ${manageDTE} DTE (${lt112Ref})`;
        } else if (position.pl >= 50) {
          action = `MONITOR - Approaching target`;
        }
        score = Math.max(0, 100 - (120 - position.dte) * 0.5);
        break;
        
      case 'IPMCC':
        const maxLoss = getPDFExitTarget('IPMCC', 'maxLoss');
        const rollDTE = getPDFExitTarget('IPMCC', 'rollDTE');
        const weeklyTarget = getPDFExitTarget('IPMCC', 'weeklyTarget');
        const ipmccRef = getPDFExitTarget('IPMCC', 'reference');
        
        if (position.pl <= maxLoss) {
          exitTrigger = true;
          action = `EXIT - ${Math.abs(maxLoss)}% LEAP LOSS (${ipmccRef})`;
        } else if (position.dte <= rollDTE) {
          action = `ROLL LEAP - <${rollDTE} DTE (${ipmccRef})`;
        } else if (position.weeklyPL && position.weeklyPL >= weeklyTarget) {
          action = `CLOSE WEEKLY - ${weeklyTarget}% TARGET`;
        }
        score = Math.max(0, 100 - Math.abs(position.pl));
        break;
        
      case '0DTE':
        const profitTarget = getPDFExitTarget('0DTE', 'profit');
        const stopMultiple = getPDFExitTarget('0DTE', 'stopMultiple');
        const timeStopHour = getPDFExitTarget('0DTE', 'timeStopHour');
        const odteRef = getPDFExitTarget('0DTE', 'reference');
        const hour = new Date().getHours();
        
        if (position.pl >= profitTarget) {
          exitTrigger = true;
          action = `EXIT - ${profitTarget}% TARGET (${odteRef})`;
        } else if (position.pl <= -(stopMultiple * 100)) {
          exitTrigger = true;
          action = `EXIT - ${stopMultiple}X STOP (${odteRef})`;
        } else if (hour >= timeStopHour) {
          exitTrigger = true;
          action = `EXIT - ${timeStopHour}:00 TIME STOP (${odteRef})`;
        } else if (hour >= 14) {
          action = `PREPARE - Approaching time stop`;
        }
        score = position.pl >= 0 ? 75 : 25;
        break;
        
      case 'LEAP':
        const leapProfit = getPDFExitTarget('LEAP', 'profit');
        const avgDays = getPDFExitTarget('LEAP', 'avgDays');
        const leapRef = getPDFExitTarget('LEAP', 'reference');
        
        if (position.pl >= leapProfit) {
          exitTrigger = true;
          action = `EXIT - ${leapProfit}% TARGET (${leapRef})`;
        } else if (position.daysHeld >= avgDays) {
          action = `EVALUATE - Past ${avgDays} day average`;
        }
        score = Math.max(0, 100 - (position.daysHeld / avgDays * 50));
        break;
        
      case 'RATIO':
        const ratioProfit = getPDFExitTarget('RATIO', 'profit');
        const defenseDelta = getPDFExitTarget('RATIO', 'defenseDelta');
        const ratioRef = getPDFExitTarget('RATIO', 'reference');
        
        if (position.pl >= ratioProfit) {
          exitTrigger = true;
          action = `EXIT - ${ratioProfit}% TARGET (${ratioRef})`;
        } else if (position.testDelta >= defenseDelta) {
          action = `DEFEND - Delta ${defenseDelta} reached (${ratioRef})`;
        }
        score = Math.max(0, 100 - Math.abs(position.pl) * 2);
        break;
        
      case 'BUTTERFLY':
        const butterflyRef = getPDFExitTarget('BUTTERFLY', 'reference');
        action = `HOLD TO EXPIRY (${butterflyRef})`;
        score = 50; // Neutral score for hold strategies
        break;
        
      case 'DIAGONAL':
        const diagProfit = getPDFExitTarget('DIAGONAL', 'profit');
        const vixLimit = getPDFExitTarget('DIAGONAL', 'vixLimit');
        const diagRef = getPDFExitTarget('DIAGONAL', 'reference');
        
        if (position.pl >= diagProfit) {
          exitTrigger = true;
          action = `EXIT - ${diagProfit}% TARGET (${diagRef})`;
        } else if (position.currentVIX > vixLimit) {
          exitTrigger = true;
          action = `EXIT - VIX >${vixLimit} (${diagRef})`;
        }
        score = Math.max(0, 100 - Math.abs(position.pl));
        break;
        
      default:
        action = 'MONITOR - Check PDF for rules';
    }
  } catch (error) {
    action = '? ERROR - Manual review required';
  }
  
  return { score, action, exitTrigger };
}

// ============================================
// SECTION 6: PATTERN ANALYSIS WITH STRIKES
// ============================================

function analyzePatternWithStrikes(ticker, marketData, phase) {
  try {
    if (marketData == null) {
      return {
        ticker,
        quality: '? NO MARKET DATA',
        score: 0,
        recommendation: 'AWAITING SEARCHES',
        visual: '?',
        error: 'No market data object provided'
      };
    }
    
    // Check if ticker is on Never Trade List (PDF Pages 6-7)
    const neverTradeList = ['OJ', 'LBS', 'DX', 'VX', 'NG', 'ZR', 'PA'];
    if (neverTradeList.includes(ticker)) {
      return {
        ticker,
        quality: '?? NEVER TRADE',
        score: 0,
        recommendation: 'Tom avoids this product (PDF Page 6-7)',
        visual: '??',
        error: 'On Never Trade List'
      };
    }
    
    // Special handling for NG (Natural Gas) - Phase 4 only with experience
    if (ticker === 'NG' && phase < 4) {
      return {
        ticker,
        quality: '?? REQUIRES PHASE 4',
        score: 0,
        recommendation: 'Natural Gas requires 2+ years experience',
        visual: '??',
        error: 'Not qualified for this phase'
      };
    }
    
    if (marketData[ticker] == null) {
      return {
        ticker,
        quality: '? NO DATA',
        score: 0,
        recommendation: 'SEARCH REQUIRED',
        visual: '?',
        error: `No data for ${ticker} - execute searches`
      };
    }
    
    const data = marketData[ticker];
    
    // Validate required fields exist
    const requiredFields = ['currentPrice', 'high20d', 'low20d'];
    const missingFields = requiredFields.filter(field => data[field] == null);
    
    if (missingFields.length > 0) {
      return {
        ticker,
        quality: '? INCOMPLETE DATA',
        score: 0,
        recommendation: 'PARTIAL DATA ONLY',
        visual: '?',
        error: `Missing fields: ${missingFields.join(', ')}`
      };
    }
    
    // Calculate metrics with null checks
    const range20d = data.high20d != null && data.low20d != null && data.currentPrice != null ? 
      ((data.high20d - data.low20d) / data.currentPrice) * 100 : null;
    
    const dayChange = data.currentPrice != null && data.openPrice != null ? 
      ((data.currentPrice - data.openPrice) / data.openPrice) * 100 : 0;
    
    const ivRank = data.ivRank || 0;
    const ivPercentile = data.ivPercentile || ivRank;
    
    // Get thresholds from PDF (Page 27)
    const excellentRange = 5;  // <5% range
    const excellentIV = 50;     // >50th percentile
    const goodRange = 10;       // <10% range
    const goodIV = 30;          // >30th percentile
    
    let quality = '?? POOR';
    let score = 0;
    let visual = '??';
    let specificRecommendation = null;
    
    // Pattern quality assessment
    if (range20d == null) {
      quality = '? CANNOT CALCULATE';
      visual = '?';
      score = 0;
    } else if (range20d < excellentRange && ivRank > excellentIV) {
      quality = '?? EXCELLENT';
      score = 95;
      visual = '??';
      
      // Generate specific recommendation with strikes
      if (data.optionChain && data.optionChain.put5Delta && data.optionChain.call5Delta) {
        const putBid = data.optionChain.put5DeltaBid || 'SEARCH REQUIRED';
        const callBid = data.optionChain.call5DeltaBid || 'SEARCH REQUIRED';
        const totalCredit = (putBid !== 'SEARCH REQUIRED' && callBid !== 'SEARCH REQUIRED') ?
          (putBid + callBid).toFixed(2) : 'CALCULATE';
        
        specificRecommendation = {
          type: 'STRANGLE',
          putStrike: data.optionChain.put5Delta,
          putBid: putBid,
          callStrike: data.optionChain.call5Delta,
          callBid: callBid,
          totalCredit: totalCredit,
          bpRequired: estimateBPForPosition(ticker, 'STRANGLE'),
          entry: 'ENTER NOW - Meets all criteria'
        };
      }
    } else if (range20d < goodRange && ivRank > goodIV) {
      quality = '?? GOOD';
      score = 75;
      visual = '??';
      
      // Still provide strikes but with monitoring note
      if (data.optionChain && data.optionChain.put5Delta && data.optionChain.call5Delta) {
        specificRecommendation = {
          type: 'STRANGLE',
          putStrike: data.optionChain.put5Delta,
          callStrike: data.optionChain.call5Delta,
          note: 'Monitor for improvement - near entry criteria'
        };
      }
    } else if (range20d < 15 && ivRank > 20) {
      quality = '?? FAIR';
      score = 50;
      visual = '??';
    } else {
      quality = '?? AVOID';
      score = 25;
      visual = '??';
    }
    
    // Phase-specific adjustments
    if (phase <= 2 && !['MCL', 'MGC', 'GLD', 'TLT', 'MES', 'MNQ'].includes(ticker)) {
      quality = '? NOT QUALIFIED';
      visual = '?';
      score = 0;
      recommendation = `Requires Phase ${ticker === 'ES' ? 3 : 4}`;
    }
    
    // Generate recommendation text
    let recommendation = 'WAIT';
    if (specificRecommendation) {
      if (specificRecommendation.entry) {
        recommendation = `${specificRecommendation.putStrike}P / ${specificRecommendation.callStrike}C @ £${specificRecommendation.totalCredit}`;
      } else if (specificRecommendation.note) {
        recommendation = `${specificRecommendation.putStrike}P / ${specificRecommendation.callStrike}C - ${specificRecommendation.note}`;
      }
    } else if (visual === '??') {
      recommendation = 'AVOID - Outside PDF parameters';
    } else if (visual === '?') {
      recommendation = 'INCOMPLETE - Need option chain data';
    }
    
    return {
      ticker,
      quality,
      score,
      visual,
      recommendation,
      specificRecommendation,
      phase,
      metrics: {
        currentPrice: data.currentPrice,
        dayChange: dayChange != null ? dayChange.toFixed(2) : 'N/A',
        range20d: range20d != null ? range20d.toFixed(1) : 'N/A',
        ivRank: ivRank || 'NO DATA',
        ivPercentile: ivPercentile || 'NO DATA'
      }
    };
  } catch (error) {
    return {
      ticker,
      quality: '? ERROR',
      score: 0,
      recommendation: 'ANALYSIS FAILED',
      visual: '?',
      error: error.message
    };
  }
}

// ============================================
// SECTION 7: AUGUST 2024 LESSON IMPLEMENTATION
// ============================================

function checkAugust2024Rules(positions, newPosition) {
  // Implements lessons from £308k loss (PDF Pages 7-8)
  const warnings = [];
  
  // Rule 1: Never exceed 3 positions in same correlation group
  const groups = getAllCorrelationGroups();
  for (const [groupId, data] of Object.entries(groups)) {
    const groupPositions = positions.filter(p => data.tickers.includes(p.ticker));
    if (groupPositions.length >= 3) {
      warnings.push(`?? AUGUST 2024 WARNING: ${data.name} approaching limit (Tom lost £308k with 6 correlated)`);
    }
  }
  
  // Rule 2: Check for same expiration clustering
  const expirationMap = {};
  positions.forEach(p => {
    if (!expirationMap[p.dte]) expirationMap[p.dte] = [];
    expirationMap[p.dte].push(p);
  });
  
  Object.entries(expirationMap).forEach(([dte, positions]) => {
    if (positions.length >= 3) {
      warnings.push(`?? AUGUST 2024 WARNING: ${positions.length} positions at ${dte} DTE (diversify expirations)`);
    }
  });
  
  // Rule 3: Check total directional exposure
  const bullishCount = positions.filter(p => 
    ['LT112', 'LEAP', 'IPMCC'].includes(p.strategy)
  ).length;
  
  if (bullishCount >= 4) {
    warnings.push(`?? AUGUST 2024 WARNING: ${bullishCount} bullish positions (Tom had 6 when VIX spiked)`);
  }
  
  return warnings;
}

// ============================================
// SECTION 8: CAPITAL OPTIMIZATION
// ============================================

function identifyCapitalRecycling(positions, currentTime) {
  const recyclable = [];
  let totalBPFreed = 0;
  
  positions.forEach(p => {
    let shouldRecycle = false;
    let reason = '';
    
    try {
      switch(p.strategy.toUpperCase()) {
        case 'STRANGLE':
          if (p.pl >= 50) {
            shouldRecycle = true;
            reason = '50% profit target hit (PDF Page 9)';
          } else if (p.dte <= 21) {
            shouldRecycle = true;
            reason = '21 DTE exit rule (PDF Page 9)';
          }
          break;
          
        case 'LT112':
          if (p.pl >= 90 && p.dte > 30) {
            shouldRecycle = true;
            reason = '90% naked put target (PDF Page 26)';
          } else if (p.dte <= 30) {
            shouldRecycle = true;
            reason = 'Close naked puts at 30 DTE (PDF Page 26)';
          }
          break;
          
        case '0DTE':
          if (currentTime && currentTime.hour >= 14 && currentTime.minute >= 30) {
            shouldRecycle = true;
            reason = '2:30 PM profit taking (PDF Page 25)';
          }
          break;
          
        case 'RATIO':
          if (p.pl >= 50) {
            shouldRecycle = true;
            reason = '50% profit target (PDF Page 32)';
          }
          break;
          
        case 'DIAGONAL':
          if (p.pl >= 50) {
            shouldRecycle = true;
            reason = '50% of max profit (PDF Page 33)';
          }
          break;
      }
      
      if (shouldRecycle) {
        const bpToFree = p.bpUsed || estimateBPForPosition(p.ticker, p.strategy);
        recyclable.push({
          position: `${p.ticker} ${p.strategy}`,
          reason,
          bpToFree
        });
        totalBPFreed += bpToFree;
      }
    } catch (error) {
      if (DEBUG) console.error(`Recycling analysis error for position:`, p);
    }
  });
  
  return {
    count: recyclable.length,
    positions: recyclable,
    totalBPFreed,
    redeploymentOptions: calculateRedeployment(totalBPFreed)
  };
}

function calculateRedeployment(freedBP) {
  const options = [];
  
  if (freedBP >= 8) {
    options.push('IPMCC position (8% BP)');
  }
  if (freedBP >= 6) {
    options.push('ES LT112 position (6% BP)');
  }
  if (freedBP >= 3) {
    options.push(`${Math.floor(freedBP / 3)} strangle positions (3% each)`);
  }
  if (freedBP >= 2) {
    options.push(`${Math.floor(freedBP / 2)} 0DTE or ratio positions (2% each)`);
  }
  
  return options.length > 0 ? options : ['Insufficient BP for new positions'];
}

function calculateSPANCredits(positions, portfolioMargin, accountValue) {
  if (!portfolioMargin) return { credits: [], totalSaved: 0 };
  
  // SPAN correlation pairs from PDF (Portfolio Margin discussion)
  const spanPairs = [
    // Energy complex
    { pair: ['CL', 'RB'], reduction: 30, name: 'Energy crack spread' },
    { pair: ['CL', 'HO'], reduction: 28, name: 'Crude/Heating oil' },
    { pair: ['RB', 'HO'], reduction: 25, name: 'Refined products' },
    { pair: ['CL', 'NG'], reduction: 15, name: 'Energy diversification' },
    
    // Metals
    { pair: ['GC', 'SI'], reduction: 25, name: 'Precious metals' },
    { pair: ['GC', 'HG'], reduction: 20, name: 'Gold/Copper' },
    { pair: ['SI', 'PL'], reduction: 22, name: 'Silver/Platinum' },
    
    // Equity indices
    { pair: ['ES', 'NQ'], reduction: 20, name: 'Equity indices' },
    { pair: ['ES', 'RTY'], reduction: 18, name: 'Large/Small cap' },
    { pair: ['NQ', 'RTY'], reduction: 15, name: 'Tech/Small cap' },
    
    // Agriculture
    { pair: ['ZC', 'ZS'], reduction: 15, name: 'Grain complex' },
    { pair: ['ZC', 'ZW'], reduction: 14, name: 'Corn/Wheat' },
    { pair: ['ZS', 'ZW'], reduction: 12, name: 'Soy/Wheat' },
    { pair: ['LE', 'HE'], reduction: 10, name: 'Meat complex' },
    
    // Fixed Income
    { pair: ['ZB', 'ZN'], reduction: 18, name: 'Duration spread' },
    { pair: ['ZN', 'ZF'], reduction: 15, name: 'Yield curve' },
    
    // Currencies
    { pair: ['6E', '6B'], reduction: 12, name: 'European currencies' },
    { pair: ['6A', '6C'], reduction: 10, name: 'Commodity currencies' },
    { pair: ['6J', '6S'], reduction: 8, name: 'Safe haven FX' }
  ];
  
  const credits = [];
  let totalSaved = 0;
  
  spanPairs.forEach(span => {
    const hasFirst = positions.some(p => p.ticker === span.pair[0]);
    const hasSecond = positions.some(p => p.ticker === span.pair[1]);
    
    if (hasFirst && hasSecond) {
      const saving = Math.round(accountValue * (span.reduction / 100) * 0.01);
      credits.push({
        pair: span.name,
        tickers: `${span.pair[0]}/${span.pair[1]}`,
        reduction: `${span.reduction}%`,
        bpFreed: saving,
        note: 'Portfolio Margin benefit'
      });
      totalSaved += saving;
    }
  });
  
  // Diversification bonus
  const uniqueGroups = new Set();
  positions.forEach(p => {
    const groups = getAllCorrelationGroups();
    for (const [groupId, data] of Object.entries(groups)) {
      if (data.tickers.includes(p.ticker)) {
        uniqueGroups.add(groupId);
        break;
      }
    }
  });
  
  if (uniqueGroups.size >= 4) {
    const diversificationCredit = Math.round(accountValue * 0.05 * 0.01);
    credits.push({
      pair: 'Diversification Bonus',
      tickers: `${uniqueGroups.size} groups`,
      reduction: '5%',
      bpFreed: diversificationCredit,
      note: 'Multi-group diversification'
    });
    totalSaved += diversificationCredit;
  }
  
  return { credits, totalSaved };
}

// ============================================
// SECTION 9: STRATEGY-SPECIFIC ANALYSIS
// ============================================

function analyzeWeeklyStaggering(positions, accountValue, currentDate, phase) {
  // PDF Page 26 - LT112 Stacking
  if (phase < 2) {
    return {
      product: 'N/A',
      recommendation: 'LT112 not available until Phase 2',
      note: 'Minimum £40k required'
    };
  }
  
  if (accountValue < 55000) {
    return {
      product: 'MES',
      recommendation: 'Can add multiple MES positions',
      note: 'No staggering required for MES (PDF Page 26)'
    };
  }
  
  const weekOfMonth = Math.ceil(currentDate.getDate() / 7);
  
  const existingWeeks = positions
    .filter(p => p.strategy === 'LT112')
    .map(p => p.entryWeek || 1);
  
  const staggering = {
    currentWeek: weekOfMonth,
    product: 'ES',
    weeksOpen: [1, 2, 3, 4].filter(w => !existingWeeks.includes(w)),
    sizing: {
      1: 'FULL SIZE - Primary entry',
      2: '50% SIZE - Averaging in',
      3: '50% SIZE - Final average',
      4: 'SKIP - Preserve capital'
    }[weekOfMonth],
    recommendation: 'WAIT'
  };
  
  if (staggering.weeksOpen.includes(weekOfMonth) && weekOfMonth !== 4) {
    staggering.recommendation = 'ADD POSITION';
  } else if (weekOfMonth === 4) {
    staggering.recommendation = 'SKIP THIS WEEK';
  }
  
  return staggering;
}

function calculate0DTECountdown(currentTime) {
  // PDF Page 25 - 0DTE Complete Specs
  if (currentTime == null || currentTime.dayOfWeek !== 'Friday') {
    return null;
  }
  
  if (currentTime.isWeekend) {
    return {
      timeRemaining: -1,
      message: 'MARKET CLOSED - WEEKEND',
      phase: 'CLOSED'
    };
  }
  
  const targetHour = 10;
  const targetMinute = 30;
  
  const now = currentTime.hour * 60 + currentTime.minute;
  const target = targetHour * 60 + targetMinute;
  
  if (now >= target) {
    if (currentTime.hour < 15) {
      return { 
        timeRemaining: 0, 
        message: 'EXECUTION WINDOW OPEN - ENTER NOW',
        phase: 'EXECUTE',
        status: '?? ACTIVE'
      };
    } else if (currentTime.hour < 16) {
      return {
        timeRemaining: -1,
        message: 'APPROACHING 3PM TIME STOP',
        phase: 'CLOSING',
        status: '?? MANAGE'
      };
    } else {
      return {
        timeRemaining: -1,
        message: '0DTE WINDOW CLOSED',
        phase: 'CLOSED',
        status: '?? DONE'
      };
    }
  }
  
  const minutesRemaining = target - now;
  const hours = Math.floor(minutesRemaining / 60);
  const minutes = minutesRemaining % 60;
  
  let phase = '';
  let status = '';
  
  if (currentTime.hour < 9 || (currentTime.hour === 9 && currentTime.minute < 30)) {
    phase = 'OVERNIGHT ASSESSMENT';
    status = '?? PREPARING';
  } else if (currentTime.hour === 9 && currentTime.minute >= 30) {
    phase = 'OPENING RANGE DEVELOPMENT';
    status = '?? ANALYZING';
  } else {
    phase = 'FINAL PREPARATION';
    status = '?? READY';
  }
  
  const timeStr = hours > 0 ? 
    `${hours}h ${minutes}m until 10:30 AM entry` :
    `${minutes} minutes until 10:30 AM entry`;
  
  return {
    timeRemaining: minutesRemaining,
    message: timeStr,
    phase,
    status,
    currentMarketTime: `${currentTime.hour}:${String(currentTime.minute).padStart(2, '0')} EST`
  };
}

function calculate0DTEStrikes(esPrice, percentMove, optionChainData) {
  // PDF Page 25 - Strike Selection Formula
  const movement = percentMove || 0;
  const trigger = esPrice * 0.005; // 0.5% trigger
  const callTrigger = esPrice + trigger;
  const putTrigger = esPrice - trigger;
  
  const round5 = (x) => Math.round(x / 5) * 5;
  
  const strikes = {
    currentPrice: esPrice,
    movement: `${movement > 0 ? '+' : ''}${movement.toFixed(2)}%`,
    openPrice: optionChainData?.openPrice || esPrice - (esPrice * movement / 100),
    recommendation: '',
    strikes: {},
    creditSource: 'PENDING SEARCH'
  };
  
  // Use actual option chain data if available
  if (optionChainData && optionChainData.call30Wide && optionChainData.put30Wide) {
    if (movement > 0.5) {
      strikes.recommendation = '?? CALL SPREAD (Fade the rally)';
      strikes.strikes = {
        short: optionChainData.call30Wide.shortStrike,
        long: optionChainData.call30Wide.longStrike,
        bid: optionChainData.call30Wide.bid || 'SEARCH REQUIRED',
        ask: optionChainData.call30Wide.ask || 'SEARCH REQUIRED',
        credit: optionChainData.call30Wide.credit || 'SEARCH: ES 0DTE call spread'
      };
      strikes.creditSource = 'FROM OPTION CHAIN';
    } else if (movement < -0.5) {
      strikes.recommendation = '?? PUT SPREAD (Fade the drop)';
      strikes.strikes = {
        short: optionChainData.put30Wide.shortStrike,
        long: optionChainData.put30Wide.longStrike,
        bid: optionChainData.put30Wide.bid || 'SEARCH REQUIRED',
        ask: optionChainData.put30Wide.ask || 'SEARCH REQUIRED',
        credit: optionChainData.put30Wide.credit || 'SEARCH: ES 0DTE put spread'
      };
      strikes.creditSource = 'FROM OPTION CHAIN';
    } else {
      strikes.recommendation = '?? IRON CONDOR (Range day)';
      strikes.strikes = {
        putShort: optionChainData.ironCondor?.putShort || round5(esPrice - 60),
        putLong: optionChainData.ironCondor?.putLong || round5(esPrice - 90),
        callShort: optionChainData.ironCondor?.callShort || round5(esPrice + 60),
        callLong: optionChainData.ironCondor?.callLong || round5(esPrice + 90),
        putCredit: optionChainData.ironCondor?.putCredit || 'SEARCH REQUIRED',
        callCredit: optionChainData.ironCondor?.callCredit || 'SEARCH REQUIRED',
        totalCredit: optionChainData.ironCondor?.totalCredit || 'SEARCH: ES 0DTE IC'
      };
      strikes.creditSource = optionChainData.ironCondor ? 'FROM OPTION CHAIN' : 'SEARCH REQUIRED';
    }
  } else {
    // No option chain data - indicate searches required
    if (movement > 0.5) {
      strikes.recommendation = '?? CALL SPREAD (Search for strikes)';
      strikes.strikes = {
        short: round5(esPrice + 20),
        long: round5(esPrice + 50),
        credit: 'EXECUTE SEARCH: "ES 0DTE call spread 30-wide credit"'
      };
    } else if (movement < -0.5) {
      strikes.recommendation = '?? PUT SPREAD (Search for strikes)';
      strikes.strikes = {
        short: round5(esPrice - 20),
        long: round5(esPrice - 50),
        credit: 'EXECUTE SEARCH: "ES 0DTE put spread 30-wide credit"'
      };
    } else {
      strikes.recommendation = '?? IRON CONDOR (Search for strikes)';
      strikes.strikes = {
        putShort: round5(esPrice - 60),
        putLong: round5(esPrice - 90),
        callShort: round5(esPrice + 60),
        callLong: round5(esPrice + 90),
        credit: 'EXECUTE SEARCH: "ES 0DTE iron condor credit"'
      };
    }
    strikes.creditSource = '? NO OPTION CHAIN DATA - SEARCH REQUIRED';
  }
  
  // Add trigger levels
  strikes.triggers = {
    callTrigger: round5(callTrigger),
    putTrigger: round5(putTrigger),
    neutralZone: `${round5(putTrigger)} - ${round5(callTrigger)}`
  };
  
  // Add API execution readiness
  if (API_MODE && window.orderBuilder) {
    strikes.apiReady = true;
    strikes.executable = true;
  }
  
  return strikes;
}
// ============================================
// SECTION 9B: PDF-SPECIFIED STRATEGY IMPLEMENTATIONS
// These implementations complete the framework by adding
// specific calculations from the PDF that were referenced
// but not fully implemented in previous versions
// ============================================

// --------------------------------------------
// BOX SPREAD CALCULATIONS (PDF Page 31)
// --------------------------------------------
function calculateBoxSpreadOpportunity(accountValue, currentRates, searchedData) {
  // Only available for Phase 3+ (£55k+) per PDF
  if (accountValue < 55000) {
    return {
      available: false,
      reason: 'Requires £55k+ account (Phase 3)',
      pdfReference: 'Page 19 - £55k threshold'
    };
  }
  
  // PDF Page 31: Annual Rate = ((Box Width / Price Paid) - 1) × (365 / DTE) × 100
  const evaluateBoxSpread = (width, price, dte) => {
    const annualRate = ((width / price) - 1) * (365 / dte) * 100;
    
    // PDF Page 31: Acceptable rates
    if (annualRate < 1.0) {
      return { rate: annualRate, action: 'EXECUTE MAXIMUM SIZE', quality: 'EXCELLENT' };
    } else if (annualRate < 1.5) {
      return { rate: annualRate, action: 'EXECUTE STANDARD SIZE', quality: 'GOOD' };
    } else if (annualRate < 2.0) {
      return { rate: annualRate, action: 'EXECUTE SMALL SIZE', quality: 'MARGINAL' };
    } else {
      return { rate: annualRate, action: 'SKIP - USE MARGIN', quality: 'POOR' };
    }
  };
  
  // PDF Page 31: Execution best practices
  const executionRules = {
    orderType: 'LIMIT ONLY',
    startPrice: 'Mid - 0.2%',
    increment: '0.05%',
    maxIterations: 8,
    timeRestriction: 'RTH only',
    product: 'SPX only',
    width: 500, // Standard width from PDF
    targetDTE: [365, 730] // 1-2 years from PDF
  };
  
  // Calculate potential BP freed (PDF Page 19)
  const bpFreed = Math.min(20000, accountValue * 0.25);
  const annualCost = bpFreed * 0.01; // 1% cost from PDF
  const monthlyBenefit = (bpFreed * 0.08) / 12; // 8% return on freed capital
  
  return {
    available: true,
    product: 'SPX',
    width: executionRules.width,
    evaluation: searchedData?.SPX?.boxSpreadRate ? 
      evaluateBoxSpread(500, searchedData.SPX.boxSpreadPrice, 365) :
      { action: 'SEARCH REQUIRED', query: 'SPX 365 DTE 500-point box spread price' },
    bpImpact: `Frees £${bpFreed.toLocaleString()} BP`,
    annualCost: `£${annualCost.toFixed(0)}`,
    monthlyBenefit: `£${monthlyBenefit.toFixed(0)} additional income potential`,
    executionRules,
    pdfReference: 'Pages 19, 31 - Box Spread Complete Specs'
  };
}

// --------------------------------------------
// BUTTERFLY STRIKE MATRIX (PDF Pages 31-32)
// --------------------------------------------
function calculateButterflyMatrix(esPrice, percentMove, accountValue, phase) {
  // PDF Page 19: Available at Phase 3+ (£45k+)
  if (phase < 3) {
    return {
      available: false,
      reason: `Phase ${phase} - Requires Phase 3+ for butterflies`,
      pdfReference: 'Page 19 - Phase 3 strategies'
    };
  }
  
  const butterfly = {
    product: 'SPX',
    entry: 'Friday 10:35 AM (after 0DTE)',
    width: 10, // PDF Page 31: 10 points symmetrical
    maxRisk: Math.min(400, accountValue * 0.003), // PDF Page 32: 0.3% weekly
    maxContracts: 5, // PDF Page 32: Maximum 5 butterflies
    pdfReference: 'Pages 31-32 - Butterfly Complete Specs'
  };
  
  // PDF Page 31-32: Strike Selection Matrix
  if (percentMove > 1.0) {
    // After 1% up move
    butterfly.center = Math.round((esPrice - 10) / 5) * 5;
    butterfly.type = 'PUT';
    butterfly.bias = 'Fade the rally';
    butterfly.rationale = 'After 1% up move - put butterfly (PDF Page 31)';
  } else if (percentMove < -1.0) {
    // After 1% down move
    butterfly.center = Math.round((esPrice + 10) / 5) * 5;
    butterfly.type = 'CALL';
    butterfly.bias = 'Fade the drop';
    butterfly.rationale = 'After 1% down move - call butterfly (PDF Page 31)';
  } else if (Math.abs(percentMove) > 0.5) {
    // After 0.5% move either way
    butterfly.center = Math.round(esPrice / 5) * 5;
    butterfly.type = percentMove > 0 ? 'PUT' : 'CALL';
    butterfly.bias = 'Fade the direction';
    butterfly.rationale = 'After 0.5% move - fade direction (PDF Page 32)';
  } else {
    return {
      available: false,
      reason: 'Insufficient movement for butterfly entry',
      currentMove: `${percentMove.toFixed(2)}%`,
      requirement: 'Need >0.5% move',
      pdfReference: 'Page 31 - Strike Selection Matrix'
    };
  }
  
  // Complete strike calculation
  butterfly.strikes = {
    lower: butterfly.center - butterfly.width,
    center: butterfly.center,
    upper: butterfly.center + butterfly.width
  };
  
  // Position sizing from PDF
  butterfly.contracts = Math.min(
    Math.floor(butterfly.maxRisk / 250), // Assume $250 debit
    butterfly.maxContracts
  );
  
  // Expected outcome from PDF Page 9
  butterfly.winRate = '15-20%';
  butterfly.targetReturn = '10:1 reward/risk';
  butterfly.management = 'Hold to expiration (PDF Page 32)';
  
  return butterfly;
}

// --------------------------------------------
// LEAP LADDER SYSTEM (PDF Page 28)
// --------------------------------------------
function executeLEAPLadderSystem(existingLEAPs, accountValue, phase, dayOfWeek, vixLevel) {
  // PDF Page 17: Available at Phase 2+ (£37k+)
  if (accountValue < 37000) {
    return {
      available: false,
      reason: 'Requires £37k+ (Phase 2 enhanced)',
      pdfReference: 'Page 17 - £37k threshold'
    };
  }
  
  // PDF Page 28: Only on Mondays
  if (dayOfWeek !== 'Monday') {
    return {
      available: false,
      reason: 'LEAP entries on Monday only',
      nextEntry: 'Next Monday',
      pdfReference: 'Page 28 - Monday entry rule'
    };
  }
  
  const ladder = {
    product: 'SPY',
    maxPositions: phase >= 4 ? 10 : 4, // PDF Page 28: 10 for Phase 4
    currentCount: existingLEAPs.length,
    dte: 365,
    pdfReference: 'Page 28 - LEAP Ladder Specifications'
  };
  
  // PDF Page 28: The Ladder System
  const weekOfMonth = Math.ceil(new Date().getDate() / 7);
  const deltaByWeek = [12, 13, 14, 12]; // Rotating deltas from PDF
  ladder.targetDelta = deltaByWeek[weekOfMonth - 1] || 12;
  
  // PDF Page 33: VIX optimization for weekly entry
  if (vixLevel < 15) {
    ladder.action = 'SKIP';
    ladder.reason = 'VIX <15 - Skip week (PDF Page 33)';
  } else if (vixLevel > 20) {
    ladder.action = 'DOUBLE SIZE';
    ladder.multiplier = 2;
    ladder.reason = 'VIX >20 - Double size (PDF Page 33)';
  } else {
    ladder.action = 'STANDARD ENTRY';
    ladder.multiplier = 1;
  }
  
  // Management rules from PDF Page 28
  ladder.management = {
    profitTarget: 30, // 30% from PDF
    averageHoldDays: 40,
    rollTrigger: 150, // DTE for rolling
    expectedCredit: 400, // $400 from PDF
    monthlyTarget: '£200-300'
  };
  
  // Check existing positions for profit taking
  ladder.closures = existingLEAPs.filter(p => 
    p.pl >= 30 || p.dte < 150
  ).map(p => ({
    position: p.ticker,
    reason: p.pl >= 30 ? '30% profit target' : '<150 DTE roll trigger',
    action: 'CLOSE'
  }));
  
  // Calculate if we can add new position
  if (ladder.currentCount < ladder.maxPositions && ladder.action !== 'SKIP') {
    ladder.newEntry = {
      delta: ladder.targetDelta,
      contracts: ladder.multiplier,
      strikeCalculation: 'SPY price × (1 - delta/100)',
      expectedPremium: `£${400 * ladder.multiplier}`
    };
  }
  
  return ladder;
}

// --------------------------------------------
// SEASONAL OVERLAY SYSTEM (PDF Pages 34-35)
// --------------------------------------------
function applySeasonalOverlay(currentMonth, positions, phase) {
  // Complete month-by-month overlay from PDF Pages 34-35
  const seasonalMatrix = {
    1: { // January
      actions: ['Short bonds (rate decisions)', 'Load tech for earnings'],
      avoid: ['New agricultural positions'],
      focus: 'Tax loss harvest completed',
      allocation: { equity: 0.7, bonds: -0.2, commodities: 0.3 }
    },
    2: { // February
      actions: ['Spring rally begins', 'Add equity exposure'],
      avoid: ['Safe haven reduction too early'],
      focus: 'Momentum building',
      allocation: { equity: 0.8, bonds: 0.1, commodities: 0.3 }
    },
    3: { // March
      actions: ['Quarter-end volatility prep', 'Triple witching opportunity'],
      avoid: ['Complacency'],
      focus: 'Earnings preparation',
      allocation: { equity: 0.7, bonds: 0.2, commodities: 0.3 }
    },
    4: { // April
      actions: ['Plant agriculture longs', 'Earnings volatility peak'],
      avoid: ['Index strangles'],
      focus: 'Sector rotation',
      allocation: { equity: 0.6, bonds: 0.2, commodities: 0.4 }
    },
    5: { // May
      actions: ['Sell in May defensive', 'Add gold/bond exposure'],
      avoid: ['Aggressive equity'],
      focus: 'Risk reduction',
      allocation: { equity: 0.5, bonds: 0.3, commodities: 0.4 }
    },
    6: { // June
      actions: ['Summer driving season', 'Russell rebalancing'],
      avoid: ['Low liquidity trades'],
      focus: 'Energy plays',
      allocation: { equity: 0.5, bonds: 0.3, commodities: 0.4 }
    },
    7: { // July
      actions: ['Reduce all positions', 'Preserve capital'],
      avoid: ['New initiatives'],
      focus: 'Lowest volume month',
      allocation: { equity: 0.3, bonds: 0.4, commodities: 0.2 }
    },
    8: { // August
      actions: ['Volatility returns', 'Jackson Hole prep'],
      avoid: ['Complacency'],
      focus: 'Increase strangles',
      allocation: { equity: 0.5, bonds: 0.3, commodities: 0.3 }
    },
    9: { // September
      actions: ['Maximum put selling', '0DTE opportunities'],
      avoid: ['Long equity bias'],
      focus: 'Historically worst month',
      allocation: { equity: 0.4, bonds: 0.4, commodities: 0.3 }
    },
    10: { // October
      actions: ['Buy the dip month', 'Add LEAP positions'],
      avoid: ['Panic selling'],
      focus: 'Q4 rally prep',
      allocation: { equity: 0.7, bonds: 0.2, commodities: 0.3 }
    },
    11: { // November
      actions: ['Thanksgiving rally', 'Maximum equity exposure'],
      avoid: ['Premature hedging'],
      focus: 'Year-end rally',
      allocation: { equity: 0.8, bonds: 0.1, commodities: 0.2 }
    },
    12: { // December
      actions: ['Tax loss harvesting', 'Santa rally participation'],
      avoid: ['Pin risk for butterflies'],
      focus: 'Year-end positioning',
      allocation: { equity: 0.7, bonds: 0.2, commodities: 0.2 }
    }
  };
  
  const seasonal = seasonalMatrix[currentMonth];
  if (!seasonal) return null;
  
  // Calculate position adjustments based on seasonal bias
  const adjustments = [];
  
  // Check current allocation vs seasonal targets
  const currentAllocation = calculateCurrentAllocation(positions);
  
  Object.entries(seasonal.allocation).forEach(([asset, target]) => {
    const current = currentAllocation[asset] || 0;
    const diff = target - current;
    
    if (Math.abs(diff) > 0.1) { // 10% threshold
      adjustments.push({
        asset,
        current: `${(current * 100).toFixed(0)}%`,
        target: `${(target * 100).toFixed(0)}%`,
        action: diff > 0 ? 'INCREASE' : 'DECREASE',
        amount: `${Math.abs(diff * 100).toFixed(0)}%`
      });
    }
  });
  
  return {
    month: currentMonth,
    monthName: new Date(2024, currentMonth - 1).toLocaleString('default', { month: 'long' }),
    ...seasonal,
    adjustments,
    pdfReference: 'Pages 34-35 - Seasonal Overlay Calendar'
  };
}

// --------------------------------------------
// ADVANCED 0DTE VARIATIONS (PDF Pages 4-5)
// --------------------------------------------
function calculate0DTEVariations(esPrice, movement, atr, vixLevel) {
  const variations = {
    standard: null,
    brokenWing: null,
    batman: null,
    pdfReference: 'Pages 4-5 - Weekly Iron Condor Variations'
  };
  
  // Standard Iron Condor (PDF Page 4)
  if (Math.abs(movement) <= 0.5) {
    variations.standard = {
      type: 'STANDARD IRON CONDOR',
      callShort: Math.round((esPrice + atr * 0.5) / 5) * 5,
      callLong: Math.round((esPrice + atr * 0.5 + 30) / 5) * 5,
      putShort: Math.round((esPrice - atr * 0.5) / 5) * 5,
      putLong: Math.round((esPrice - atr * 0.5 - 30) / 5) * 5,
      creditTarget: '£400-500',
      when: 'Market flat (±0.5%)'
    };
  }
  
  // Broken Wing Iron Condor - Tom's Preference (PDF Page 4)
  if (Math.abs(movement) <= 0.5) {
    const testedSide = movement > 0 ? 'put' : 'call';
    variations.brokenWing = {
      type: 'BROKEN WING IRON CONDOR',
      preference: "Tom's Preference",
      structure: {},
      creditTarget: '£400-500',
      benefit: 'Reduces risk on trending days'
    };
    
    if (testedSide === 'put') {
      // Bullish bias - wider put wing
      variations.brokenWing.structure = {
        callShort: Math.round((esPrice + atr * 0.5) / 5) * 5,
        callLong: variations.brokenWing.structure.callShort + 30,
        putShort: Math.round((esPrice - atr * 0.5) / 5) * 5,
        putLong: variations.brokenWing.structure.putShort - 50 // WIDER
      };
      variations.brokenWing.bias = 'Bullish - extra put protection';
    } else {
      // Bearish bias - wider call wing
      variations.brokenWing.structure = {
        callShort: Math.round((esPrice + atr * 0.5) / 5) * 5,
        callLong: variations.brokenWing.structure.callShort + 50, // WIDER
        putShort: Math.round((esPrice - atr * 0.5) / 5) * 5,
        putLong: variations.brokenWing.structure.putShort - 30
      };
      variations.brokenWing.bias = 'Bearish - extra call protection';
    }
  }
  
  // Batman Spread - Advanced (PDF Pages 4-5)
  if (vixLevel < 12) {
    variations.batman = {
      type: 'BATMAN SPREAD',
      warning: 'Only for experienced traders',
      requirement: 'VIX <12',
      currentVIX: vixLevel,
      structure: {
        sell: [
          { type: 'ATM Straddle', strike: Math.round(esPrice / 5) * 5, quantity: 2 }
        ],
        buy: [
          { type: 'OTM Put', strike: Math.round((esPrice - 50) / 5) * 5, quantity: 1 },
          { type: 'OTM Call', strike: Math.round((esPrice + 50) / 5) * 5, quantity: 1 }
        ]
      },
      visual: 'Risk graph looks like Batman symbol',
      risk: 'Complex management required'
    };
  } else {
    variations.batman = {
      available: false,
      reason: `VIX at ${vixLevel} - needs <12 for Batman`,
      alternative: 'Use standard or broken wing IC'
    };
  }
  
  return variations;
}

// --------------------------------------------
// ENHANCED STRANGLE POSITIONS (PDF Page 33)
// --------------------------------------------
function calculateEnhancedStrangles(ticker, standardStrangle, phase) {
  if (phase < 2) {
    return {
      available: false,
      reason: 'Enhanced strangles require Phase 2+',
      pdfReference: 'Page 33 - Enhanced Positions'
    };
  }
  
  const enhanced = {
    standard: standardStrangle,
    ratioVersion: null,
    pdfReference: 'Page 33 - Strangle Enhancements'
  };
  
  // PDF Page 33: Add ratio element
  if (standardStrangle && standardStrangle.putStrike && standardStrangle.callStrike) {
    enhanced.ratioVersion = {
      type: 'STRANGLE WITH PUT RATIO',
      structure: 'Standard strangle (1×1) + Put ratio (1×2)',
      puts: {
        long: { strike: standardStrangle.putStrike - 10, quantity: 1 },
        short: { strike: standardStrangle.putStrike, quantity: 2 }
      },
      calls: {
        short: { strike: standardStrangle.callStrike, quantity: 1 }
      },
      benefits: [
        'Reduces BP by 30%',
        'Similar profit potential',
        'Better capital efficiency'
      ],
      management: 'Close at 50% or defend at delta 25',
      bpReduction: '30% less than standard strangle'
    };
  }
  
  return enhanced;
}

// --------------------------------------------
// HELPER FUNCTIONS FOR STRATEGY IMPLEMENTATIONS
// --------------------------------------------

function calculateCurrentAllocation(positions) {
  // Helper for seasonal overlay
  const allocation = { equity: 0, bonds: 0, commodities: 0 };
  let totalBP = 0;
  
  positions.forEach(p => {
    const bp = p.bpUsed || 3;
    totalBP += bp;
    
    // Categorize by asset class
    if (['ES', 'MES', 'NQ', 'SPY', 'QQQ', 'IWM'].includes(p.ticker)) {
      allocation.equity += bp;
    } else if (['ZB', 'ZN', 'TLT', 'GLD'].includes(p.ticker)) {
      allocation.bonds += bp;
    } else {
      allocation.commodities += bp;
    }
  });
  
  // Convert to percentages
  if (totalBP > 0) {
    Object.keys(allocation).forEach(key => {
      allocation[key] = allocation[key] / totalBP;
    });
  }
  
  return allocation;
}

function calculateLEAPStrike(underlying, targetDelta, dte) {
  // Helper for LEAP ladder system
  // This would use actual option chain data in production
  // Placeholder formula: Strike = Current × (1 - delta/100)
  return {
    calculation: `${underlying} price × (1 - ${targetDelta}/100)`,
    note: 'Requires actual option chain for precise strike'
  };
}

// --------------------------------------------
// INTEGRATION FUNCTION FOR ALL STRATEGIES
// --------------------------------------------
function executeAdvancedStrategies(userData, searchedData, phase) {
  const results = {
    boxSpread: null,
    butterfly: null,
    leapLadder: null,
    seasonal: null,
    odteVariations: null,
    enhancedStrangles: null
  };
  
  // Box Spread Opportunity (Phase 3+)
  if (phase >= 3) {
    results.boxSpread = calculateBoxSpreadOpportunity(
      userData.accountValue,
      searchedData.interestRates,
      searchedData
    );
  }
  
  // Butterfly Matrix (Phase 3+, Fridays)
  if (phase >= 3 && userData.dayOfWeek === 'Friday' && searchedData.ES) {
    const percentMove = ((searchedData.ES.currentPrice - searchedData.ES.openPrice) / 
                        searchedData.ES.openPrice) * 100;
    results.butterfly = calculateButterflyMatrix(
      searchedData.ES.currentPrice,
      percentMove,
      userData.accountValue,
      phase
    );
  }
  
  // LEAP Ladder System (Phase 2+, Mondays)
  if (phase >= 2 && userData.dayOfWeek === 'Monday') {
    const existingLEAPs = userData.positions.filter(p => p.strategy === 'LEAP');
    results.leapLadder = executeLEAPLadderSystem(
      existingLEAPs,
      userData.accountValue,
      phase,
      userData.dayOfWeek,
      userData.vixLevel
    );
  }
  
  // Seasonal Overlay (All phases)
  const currentMonth = new Date().getMonth() + 1;
  results.seasonal = applySeasonalOverlay(currentMonth, userData.positions, phase);
  
  // 0DTE Variations (Fridays)
  if (userData.dayOfWeek === 'Friday' && searchedData.ES) {
    const movement = ((searchedData.ES.currentPrice - searchedData.ES.openPrice) / 
                     searchedData.ES.openPrice) * 100;
    results.odteVariations = calculate0DTEVariations(
      searchedData.ES.currentPrice,
      movement,
      searchedData.ES.atr || 45,
      userData.vixLevel
    );
  }
  
  // Enhanced Strangles (Phase 2+)
  if (phase >= 2) {
    // This would be called for each strangle opportunity
    results.enhancedStrangles = {
      available: true,
      note: 'Calculate for each strangle opportunity',
      pdfReference: 'Page 33 - Enhanced Positions'
    };
  }
  
  return results;
}

// ============================================
// EXPORT FOR FRAMEWORK INTEGRATION
// ============================================
// Add to window object for framework access
if (typeof window !== 'undefined') {
  window.advancedStrategies = {
    calculateBoxSpreadOpportunity,
    calculateButterflyMatrix,
    executeLEAPLadderSystem,
    applySeasonalOverlay,
    calculate0DTEVariations,
    calculateEnhancedStrangles,
    executeAdvancedStrategies
  };
}

console.log('? Advanced Strategy Implementations Loaded');
console.log('  - Box Spread Calculator (PDF Page 31)');
console.log('  - Butterfly Strike Matrix (PDF Pages 31-32)');
console.log('  - LEAP Ladder System (PDF Page 28)');
console.log('  - Seasonal Overlay Calendar (PDF Pages 34-35)');
console.log('  - 0DTE Variations: Broken Wing & Batman (PDF Pages 4-5)');
console.log('  - Enhanced Strangle Positions (PDF Page 33)');
console.log('');
console.log('Integration: Call executeAdvancedStrategies() in main framework');

// ============================================
// SECTION 10: SUSTAINABILITY CHECKS
// ============================================

function checkSustainability(monthPL, accountValue) {
  // PDF Pages 39-40 - P&L Expectations
  const currentDay = new Date().getDate();
  const monthlyPercent = (monthPL / accountValue) * 100;
  const projected = (monthPL / currentDay) * 30;
  const projectedPercent = (projected / accountValue) * 100;
  
  let status = 'SUSTAINABLE';
  let warning = null;
  let action = 'CONTINUE';
  
  // Tom's sustainability thresholds
  if (projectedPercent > 15) {
    status = 'DANGEROUS';
    warning = '? ERROR: >15% monthly unsustainable (PDF Page 40)';
    action = 'REDUCE ALL POSITIONS IMMEDIATELY';
  } else if (projectedPercent > 12) {
    status = 'WARNING';
    warning = '?? WARNING: Above 12% sustainability threshold';
    action = 'REDUCE POSITION SIZES';
  } else if (projectedPercent < 6) {
    status = 'UNDERPERFORMING';
    warning = '?? INFO: Below target pace';
    action = 'REVIEW EXECUTION';
  }
  
  return {
    current: monthlyPercent.toFixed(1),
    projected: projectedPercent.toFixed(1),
    target: 8,
    status,
    warning,
    action
  };
}

// ============================================
// SECTION 11: MAIN EXECUTION FRAMEWORK
// ============================================

function executeFramework(userInput, searchedData) {
  console.log('+---------------------------------------------------------------+');
  console.log('¦      TOM KING FRAMEWORK v16.0 - COMPLETE INTEGRATION          ¦');
  console.log('+---------------------------------------------------------------+');
  
  try {
    // Step 1: Parse and validate
    const parseResult = parseAndValidateInput(userInput);
    if (!parseResult.success) {
      throw new Error(parseResult.error);
    }
    
    const userData = parseResult.data;
    console.log('? Input validated - Phase ' + userData.phase);
    
    if (userData.apiMode) {
      console.log('?? API MODE ACTIVE');
    } else if (userData.testingMode) {
      console.log('?? TEST MODE ACTIVE - Override time: ' + userData.timeStr);
    } else {
      console.log('?? MANUAL MODE ACTIVE');
    }
    
    if (userData.isWeekend) {
      console.log('?? WARNING: Market closed - Weekend');
    }
    
    // Step 2: Check if data was searched
    if (searchedData == null || Object.keys(searchedData).length === 0) {
      console.log('?? BLOCKED: No market data provided');
      console.log('');
      
      if (userData.apiMode) {
        console.log('API MODE: Data should have been automatically collected');
        console.log('Check API connection and try again');
      } else {
        console.log('MANDATORY SEARCHES - NO EXCEPTIONS:');
        console.log('1. "current time EST and UK time"');
        console.log('2. "ES futures current price opening price 5-day high low 20-day range ATR"');
        console.log('3. "SPY current price support resistance RSI 8 EMA 21 EMA"');
        console.log('4. "VIX current level 20-day average regime"');
        console.log('5. "DXY dollar index level trend"');
        console.log('');
        
        const phaseTickers = getQualifiedTickersByPhase(userData.phase, userData.accountValue);
        console.log('Phase ' + userData.phase + ' qualified tickers:');
        phaseTickers.tradeable.forEach(ticker => {
          console.log('- ' + ticker + ': price, range, IV, option chain');
        });
      }
      
      throw new Error('Cannot proceed without market data');
    }
    
    // Validate data structure matches requirements
    const dataValidation = validateSearchedData(searchedData);
    if (!dataValidation.valid) {
      console.log('?? WARNING: Incomplete market data');
      console.log(`Missing fields: ${dataValidation.missingFields.join(', ')}`);
      console.log('Proceeding with available data...');
    } else {
      console.log('? Market data complete');
    }
    
    // Get current time for various calculations
    const currentTime = extractCurrentTime(userData, searchedData);
    
    // Step 3: Analyze existing positions
    console.log('');
    console.log('ANALYZING EXISTING POSITIONS...');
    const positionHealth = userData.positions.map(p => ({
      ...p,
      ...analyzePositionHealth(p)
    }));
    
    // Check August 2024 rules
    const august2024Warnings = checkAugust2024Rules(userData.positions, null);
    if (august2024Warnings.length > 0) {
      console.log('');
      console.log('+---------------------------------------------------------------+');
      console.log('¦         AUGUST 2024 CORRELATION WARNING                       ¦');
      console.log('+---------------------------------------------------------------+');
      august2024Warnings.forEach(warning => console.log(warning));
    }
    
    // Step 4: Get phase-qualified tickers
    const tickers = getQualifiedTickersByPhase(userData.phase, userData.accountValue);
    console.log(`Phase ${userData.phase}: Qualified for ${tickers.tradeable.length} tickers`);
    
    // Step 5: Check concentration limits
    const concentrationStatus = checkDetailedConcentration(userData.positions);
    
    // Step 6: Get tickers to search based on phase
    const tickersToSearch = getPhaseTickersToSearch(userData.phase, userData.accountValue, concentrationStatus);
    
    if (tickersToSearch.length > 0 && !userData.apiMode) {
      console.log('');
      console.log('+---------------------------------------------------------------+');
      console.log('¦      PHASE ' + userData.phase + ' AUTOMATED TICKER SEARCHES                    ¦');
      console.log('+---------------------------------------------------------------+');
      console.log('');
      console.log('FOR EACH QUALIFIED TICKER (based on phase):');
      console.log('IF ticker not at concentration limit:');
      tickersToSearch.forEach(ticker => {
        console.log(`? ${ticker}: Searching pattern data...`);
        console.log(`  Search: "${ticker} current price 20-day high low"`);
        console.log(`  Search: "${ticker} IV rank IV percentile ATR"`);
        console.log(`  IF NO RESULTS: ? CANNOT PROCEED`);
      });
    }
    
    // Step 7: Generate phase-based allocation table
    const allocationTable = generatePhaseAllocationTable(userData, searchedData, concentrationStatus);
    
    // Step 8: Analyze patterns with phase awareness
    console.log('');
    console.log('PHASE ' + userData.phase + ' PATTERN ANALYSIS...');
    const patterns = {
      excellent: [],
      good: [],
      fair: [],
      poor: [],
      noData: []
    };
    
    tickers.tradeable.forEach(ticker => {
      const analysis = analyzePatternWithStrikes(ticker, searchedData, userData.phase);
      
      if (analysis.visual === '??') {
        patterns.excellent.push(analysis);
      } else if (analysis.visual === '??' && analysis.score >= 70) {
        patterns.good.push(analysis);
      } else if (analysis.visual === '??') {
        patterns.fair.push(analysis);
      } else if (analysis.visual === '??') {
        patterns.poor.push(analysis);
      } else if (analysis.visual === '?') {
        patterns.noData.push(ticker);
        if (DEBUG && analysis.error) {
          console.log(`  ? ${ticker}: ${analysis.error}`);
        }
      }
    });
    
    // Step 9: Calculate phase-optimized BP plan
    const vixRegime = getVIXRegimeLimits(userData.vixLevel);
    const availableSlots = {};
    allocationTable.table.forEach(row => {
      availableSlots[row.strategy] = row.availablePos;
    });
    const bpOptimization = calculatePhaseBPOptimization(
      userData.bpUsed,
      userData.phase,
      vixRegime,
      availableSlots,
      userData.dayOfWeek
    );
    
    // Step 10: Capital recycling analysis
    const recycling = identifyCapitalRecycling(userData.positions, currentTime);
    
    // Step 11: SPAN margin credits (Phase 4 PM only)
    const spanCredits = calculateSPANCredits(
      userData.positions,
      userData.portfolioMargin,
      userData.accountValue
    );
    
    // Step 12: Weekly staggering analysis (Phase 2+)
    const staggering = analyzeWeeklyStaggering(
      userData.positions,
      userData.accountValue,
      currentTime.date,
      userData.phase
    );
    
    // Step 13: Friday 0DTE countdown
    const countdown = calculate0DTECountdown(currentTime);
    
    // Step 14: Check for VIX spike opportunity
    const vixOpportunity = checkVIXSpikeOpportunity(userData.vixLevel, userData.accountValue);
    
    // Step 15: 0DTE strike calculations if Friday
    let strikeRecommendation = null;
    if (userData.dayOfWeek === 'Friday' && searchedData.ES) {
      const percentMove = searchedData.ES.currentPrice && searchedData.ES.openPrice ?
        ((searchedData.ES.currentPrice - searchedData.ES.openPrice) / searchedData.ES.openPrice) * 100 : 0;
      
      strikeRecommendation = calculate0DTEStrikes(
        searchedData.ES.currentPrice, 
        percentMove,
        searchedData.ES.optionChain
      );
    }
    
    // Step 16: Check sustainability
    const sustainability = checkSustainability(userData.monthPL, userData.accountValue);
    
    // Step 17: Generate comprehensive results
    const results = {
      success: true,
      userData,
      phase: userData.phase,
      positionHealth,
      exitTriggers: positionHealth.filter(p => p.exitTrigger),
      patterns,
      concentrationStatus,
      allocationTable,
      bpOptimization,
      vixRegime,
      vixOpportunity,
      sustainability,
      recycling,
      spanCredits,
      staggering,
      countdown,
      strikeRecommendation,
      tickersToSearch,
      currentTime,
      esPrice: searchedData.ES ? searchedData.ES.currentPrice : null,
      dataCompleteness: dataValidation,
      august2024Warnings,
      apiMode: userData.apiMode,
      timestamp: new Date().toISOString()
    };
    
    // Output comprehensive analysis
    displayCompleteResults(results);
    
    // Bridge to HTML dashboard
    if (typeof window !== 'undefined') {
      window.frameworkResults = results;
      console.log('');
      console.log('+---------------------------------------------------------------+');
      console.log('¦  ? Results available at window.frameworkResults              ¦');
      console.log('¦  ?? Ready for HTML dashboard visualization                    ¦');
      console.log('¦  ?? Phase ' + userData.phase + ' execution complete                          ¦');
      if (userData.apiMode) {
        console.log('¦  ?? API Mode: Orders ready for submission                     ¦');
      }
      console.log('+---------------------------------------------------------------+');
    }
    
    return results;
    
  } catch (error) {
    console.error('');
    console.error('+---------------------------------------------------------------+');
    console.error('¦  ? FRAMEWORK ERROR                                           ¦');
    console.error('+---------------------------------------------------------------+');
    console.error('Error:', error.message);
    console.error('');
    console.error('TROUBLESHOOTING:');
    if (userData && userData.apiMode) {
      console.error('1. Check API credentials are correct');
      console.error('2. Verify network connection');
      console.error('3. Try manual mode as fallback');
    } else {
      console.error('1. Ensure all phase-specific searches have been executed');
      console.error('2. Verify input format matches specification');
      console.error('3. Check that searchedData structure is complete');
    }
    console.error('4. Review PDF reference guide for phase rules');
    return { success: false, error: error.message, data: null };
  }
}

// Additional helper functions...

function checkDetailedConcentration(positions) {
  const groups = getAllCorrelationGroups();
  const status = {};
  
  Object.entries(groups).forEach(([groupId, groupData]) => {
    const positionsInGroup = positions.filter(p => 
      groupData.tickers.includes(p.ticker)
    );
    
    status[groupId] = {
      name: groupData.name,
      current: positionsInGroup.length,
      limit: groupData.limit,
      available: groupData.limit - positionsInGroup.length,
      positions: positionsInGroup.map(p => `${p.ticker} ${p.strategy}`),
      correlation: groupData.correlation,
      status: positionsInGroup.length >= groupData.limit ? '?? FULL' : '? OPEN'
    };
  });
  
  return status;
}

function getPhaseTickersToSearch(phase, accountValue, concentrationStatus) {
  const qualified = getQualifiedTickersByPhase(phase, accountValue);
  const toSearch = [];
  
  qualified.tradeable.forEach(ticker => {
    // Find which group this ticker belongs to
    const groups = getAllCorrelationGroups();
    for (const [groupId, data] of Object.entries(groups)) {
      if (data.tickers.includes(ticker)) {
        // Check if group has available slots
        if (concentrationStatus[groupId]?.available > 0) {
          toSearch.push(ticker);
        }
        break;
      }
    }
  });
  
  return toSearch;
}

function validateSearchedData(searchedData) {
  const validation = {
    valid: true,
    missingTickers: [],
    missingFields: [],
    warnings: []
  };
  
  // Check core required tickers
  const requiredTickers = ['ES', 'SPY', 'VIX', 'DXY'];
  requiredTickers.forEach(ticker => {
    if (searchedData[ticker] == null) {
      validation.missingTickers.push(ticker);
      validation.valid = false;
    }
  });
  
  // Validate ES fields (most critical)
  if (searchedData.ES) {
    const requiredESFields = ['currentPrice', 'openPrice', 'high20d', 'low20d'];
    const optionalESFields = ['ivRank', 'atr', 'rsi', 'ema8', 'ema21'];
    
    requiredESFields.forEach(field => {
      if (searchedData.ES[field] == null) {
        validation.missingFields.push(`ES.${field}`);
        validation.valid = false;
      }
    });
    
    optionalESFields.forEach(field => {
      if (searchedData.ES[field] == null) {
        validation.warnings.push(`ES.${field} missing - some analysis limited`);
      }
    });
  }
  
  // Validate VIX (critical for regime)
  if (searchedData.VIX) {
    if (searchedData.VIX.currentLevel == null && searchedData.VIX.current == null) {
      validation.missingFields.push('VIX.currentLevel');
      validation.valid = false;
    }
  }
  
  return validation;
}

function extractCurrentTime(userData, searchedData) {
  const currentTime = {
    dayOfWeek: userData.testingMode ? userData.dayOfWeek : userData.dayOfWeek,
    hour: 10,
    minute: 0,
    date: new Date(),
    isWeekend: userData.isWeekend || false,
    isTradingHours: false,
    marketStatus: 'UNKNOWN'
  };
  
  // Use time from searchedData if available
  if (searchedData.TIME && searchedData.TIME.currentEST) {
    const timeMatch = searchedData.TIME.currentEST.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
    if (timeMatch) {
      let hour = parseInt(timeMatch[1]);
      const minute = parseInt(timeMatch[2]);
      const period = timeMatch[3]?.toUpperCase();
      
      if (period === 'PM' && hour !== 12) hour += 12;
      if (period === 'AM' && hour === 12) hour = 0;
      
      currentTime.hour = hour;
      currentTime.minute = minute;
    }
  } else if (userData.testingMode && userData.timeStr) {
    // Use override time if in test mode
    const timeMatch = userData.timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
    if (timeMatch) {
      let hour = parseInt(timeMatch[1]);
      const minute = parseInt(timeMatch[2]);
      const period = timeMatch[3]?.toUpperCase();
      
      if (period === 'PM' && hour !== 12) hour += 12;
      if (period === 'AM' && hour === 12) hour = 0;
      
      currentTime.hour = hour;
      currentTime.minute = minute;
    }
  }
  
  // Determine market status
  if (!currentTime.isWeekend) {
    if (currentTime.hour >= 9 && currentTime.hour < 16) {
      currentTime.isTradingHours = true;
      currentTime.marketStatus = 'OPEN';
    } else if (currentTime.hour >= 4 && currentTime.hour < 9) {
      currentTime.marketStatus = 'PRE-MARKET';
    } else if (currentTime.hour >= 16 && currentTime.hour < 20) {
      currentTime.marketStatus = 'AFTER-HOURS';
    } else {
      currentTime.marketStatus = 'CLOSED';
    }
  } else {
    currentTime.marketStatus = 'CLOSED - WEEKEND';
  }
  
  return currentTime;
}

// ============================================
// SECTION 12: RESULTS DISPLAY (COMPLETE)
// ============================================

function displayCompleteResults(results) {
  const { patterns, recycling, spanCredits, staggering, countdown, vixOpportunity, strikeRecommendation, allocationTable, bpOptimization, phase, apiMode } = results;
  
  // Phase announcement
  console.log('');
  console.log('+---------------------------------------------------------------+');
  console.log('¦          PHASE ' + phase + ' ANALYSIS COMPLETE                          ¦');
  console.log('¦     Account: £' + results.userData.accountValue.toLocaleString().padEnd(10) + '                                    ¦');
  if (apiMode) {
    console.log('¦     Mode: API (Real-time data)                                ¦');
  }
  console.log('+---------------------------------------------------------------+');
  
  // VIX Spike Opportunity Alert (highest priority)
  if (vixOpportunity && vixOpportunity.triggered) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦   ?????? VIX SPIKE OPPORTUNITY PROTOCOL ACTIVATED ??????     ¦');
    console.log('+---------------------------------------------------------------+');
    console.log(`VIX at ${results.userData.vixLevel} - GENERATIONAL OPPORTUNITY`);
    console.log(vixOpportunity.warning);
    vixOpportunity.actions.forEach(action => console.log(`  • ${action}`));
    console.log(`Deploy: £${vixOpportunity.deployment.toLocaleString()}`);
    console.log(`Expected: ${vixOpportunity.expectedReturn}`);
  }
  
  // August 2024 Warnings
  if (results.august2024Warnings && results.august2024Warnings.length > 0) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦      ??  AUGUST 2024 CORRELATION WARNINGS                     ¦');
    console.log('+---------------------------------------------------------------+');
    results.august2024Warnings.forEach(warning => console.log(warning));
  }
  
  // Position Allocation Table (Phase-specific)
  if (allocationTable) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦   PHASE ' + phase + ' POSITION ALLOCATION & BP OPTIMIZATION            ¦');
    console.log('+---------------------------------------------------------------+');
    console.log('');
    console.log('Strategy    | Max Pos | Current | Avail | BP/Pos | BP Used | Can Add | Priority');
    console.log('------------|---------|---------|-------|--------|---------|---------|----------');
    
    allocationTable.table.forEach(row => {
      const line = `${row.strategy.padEnd(11)} | ${String(row.maxPos).padEnd(7)} | ${String(row.currentPos).padEnd(7)} | ${String(row.availablePos).padEnd(5)} | ${(row.bpPerPos + '%').padEnd(6)} | ${(row.currentBP + '%').padEnd(7)} | ${(row.canAddBP + '%').padEnd(7)} | ${row.priority}`;
      console.log(line);
    });
    
    console.log('------------|---------|---------|-------|--------|---------|---------|----------');
    const totalBP = allocationTable.table.reduce((sum, row) => sum + row.currentBP, 0);
    const totalAvail = allocationTable.table.reduce((sum, row) => sum + row.canAddBP, 0);
    console.log(`TOTAL       | -       | -       | -     | -      | ${(totalBP + '%').padEnd(7)} | ${(totalAvail + '%').padEnd(7)} | -`);
    console.log('');
    
    // Phase-specific BP targets
    const phaseTargets = {
      1: '40-50%',
      2: '55-65%',
      3: '60-75%',
      4: results.vixRegime.min + '-' + results.vixRegime.max + '%'
    };
    
    console.log(`Phase ${phase} BP Target: ${phaseTargets[phase]}`);
    console.log(`Current: ${results.userData.bpUsed}% | Available: ${100 - results.userData.bpUsed}%`);
  }
  
  // BP Optimization Plan
  if (bpOptimization && bpOptimization.needed && bpOptimization.plan.length > 0) {
    console.log('');
    console.log('PHASE ' + phase + ' OPTIMIZATION PLAN TO REACH ' + bpOptimization.targetMin + '% BP:');
    bpOptimization.plan.forEach((item, index) => {
      console.log(`${index + 1}. Add ${item.positions} ${item.strategy} position${item.positions > 1 ? 's' : ''} (+${item.bpAdded}%) ${item.when}`);
    });
    console.log(`Final BP after additions: ${bpOptimization.projectedBP}% ?`);
  }
  
  // Friday pre-market section
  if (countdown && countdown.timeRemaining != null) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦        ?? 0DTE PRE-MARKET ANALYSIS (PDF Page 25)              ¦');
    console.log('+---------------------------------------------------------------+');
    if (countdown.timeRemaining > 0) {
      console.log(`Phase: ${countdown.phase} ${countdown.status || ''}`);
      console.log(`? ${countdown.message}`);
      console.log(`Market Time: ${countdown.currentMarketTime || 'Unknown'}`);
    } else if (countdown.timeRemaining === 0) {
      console.log(`? ${countdown.message}`);
    } else {
      console.log(`${countdown.status} ${countdown.message}`);
    }
    
    if (strikeRecommendation && strikeRecommendation.strikes) {
      const maxContracts = phase; // Phase 1 = 1 contract, Phase 2 = 2, etc.
      console.log('');
      console.log(`ES at ${strikeRecommendation.currentPrice} (${strikeRecommendation.movement} from open)`);
      console.log(`Triggers: Call >${strikeRecommendation.triggers?.callTrigger} | Put <${strikeRecommendation.triggers?.putTrigger}`);
      console.log(`Recommendation: ${strikeRecommendation.recommendation}`);
      console.log(`Phase ${phase} allows: ${maxContracts} contract${maxContracts > 1 ? 's' : ''}`);
      
      if (strikeRecommendation.strikes.short) {
        console.log(`Strikes: ${strikeRecommendation.strikes.short}/${strikeRecommendation.strikes.long}`);
        if (strikeRecommendation.strikes.credit !== 'SEARCH REQUIRED') {
          console.log(`Credit per contract: £${strikeRecommendation.strikes.credit}`);
          console.log(`Total with ${maxContracts} contracts: £${(strikeRecommendation.strikes.credit * maxContracts).toFixed(2)}`);
        }
      }
      
      if (apiMode && strikeRecommendation.apiReady) {
        console.log('');
        console.log('?? API MODE: Order ready for submission via TastyTrade');
      }
    }
  }
  
  // Exit triggers
  if (results.exitTriggers && results.exitTriggers.length > 0) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦      ?? IMMEDIATE EXITS REQUIRED (PDF Pages 9-10)             ¦');
    console.log('+---------------------------------------------------------------+');
    results.exitTriggers.forEach(p => {
      console.log(`  ${p.ticker} ${p.strategy}: ${p.action}`);
    });
  }
  
  // Capital recycling
  if (recycling && recycling.count > 0) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦           ??  CAPITAL RECYCLING OPPORTUNITIES                 ¦');
    console.log('+---------------------------------------------------------------+');
    recycling.positions.forEach(r => {
      console.log(`  ${r.position}: ${r.reason} - Frees ${r.bpToFree}% BP`);
    });
    console.log(`  TOTAL BP TO FREE: ${recycling.totalBPFreed}%`);
    console.log(`  Redeployment: ${recycling.redeploymentOptions.join(', ')}`);
  }
  
  // Pattern opportunities with phase awareness
  if (patterns) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦     PHASE ' + phase + ' PATTERN ANALYSIS WITH SPECIFIC STRIKES         ¦');
    console.log('+---------------------------------------------------------------+');
    
    if (patterns.excellent && patterns.excellent.length > 0) {
      console.log(`\n?? EXCELLENT SETUPS (${patterns.excellent.length}):`);
      patterns.excellent.forEach(p => {
        const price = p.metrics?.currentPrice || 'NO PRICE';
        const range = p.metrics?.range20d || 'N/A';
        const iv = p.metrics?.ivRank || 'N/A';
        console.log(`  ${p.ticker}: ${price} | Range: ${range}% | IV Rank: ${iv}%`);
        if (p.specificRecommendation) {
          const rec = p.specificRecommendation;
          console.log(`    ? Entry: ${rec.putStrike}P @ £${rec.putBid} / ${rec.callStrike}C @ £${rec.callBid}`);
          console.log(`    ? Total Credit: £${rec.totalCredit} | BP Required: ${rec.bpRequired}%`);
        }
      });
    }
    
    if (patterns.good && patterns.good.length > 0) {
      console.log(`\n?? GOOD SETUPS (${patterns.good.length}):`);
      patterns.good.forEach(p => {
        console.log(`  ${p.ticker}: Score ${p.score} - ${p.recommendation}`);
      });
    }
    
    if (patterns.poor && patterns.poor.length > 0) {
      console.log(`\n?? AVOID (${patterns.poor.length}): ${patterns.poor.map(p => p.ticker).join(', ')}`);
      console.log('  ? See PDF Pages 6-7 for Never Trade List');
    }
    
    if (patterns.noData && patterns.noData.length > 0) {
      console.log(`\n? NO DATA (${patterns.noData.length}): ${patterns.noData.join(', ')}`);
      if (apiMode) {
        console.log('  ? API should have collected this data - check connection');
      } else {
        console.log('  ? Execute phase ' + phase + ' searches for these tickers');
      }
    }
  }
  
  // Concentration groups status (PDF Page 12)
  if (results.concentrationStatus) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦     ?? CONCENTRATION GROUP STATUS (PDF Page 12)               ¦');
    console.log('+---------------------------------------------------------------+');
    
    let hasPositions = false;
    Object.entries(results.concentrationStatus).forEach(([group, status]) => {
      if (status && status.current > 0) {
        hasPositions = true;
        console.log(`  ${group} - ${status.name}: ${status.current}/${status.limit} ${status.status}`);
        if (status.positions && status.positions.length > 0) {
          console.log(`    Positions: ${status.positions.join(', ')}`);
        }
      }
    });
    
    if (!hasPositions) {
      console.log('  No current positions in any correlation group');
    }
    
    // Show available groups for phase
    console.log('');
    console.log('  PHASE ' + phase + ' AVAILABLE SLOTS:');
    Object.entries(results.concentrationStatus).forEach(([group, status]) => {
      if (status && status.available > 0) {
        const groupTickers = getAllCorrelationGroups()[group].tickers;
        const phaseTickers = getQualifiedTickersByPhase(phase, results.userData.accountValue).tradeable;
        const availableInPhase = groupTickers.filter(t => phaseTickers.includes(t));
        
        if (availableInPhase.length > 0) {
          console.log(`    ${group} - ${status.name}: ${status.available} slot${status.available > 1 ? 's' : ''}`);
          console.log(`      Phase ${phase} tickers: ${availableInPhase.join(', ')}`);
        }
      }
    });
  }
  
  // SPAN credits for PM accounts (Phase 4)
  if (spanCredits && spanCredits.totalSaved > 0 && phase === 4) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦        ?? SPAN MARGIN CREDITS (Portfolio Margin)              ¦');
    console.log('+---------------------------------------------------------------+');
    spanCredits.credits.forEach(c => {
      console.log(`  ${c.tickers}: ${c.reduction} reduction = £${c.bpFreed} freed`);
    });
    console.log(`  TOTAL BP FREED: £${spanCredits.totalSaved}`);
  }
  
  // Weekly staggering (Phase 2+ only)
  if (staggering && results.userData.dayOfWeek === 'Wednesday' && phase >= 2) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦       ?? LT112 WEEKLY STAGGERING (PDF Page 26)                ¦');
    console.log('+---------------------------------------------------------------+');
    console.log(`  Week ${staggering.currentWeek}: ${staggering.sizing}`);
    console.log(`  Product: ${staggering.product}`);
    console.log(`  Recommendation: ${staggering.recommendation}`);
    
    if (staggering.weeksOpen && staggering.weeksOpen.length > 0) {
      console.log(`  Open Weeks: ${staggering.weeksOpen.join(', ')}`);
    }
  }
  
  // Position sizing recommendations
  if (results.sizing && results.sizing.length > 0) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦      ?? PHASE ' + phase + ' POSITION SIZING OPTIMIZATION               ¦');
    console.log('+---------------------------------------------------------------+');
    if (results.vixRegime) {
      console.log(`  ${results.vixRegime.message}`);
    }
    console.log(`  Current BP: ${results.userData.bpUsed}%`);
    console.log(`  Available: ${100 - results.userData.bpUsed}%`);
    console.log('');
    console.log('  PHASE ' + phase + ' RECOMMENDED POSITIONS:');
    results.sizing.forEach(s => {
      console.log(`    • ${s.strategy}: ${s.positions} positions (${s.bpRequired}% BP)`);
    });
    console.log('  (See PDF Pages 13-24 for Phase ' + phase + ' specifications)');
  }
  
  // Sustainability check
  if (results.sustainability) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('¦      ?? MONTHLY SUSTAINABILITY CHECK (PDF Pages 39-40)        ¦');
    console.log('+---------------------------------------------------------------+');
    console.log(`  Current: £${results.userData.monthPL} (${results.sustainability.current}%)`);
    console.log(`  Projected: ${results.sustainability.projected}% monthly`);
    console.log(`  Target: ${results.sustainability.target}% monthly`);
    console.log(`  Status: ${results.sustainability.status}`);
    
    if (results.sustainability.warning) {
      console.log('');
      console.log(`  ${results.sustainability.warning}`);
      console.log(`  Action Required: ${results.sustainability.action}`);
    }
  }
  
  // Data completeness report
  if (results.dataCompleteness) {
    if (!results.dataCompleteness.valid || results.dataCompleteness.warnings?.length > 0) {
      console.log('');
      console.log('+---------------------------------------------------------------+');
      console.log('¦            ??  DATA QUALITY REPORT                            ¦');
      console.log('+---------------------------------------------------------------+');
      
      if (results.dataCompleteness.missingTickers?.length > 0) {
        console.log(`  Missing Tickers: ${results.dataCompleteness.missingTickers.join(', ')}`);
      }
      if (results.dataCompleteness.missingFields?.length > 0) {
        console.log(`  Missing Fields: ${results.dataCompleteness.missingFields.join(', ')}`);
      }
      if (results.dataCompleteness.warnings?.length > 0) {
        console.log('  Warnings:');
        results.dataCompleteness.warnings.forEach(w => {
          console.log(`    • ${w}`);
        });
      }
    }
  }
}

// ============================================
// EXECUTION
// ============================================

console.log('');
console.log('+---------------------------------------------------------------+');
console.log('¦              HOW TO EXECUTE THIS FRAMEWORK                    ¦');
console.log('+---------------------------------------------------------------+');
console.log('');
console.log('THREE EXECUTION MODES AVAILABLE:');
console.log('');
console.log('MODE 1: API (Automated with TastyTrade)');
console.log('  const results = executeFrameworkWithAPI(clientSecret, refreshToken);');
console.log('');
console.log('MODE 2: MANUAL (Web Searches)');
console.log('  const results = executeFramework(userInput, searchedData);');
console.log('');
console.log('MODE 3: TEST (Simulated Data)');
console.log('  const results = executeFrameworkTest();');
console.log('');
console.log('STEP-BY-STEP GUIDE:');
console.log('');
console.log('1. IDENTIFY YOUR PHASE');
console.log('  Phase 1: £30,000-40,000 (Foundation)');
console.log('  Phase 2: £40,000-60,000 (Scaling)');
console.log('  Phase 3: £60,000-75,000 (Optimization)');
console.log('  Phase 4: £75,000+ (Professional)');
console.log('');
console.log('2. CHOOSE EXECUTION MODE');
console.log('  API: Use TastyTrade credentials');
console.log('  Manual: Execute phase-specific searches');
console.log('  Test: Use simulated data');
console.log('');
console.log('3. RUN ANALYSIS');
console.log('  Framework will automatically:');
console.log('  - Analyze positions');
console.log('  - Calculate opportunities');
console.log('  - Generate recommendations');
console.log('  - Prepare orders (API mode)');
console.log('');
console.log('Framework v16.0 loaded - Complete with API integration.');
console.log('ALL v14.0 functionality preserved + TastyTrade API added.');
console.log('');
console.log('+---------------------------------------------------------------+');
console.log('¦   ?? Reference PDF for complete strategy specifications       ¦');
console.log('¦   ?? Execute all phase-specific searches (Manual mode)        ¦');
console.log('¦   ?? Use API credentials for automation (API mode)            ¦');
console.log('¦   ? Use actual market data only - no placeholders            ¦');
console.log('¦   ?? Phase-based progression system active                    ¦');
console.log('+---------------------------------------------------------------+');

// Test mode execution function
function executeFrameworkTest() {
  console.log('+---------------------------------------------------------------+');
  console.log('¦              ?? TEST MODE - SIMULATED DATA                    ¦');
  console.log('+---------------------------------------------------------------+');
  
  const testInput = '£45000 | MES LT112 (85 DTE, 6420, +12%), MCL strangle (55 DTE, 2.80, +48%) | 20% | Pretend it\'s Friday 01/10 9:45 AM EST | VIX 14.8 | No';
  
  const testSearchedData = {
    ES: {
      currentPrice: 6450,
      openPrice: 6440,
      previousClose: 6435,
      high20d: 6520,
      low20d: 6380,
      high5d: 6480,
      low5d: 6420,
      atr: 45,
      rsi: 58,
      ema8: 6445,
      ema21: 6430,
      ivRank: 35,
      ivPercentile: 40,
      optionChain: {
        put5Delta: 6200,
        put5DeltaBid: 2.50,
        call5Delta: 6700,
        call5DeltaBid: 2.75,
        atmStrike: 6450,
        call30Wide: {
          shortStrike: 6470,
          longStrike: 6500,
          credit: 2.25
        },
        put30Wide: {
          shortStrike: 6430,
          longStrike: 6400,
          credit: 2.50
        }
      }
    },
    SPY: {
      currentPrice: 458.50,
      openPrice: 457.25,
      ivRank: 32
    },
    VIX: {
      currentLevel: 14.8,
      avg20d: 15.5
    },
    DXY: {
      currentLevel: 103.5,
      trend: 'UP'
    },
    TIME: {
      currentEST: '9:45 AM',
      currentUK: '2:45 PM',
      marketStatus: 'OPEN'
    },
    MCL: {
      currentPrice: 65.50,
      high20d: 68.00,
      low20d: 63.00,
      ivRank: 52
    }
  };
  
  console.log('Test data loaded:');
  console.log('  Account: £45,000 (Phase 2)');
  console.log('  Positions: 2');
  console.log('  Time: Friday 9:45 AM EST');
  console.log('  VIX: 14.8');
  console.log('');
  
  return executeFramework(testInput, testSearchedData);
}

HTML DASHBOARD TEMPLATE
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tom King Trading Dashboard v16.0 - Complete Integration</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<style>
  body { 
    font-family: 'Segoe UI', Arial, sans-serif; 
    padding: 20px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    margin: 0;
  }
  
  .header { 
    background: white; 
    padding: 25px; 
    border-radius: 12px; 
    margin-bottom: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }
  
  .phase-indicator {
    display: inline-block;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: bold;
    margin-left: 15px;
  }
  
  .api-indicator {
    display: inline-block;
    background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: bold;
    margin-left: 10px;
  }
  
  .metrics { 
    display: flex; 
    gap: 30px; 
    margin-top: 15px;
    flex-wrap: wrap;
  }
  
  .metric { 
    color: #7f8c8d;
    font-size: 14px;
  }
  
  .metric span { 
    font-weight: bold; 
    color: #2c3e50;
    font-size: 18px;
  }
  
  .grid { 
    display: grid; 
    grid-template-columns: 1fr 1fr; 
    gap: 20px; 
    margin-bottom: 20px;
  }
  
  @media (max-width: 768px) {
    .grid { grid-template-columns: 1fr; }
  }
  
  .container { 
    background: white; 
    padding: 20px; 
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    margin-bottom: 20px;
  }
  
  .warning {
    background: #e74c3c;
    color: white;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.8; }
    100% { opacity: 1; }
  }
  
  .premarket-box {
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }
  
  .countdown {
    font-size: 32px;
    font-weight: bold;
    text-align: center;
    background: rgba(255,255,255,0.1);
    padding: 15px;
    border-radius: 8px;
    margin: 15px 0;
  }
  
  .order-ready {
    background: linear-gradient(135deg, #27ae60 0%, #16a085 100%);
    color: white;
    padding: 15px;
    border-radius: 8px;
    margin-top: 15px;
    text-align: center;
    font-weight: bold;
  }
  
  .recycling-box {
    background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }
  
  .august-warning {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }
  
  .pattern-indicator {
    display: inline-block;
    padding: 5px 10px;
    border-radius: 6px;
    margin: 3px;
    font-weight: bold;
  }
  
  .pattern-excellent { background: #27ae60; color: white; }
  .pattern-good { background: #f39c12; color: white; }
  .pattern-poor { background: #e74c3c; color: white; }
  .pattern-nodata { background: #34495e; color: white; }
  
  table { 
    width: 100%; 
    border-collapse: collapse; 
  }
  
  th { 
    padding: 12px 8px; 
    text-align: left; 
    border-bottom: 2px solid #667eea;
    color: #2c3e50;
  }
  
  td { 
    padding: 10px 8px; 
    border-bottom: 1px solid #ecf0f1;
  }
  
  .exit-trigger {
    background: #ffe5e5;
  }
  
  .no-data {
    text-align: center;
    padding: 20px;
    color: #95a5a6;
  }
  
  canvas {
    max-height: 350px;
  }
  
  .error-message {
    background: #ffebee;
    color: #c62828;
    padding: 10px;
    border-radius: 4px;
    margin: 10px 0;
  }
  
  .status-badge {
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
  }
  
  .status-active { background: #4caf50; color: white; }
  .status-warning { background: #ff9800; color: white; }
  .status-closed { background: #f44336; color: white; }
  
  .bp-table table {
    font-size: 14px;
  }
  
  .bp-table th {
    background: #f8f9fa;
  }
  
  .bp-table .total-row {
    font-weight: bold;
    background: #e8f4f8;
  }
  
  .phase-progress {
    background: #ecf0f1;
    border-radius: 10px;
    padding: 3px;
    margin: 15px 0;
  }
  
  .phase-progress-bar {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 8px;
    border-radius: 8px;
    text-align: center;
    font-weight: bold;
    transition: width 0.3s ease;
  }
  
  .greeks-display {
    display: flex;
    justify-content: space-around;
    margin: 15px 0;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 8px;
  }
  
  .greek-item {
    text-align: center;
  }
  
  .greek-label {
    font-size: 12px;
    color: #7f8c8d;
  }
  
  .greek-value {
    font-size: 20px;
    font-weight: bold;
    color: #2c3e50;
  }
</style>
</head>
<body>

<div class="header">
  <h1>?? Tom King Trading Dashboard v16.0
    <span class="phase-indicator" id="phaseIndicator">Loading...</span>
    <span class="api-indicator" id="apiIndicator" style="display:none;">API MODE</span>
  </h1>
  <div class="metrics">
    <div class="metric">Account: <span id="accountValue">Loading...</span></div>
    <div class="metric">BP Used: <span id="bpUsed">-</span></div>
    <div class="metric">Month P&L: <span id="monthPL">-</span></div>
    <div class="metric">VIX: <span id="vixLevel">-</span></div>
    <div class="metric">ES: <span id="esPrice">-</span></div>
    <div class="metric">Time: <span id="currentTime">-</span></div>
    <div class="metric">Status: <span id="marketStatus" class="status-badge">-</span></div>
  </div>
  <div class="phase-progress">
    <div class="phase-progress-bar" id="phaseProgress">Phase Progress</div>
  </div>
</div>

<!-- API Mode Greeks Display -->
<div id="greeksSection" class="container" style="display:none;">
  <h3>?? Real-Time Portfolio Greeks (API Mode)</h3>
  <div class="greeks-display">
    <div class="greek-item">
      <div class="greek-label">Delta</div>
      <div class="greek-value" id="portfolioDelta">-</div>
    </div>
    <div class="greek-item">
      <div class="greek-label">Gamma</div>
      <div class="greek-value" id="portfolioGamma">-</div>
    </div>
    <div class="greek-item">
      <div class="greek-label">Theta</div>
      <div class="greek-value" id="portfolioTheta">-</div>
    </div>
    <div class="greek-item">
      <div class="greek-label">Vega</div>
      <div class="greek-value" id="portfolioVega">-</div>
    </div>
  </div>
</div>

<!-- Weekend/After-Hours Warning -->
<div id="marketClosedWarning" style="display:none;">
  <div class="warning">
    <h3>?? MARKET CLOSED</h3>
    <div id="marketClosedReason"></div>
  </div>
</div>

<!-- August 2024 Correlation Warning -->
<div id="august2024Warning" style="display:none;">
  <div class="august-warning">
    <h3>?? AUGUST 2024 CORRELATION WARNING</h3>
    <p>Tom lost £308,000 with 6 correlated positions. Don't repeat this mistake!</p>
    <div id="august2024Content"></div>
  </div>
</div>

<!-- Friday Pre-Market Section -->
<div id="premarketSection" style="display:none;">
  <div class="premarket-box">
    <h2 style="color:white;">?? 0DTE PRE-MARKET ANALYSIS - Phase <span id="phaseODTE">-</span></h2>
    <div id="premarketPhase"></div>
    <div class="countdown" id="countdown">Loading...</div>
    <div id="triggerLevels" style="margin-top: 15px;">
      <div>?? CALL SPREAD: ES > <span id="callTrigger">-</span></div>
      <div>?? PUT SPREAD: ES < <span id="putTrigger">-</span></div>
      <div>?? IRON CONDOR: Between triggers</div>
    </div>
    <div id="creditInfo" style="margin-top: 10px; font-size: 14px;"></div>
    <div style="margin-top: 10px;">Max Contracts for Phase: <strong id="maxContracts">-</strong></div>
    <div id="orderReady" class="order-ready" style="display:none;">
      ?? ORDER READY FOR SUBMISSION VIA API
    </div>
  </div>
</div>

<!-- VIX Spike Alert -->
<div id="vixSpikeAlert" style="display:none;">
  <div class="warning">
    <h2>?????? VIX SPIKE OPPORTUNITY PROTOCOL ??????</h2>
    <div id="vixSpikeContent"></div>
  </div>
</div>

<!-- Warnings -->
<div id="warnings"></div>

<!-- Capital Recycling -->
<div id="recyclingSection" style="display:none;">
  <div class="recycling-box">
    <h2 style="color:white;">?? CAPITAL RECYCLING OPPORTUNITIES</h2>
    <div id="recyclingContent"></div>
  </div>
</div>

<!-- Position Allocation Table -->
<div class="container bp-table">
  <h3>Phase <span id="phaseAllocation">-</span> Position Allocation & BP Optimization</h3>
  <table id="allocationTable">
    <thead>
      <tr>
        <th>Strategy</th>
        <th>Max Pos</th>
        <th>Current</th>
        <th>Available</th>
        <th>BP/Pos</th>
        <th>BP Used</th>
        <th>Can Add</th>
        <th>Priority</th>
      </tr>
    </thead>
    <tbody id="allocationRows">
      <tr class="no-data">
        <td colspan="8">Loading allocation data...</td>
      </tr>
    </tbody>
  </table>
  <div id="bpOptimizationPlan" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px;"></div>
</div>

<!-- Position Health -->
<div class="container">
  <h3>Position Health & Exit Triggers</h3>
  <table id="positionTable">
    <thead>
      <tr>
        <th>Position</th>
        <th>DTE</th>
        <th>P&L</th>
        <th>Health</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody id="positionRows">
      <tr class="no-data">
        <td colspan="5">Loading positions...</td>
      </tr>
    </tbody>
  </table>
</div>

<!-- Pattern Analysis -->
<div class="container">
  <h3>Phase <span id="phasePatterns">-</span> Pattern Analysis</h3>
  <div id="patternSummary" style="margin-bottom: 15px;">
    <span class="pattern-indicator pattern-excellent">?? EXCELLENT: 0</span>
    <span class="pattern-indicator pattern-good">?? GOOD: 0</span>
    <span class="pattern-indicator pattern-poor">?? AVOID: 0</span>
    <span class="pattern-indicator pattern-nodata">? NO DATA: 0</span>
  </div>
  <div id="patternDetails">Loading patterns...</div>
</div>

<div class="grid">
  <div class="container">
    <canvas id="bpChart"></canvas>
  </div>
  <div class="container">
    <canvas id="concentrationChart"></canvas>
  </div>
</div>

<!-- Phase-Specific Information -->
<div class="container">
  <h3>Phase <span id="phaseInfo">-</span> Information</h3>
  <div id="phaseContent"></div>
</div>

<!-- SPAN Credits (PM Only) -->
<div id="spanSection" class="container" style="display:none;">
  <h3>?? SPAN Margin Credits (Portfolio Margin - Phase 4)</h3>
  <div id="spanContent"></div>
</div>

<!-- Weekly Staggering -->
<div id="staggeringSection" class="container" style="display:none;">
  <h3>?? LT112 Weekly Staggering (Phase 2+)</h3>
  <div id="staggeringContent"></div>
</div>

<!-- Tickers to Search -->
<div id="tickerSearchSection" class="container" style="display:none;">
  <h3>?? Phase <span id="phaseSearch">-</span> Tickers Requiring Search</h3>
  <div id="tickerSearchContent"></div>
</div>

<!-- Data Quality Report -->
<div id="dataQuality" class="container" style="display:none;">
  <h3>?? Data Quality Report</h3>
  <div id="dataQualityContent"></div>
</div>

<script>
// Complete Dashboard JavaScript Implementation with API Support
window.addEventListener('load', function() {
  // Chart instances
  let bpChart = null;
  let concentrationChart = null;
  
  // Auto-refresh every 30 seconds if framework results exist
  setInterval(() => {
    if (window.frameworkResults) {
      updateDashboard(window.frameworkResults);
    }
  }, 30000);
  
  // Real-time Greeks update for API mode
  setInterval(() => {
    if (window.frameworkResults?.greeksMonitor) {
      updateGreeksDisplay();
    }
  }, 5000);
  
  function updateDashboard(results) {
    if (!results || !results.success) {
      document.getElementById('warnings').innerHTML = 
        '<div class="warning">No analysis results available. Execute framework first.</div>';
      return;
    }
    
    // Update phase indicators
    updatePhaseIndicators(results);
    
    // Update header metrics
    updateHeaderMetrics(results);
    
    // Update warnings and alerts
    updateWarningsAndAlerts(results);
    
    // Update position allocation table
    updateAllocationTable(results);
    
    // Update position health table
    updatePositionHealth(results);
    
    // Update pattern analysis
    updatePatternAnalysis(results);
    
    // Update charts
    updateCharts(results);
    
    // Update optional sections
    updateOptionalSections(results);
    
    // Update phase-specific information
    updatePhaseInfo(results);
    
    // API-specific updates
    if (results.apiMode) {
      updateAPIFeatures(results);
    }
  }
  
  function updatePhaseIndicators(results) {
    const phase = results.phase || 1;
    const accountValue = results.userData.accountValue;
    
    // Update all phase indicators
    document.getElementById('phaseIndicator').textContent = `PHASE ${phase}`;
    document.getElementById('phaseAllocation').textContent = phase;
    document.getElementById('phasePatterns').textContent = phase;
    document.getElementById('phaseInfo').textContent = phase;
    document.getElementById('phaseSearch').textContent = phase;
    document.getElementById('phaseODTE').textContent = phase;
    
    // Show API indicator if in API mode
    if (results.apiMode) {
      document.getElementById('apiIndicator').style.display = 'inline-block';
    }
    
    // Update phase progress bar
    const phaseThresholds = [30000, 40000, 60000, 75000];
    const nextThreshold = phaseThresholds[phase] || 150000;
    const prevThreshold = phaseThresholds[phase - 2] || 30000;
    const progress = ((accountValue - prevThreshold) / (nextThreshold - prevThreshold)) * 100;
    
    const progressBar = document.getElementById('phaseProgress');
    progressBar.style.width = `${Math.min(100, Math.max(0, progress))}%`;
    progressBar.textContent = phase < 4 ? 
      `Phase ${phase}: £${(accountValue/1000).toFixed(0)}k / £${(nextThreshold/1000).toFixed(0)}k` :
      `Phase 4: Professional (£${(accountValue/1000).toFixed(0)}k)`;
  }
  function updateAPIFeatures(results) {
    // Show Greeks display if available
    if (results.greeksMonitor) {
      document.getElementById('greeksSection').style.display = 'block';
      updateGreeksDisplay();
    }
    
    // Show order ready indicator for 0DTE
    if (results.strikeRecommendation?.apiReady) {
      document.getElementById('orderReady').style.display = 'block';
    }
  }
  
  function updateGreeksDisplay() {
    if (!window.frameworkResults?.greeksMonitor) return;
    
    const greeks = window.frameworkResults.greeksMonitor.getPortfolioGreeks();
    
    document.getElementById('portfolioDelta').textContent = 
      greeks.totalDelta.toFixed(2);
    document.getElementById('portfolioGamma').textContent = 
      greeks.totalGamma.toFixed(4);
    document.getElementById('portfolioTheta').textContent = 
      `£${greeks.totalTheta.toFixed(0)}`;
    document.getElementById('portfolioVega').textContent = 
      `£${greeks.totalVega.toFixed(0)}`;
  }
  
  function updateHeaderMetrics(results) {
    document.getElementById('accountValue').textContent = 
      '£' + results.userData.accountValue.toLocaleString();
    
    document.getElementById('bpUsed').textContent = 
      results.userData.bpUsed + '%';
    
    document.getElementById('monthPL').textContent = 
      '£' + results.userData.monthPL.toLocaleString();
    
    document.getElementById('vixLevel').textContent = 
      results.userData.vixLevel + ' (' + results.vixRegime.regime + ')';
    
    document.getElementById('esPrice').textContent = 
      results.esPrice ? results.esPrice.toFixed(2) : 'NO DATA';
    
    document.getElementById('currentTime').textContent = 
      results.userData.dayOfWeek + ' ' + results.userData.timeStr;
    
    const statusEl = document.getElementById('marketStatus');
    statusEl.textContent = results.currentTime.marketStatus;
    statusEl.className = 'status-badge ' + 
      (results.currentTime.marketStatus === 'OPEN' ? 'status-active' :
       results.currentTime.marketStatus.includes('CLOSED') ? 'status-closed' : 
       'status-warning');
  }
  
  function updateWarningsAndAlerts(results) {
    let warningsHtml = '';
    
    // Market closed warning
    if (results.userData.isWeekend || results.currentTime.marketStatus.includes('CLOSED')) {
      document.getElementById('marketClosedWarning').style.display = 'block';
      document.getElementById('marketClosedReason').textContent = 
        results.userData.isWeekend ? 'Market closed for weekend.' : 'Market is currently closed.';
    }
    
    // August 2024 correlation warnings
    if (results.august2024Warnings && results.august2024Warnings.length > 0) {
      document.getElementById('august2024Warning').style.display = 'block';
      let warningContent = '<ul>';
      results.august2024Warnings.forEach(warning => {
        warningContent += '<li>' + warning + '</li>';
      });
      warningContent += '</ul>';
      document.getElementById('august2024Content').innerHTML = warningContent;
    }
    
    // VIX spike alert
    if (results.vixOpportunity?.triggered) {
      document.getElementById('vixSpikeAlert').style.display = 'block';
      let vixHtml = '<p>VIX at ' + results.userData.vixLevel + '</p><ul>';
      results.vixOpportunity.actions.forEach(action => {
        vixHtml += '<li>' + action + '</li>';
      });
      vixHtml += '</ul><p><strong>Deploy: £' + results.vixOpportunity.deployment.toLocaleString() + '</strong></p>';
      document.getElementById('vixSpikeContent').innerHTML = vixHtml;
    }
    
    // Exit triggers
    if (results.exitTriggers?.length > 0) {
      warningsHtml += '<div class="warning"><strong>?? EXIT TRIGGERS:</strong><br>';
      results.exitTriggers.forEach(p => {
        warningsHtml += p.ticker + ' ' + p.strategy + ': ' + p.action + '<br>';
      });
      warningsHtml += '</div>';
    }
    
    // Sustainability warning
    if (results.sustainability?.warning) {
      warningsHtml += '<div class="warning">' + results.sustainability.warning + '<br>' +
        'Action: ' + results.sustainability.action + '</div>';
    }
    
    document.getElementById('warnings').innerHTML = warningsHtml;
    
    // Friday pre-market with phase info
    if (results.countdown && results.userData.dayOfWeek === 'Friday') {
      updatePremarketSection(results);
    }
    
    // Capital recycling
    if (results.recycling?.count > 0) {
      updateRecyclingSection(results);
    }
  }
  
  function updatePremarketSection(results) {
    document.getElementById('premarketSection').style.display = 'block';
    
    const phase = results.phase || 1;
    const maxContracts = phase; // Phase 1 = 1 contract, Phase 2 = 2, etc.
    document.getElementById('maxContracts').textContent = maxContracts;
    
    if (results.countdown.phase) {
      document.getElementById('premarketPhase').innerHTML = 
        '<strong>Phase: ' + results.countdown.phase + '</strong> ' + 
        (results.countdown.status || '');
    }
    
    document.getElementById('countdown').textContent = 
      results.countdown.message || 'No countdown data';
    
    if (results.strikeRecommendation?.triggers) {
      document.getElementById('callTrigger').textContent = 
        results.strikeRecommendation.triggers.callTrigger || 'CALCULATE';
      document.getElementById('putTrigger').textContent = 
        results.strikeRecommendation.triggers.putTrigger || 'CALCULATE';
      
      let creditInfo = 'Credit: ' + (results.strikeRecommendation.creditSource || 'SEARCH REQUIRED');
      if (results.strikeRecommendation.strikes.credit && results.strikeRecommendation.strikes.credit !== 'SEARCH REQUIRED') {
        creditInfo += ' | Total with ' + maxContracts + ' contracts: £' + 
          (results.strikeRecommendation.strikes.credit * maxContracts).toFixed(2);
      }
      document.getElementById('creditInfo').textContent = creditInfo;
    }
  }
  
  function updateRecyclingSection(results) {
    document.getElementById('recyclingSection').style.display = 'block';
    let recycleHtml = '<ul>';
    results.recycling.positions.forEach(r => {
      recycleHtml += '<li>' + r.position + ': ' + r.reason + 
        ' (Frees ' + r.bpToFree + '% BP)</li>';
    });
    recycleHtml += '</ul><strong>Total BP to Free: ' + 
      results.recycling.totalBPFreed + '%</strong><br>' +
      'Redeployment: ' + results.recycling.redeploymentOptions.join(', ');
    document.getElementById('recyclingContent').innerHTML = recycleHtml;
  }
  
  function updateAllocationTable(results) {
    if (!results.allocationTable) return;
    
    const tbody = document.getElementById('allocationRows');
    tbody.innerHTML = '';
    
    results.allocationTable.table.forEach(row => {
      const tr = tbody.insertRow();
      tr.innerHTML = 
        '<td><strong>' + row.strategy + '</strong></td>' +
        '<td>' + row.maxPos + '</td>' +
        '<td>' + row.currentPos + '</td>' +
        '<td>' + row.availablePos + '</td>' +
        '<td>' + row.bpPerPos + '%</td>' +
        '<td>' + row.currentBP + '%</td>' +
        '<td>' + row.canAddBP + '%</td>' +
        '<td>' + row.priority + '</td>';
    });
    
    // Add total row
    const totalRow = tbody.insertRow();
    totalRow.className = 'total-row';
    const totalBP = results.allocationTable.table.reduce((sum, row) => sum + row.currentBP, 0);
    const totalAvail = results.allocationTable.table.reduce((sum, row) => sum + row.canAddBP, 0);
    totalRow.innerHTML = 
      '<td><strong>TOTAL</strong></td>' +
      '<td>-</td><td>-</td><td>-</td><td>-</td>' +
      '<td><strong>' + totalBP + '%</strong></td>' +
      '<td><strong>' + totalAvail + '%</strong></td>' +
      '<td>-</td>';
    
    // BP optimization plan with phase awareness
    if (results.bpOptimization?.needed && results.bpOptimization.plan.length > 0) {
      let planHtml = '<strong>Phase ' + results.phase + ' Optimization Plan to ' + 
        results.bpOptimization.targetMin + '% BP:</strong><ol>';
      results.bpOptimization.plan.forEach(item => {
        planHtml += '<li>Add ' + item.positions + ' ' + item.strategy + 
          ' position' + (item.positions > 1 ? 's' : '') + 
          ' (+' + item.bpAdded + '%) ' + item.when + '</li>';
      });
      planHtml += '</ol><strong>Final BP: ' + results.bpOptimization.projectedBP + '%</strong>';
      document.getElementById('bpOptimizationPlan').innerHTML = planHtml;
    }
  }
  
  function updatePositionHealth(results) {
    const tbody = document.getElementById('positionRows');
    tbody.innerHTML = '';
    
    if (results.positionHealth?.length > 0) {
      results.positionHealth.forEach(p => {
        const row = tbody.insertRow();
        row.innerHTML = 
          '<td>' + p.ticker + ' ' + p.strategy + '</td>' +
          '<td>' + p.dte + '</td>' +
          '<td>' + (p.pl >= 0 ? '+' : '') + p.pl + '%</td>' +
          '<td>' + p.score + '/100</td>' +
          '<td>' + p.action + '</td>';
        
        if (p.exitTrigger) {
          row.className = 'exit-trigger';
        }
      });
    } else {
      tbody.innerHTML = '<tr class="no-data"><td colspan="5">No current positions</td></tr>';
    }
  }
  
  function updatePatternAnalysis(results) {
    if (!results.patterns) return;
    
    const excellentCount = results.patterns.excellent?.length || 0;
    const goodCount = results.patterns.good?.length || 0;
    const poorCount = results.patterns.poor?.length || 0;
    const noDataCount = results.patterns.noData?.length || 0;
    
    document.getElementById('patternSummary').innerHTML = 
      '<span class="pattern-indicator pattern-excellent">?? EXCELLENT: ' + excellentCount + '</span> ' +
      '<span class="pattern-indicator pattern-good">?? GOOD: ' + goodCount + '</span> ' +
      '<span class="pattern-indicator pattern-poor">?? AVOID: ' + poorCount + '</span> ' +
      '<span class="pattern-indicator pattern-nodata">? NO DATA: ' + noDataCount + '</span>';
    
    let patternHtml = '';
    
    if (excellentCount > 0) {
      patternHtml += '<h4>?? Excellent Opportunities:</h4><ul>';
      results.patterns.excellent.forEach(p => {
        patternHtml += '<li><strong>' + p.ticker + '</strong>: ' + 
          (p.metrics?.currentPrice || 'NO PRICE') + ' ' +
          '(Range: ' + (p.metrics?.range20d || 'N/A') + '%, ' +
          'IV: ' + (p.metrics?.ivRank || 'N/A') + '%)';
        
        if (p.specificRecommendation) {
          const rec = p.specificRecommendation;
          patternHtml += '<br>? Strikes: ' + rec.putStrike + 'P @ £' + rec.putBid + 
            ' / ' + rec.callStrike + 'C @ £' + rec.callBid +
            '<br>? Total Credit: £' + rec.totalCredit;
        }
        patternHtml += '</li>';
      });
      patternHtml += '</ul>';
    }
    
    if (goodCount > 0) {
      patternHtml += '<h4>?? Good Opportunities:</h4><ul>';
      results.patterns.good.forEach(p => {
        patternHtml += '<li>' + p.ticker + ': Score ' + p.score + ' - ' + p.recommendation + '</li>';
      });
      patternHtml += '</ul>';
    }
    
    document.getElementById('patternDetails').innerHTML = patternHtml || 'No qualifying patterns found';
  }
  
  function updatePhaseInfo(results) {
    const phase = results.phase || 1;
    const phaseInfo = {
      1: {
        title: 'Phase 1: Foundation (£30-40k)',
        strategies: ['0DTE (1 contract)', 'IPMCC (1 position)', 'Strangles (1 position)'],
        tickers: ['MCL', 'MGC', 'GLD', 'TLT'],
        target: '8-10% monthly',
        nextPhase: '£40,000'
      },
      2: {
        title: 'Phase 2: Scaling (£40-60k)',
        strategies: ['0DTE (2 contracts)', 'LT112 (MES)', 'IPMCC (2 positions)', 'Strangles (3)', 'Ratio Spreads', 'LEAPs'],
        tickers: ['MCL', 'MGC', 'GLD', 'TLT', 'MES', 'MNQ', 'SLV', 'XOP', '6A', 'M6E'],
        target: '10-12% monthly',
        nextPhase: '£60,000'
      },
      3: {
        title: 'Phase 3: Optimization (£60-75k)',
        strategies: ['0DTE (3 contracts)', 'ES upgrade', 'Butterflies', 'Box Spreads', 'Diagonals', 'All previous'],
        tickers: ['ES', 'CL', 'GC', 'LE', 'HE', 'ZC', 'ZS', 'ZW', '6E', '6B', 'All previous'],
        target: '10-13% monthly',
        nextPhase: '£75,000'
      },
      4: {
        title: 'Phase 4: Professional (£75k+)',
        strategies: ['0DTE (4+ contracts)', 'Full ES positions', 'Weekly 112 stacking', 'All strategies unlocked'],
        tickers: ['All products available - see PDF Pages 22-24'],
        target: '10-12% monthly sustainable',
        nextPhase: 'Portfolio Margin at £111k'
      }
    };
    
    const info = phaseInfo[phase];
    if (info) {
      let html = '<h4>' + info.title + '</h4>';
      html += '<p><strong>Available Strategies:</strong></p><ul>';
      info.strategies.forEach(s => html += '<li>' + s + '</li>');
      html += '</ul>';
      html += '<p><strong>Qualified Tickers:</strong> ' + info.tickers.join(', ') + '</p>';
      html += '<p><strong>Monthly Target:</strong> ' + info.target + '</p>';
      if (info.nextPhase) {
        html += '<p><strong>Next Phase at:</strong> ' + info.nextPhase + '</p>';
      }
      if (results.apiMode) {
        html += '<p><strong>Mode:</strong> ?? API (Real-time data from TastyTrade)</p>';
      }
      document.getElementById('phaseContent').innerHTML = html;
    }
  }
  
  function updateCharts(results) {
    // BP Allocation Chart
    if (results.allocationTable) {
      const bpData = [];
      const bpLabels = [];
      
      results.allocationTable.table.forEach(row => {
        if (row.currentBP > 0) {
          bpLabels.push(row.strategy);
          bpData.push(row.currentBP);
        }
      });
      
      const availableBP = Math.max(0, 100 - results.userData.bpUsed);
      bpLabels.push('Available');
      bpData.push(availableBP);
      
      const bpCanvas = document.getElementById('bpChart');
      if (bpCanvas) {
        if (bpChart) bpChart.destroy();
        
        bpChart = new Chart(bpCanvas, {
          type: 'bar',
          data: {
            labels: bpLabels,
            datasets: [{
              label: 'BP %',
              data: bpData,
              backgroundColor: ['#3498db', '#e74c3c', '#f39c12', '#27ae60', '#9966ff', '#95a5a6']
            }]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: { 
                display: true, 
                text: 'Phase ' + (results.phase || 1) + ' Buying Power Allocation' + 
                      (results.apiMode ? ' (Live)' : '')
              }
            },
            scales: {
              x: { max: 100, beginAtZero: true }
            }
          }
        });
      }
    }
    
    // Concentration Chart
    if (results.concentrationStatus) {
      const groups = ['A1', 'A2', 'B1', 'C1', 'D1', 'E', 'F'];
      const concentrationData = groups.map(g => 
        results.concentrationStatus[g]?.current || 0
      );
      
      if (concentrationData.some(d => d > 0)) {
        const concCanvas = document.getElementById('concentrationChart');
        if (concCanvas) {
          if (concentrationChart) concentrationChart.destroy();
          
          concentrationChart = new Chart(concCanvas, {
            type: 'doughnut',
            data: {
              labels: ['Equity Index', 'Equity ETF', 'Metals', 'Energy', 'Agriculture', 'Bonds', 'Currency'],
              datasets: [{
                data: concentrationData,
                backgroundColor: ['#ff6384', '#36a2eb', '#ffcd56', '#4bc0c0', '#9966ff', '#ff9f40', '#c9cbcf']
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                title: { 
                  display: true, 
                  text: 'Concentration by Group (Max 2 each, 3 for Phase 4)' 
                }
              }
            }
          });
        }
      }
    }
  }
  
  function updateOptionalSections(results) {
    const phase = results.phase || 1;
    
    // SPAN credits (Phase 4 only)
    if (results.spanCredits?.totalSaved > 0 && phase === 4) {
      document.getElementById('spanSection').style.display = 'block';
      let spanHtml = '<ul>';
      results.spanCredits.credits.forEach(c => {
        spanHtml += '<li>' + c.tickers + ': ' + c.reduction + 
          ' reduction = £' + c.bpFreed + '</li>';
      });
      spanHtml += '</ul><strong>Total BP Freed: £' + results.spanCredits.totalSaved + '</strong>';
      document.getElementById('spanContent').innerHTML = spanHtml;
    }
    
    // Weekly staggering (Phase 2+ only)
    if (results.staggering && results.userData.dayOfWeek === 'Wednesday' && phase >= 2) {
      document.getElementById('staggeringSection').style.display = 'block';
      document.getElementById('staggeringContent').innerHTML = 
        '<p>Week ' + results.staggering.currentWeek + ': ' + results.staggering.sizing + '</p>' +
        '<p>Product: ' + results.staggering.product + '</p>' +
        '<p><strong>Recommendation: ' + results.staggering.recommendation + '</strong></p>';
    }
    
    // Tickers to search (phase-specific) - only for manual mode
    if (results.tickersToSearch?.length > 0 && !results.apiMode) {
      document.getElementById('tickerSearchSection').style.display = 'block';
      let searchHtml = '<p>Execute searches for these Phase ' + phase + ' qualified tickers:</p><ul>';
      results.tickersToSearch.forEach(ticker => {
        searchHtml += '<li><strong>' + ticker + '</strong>: Price, Range, IV Rank, Option Chain</li>';
      });
      searchHtml += '</ul>';
      document.getElementById('tickerSearchContent').innerHTML = searchHtml;
    }
    
    // Data quality report
    if (results.dataCompleteness && (!results.dataCompleteness.valid || results.dataCompleteness.warnings?.length > 0)) {
      document.getElementById('dataQuality').style.display = 'block';
      let qualityHtml = '<ul>';
      
      if (results.dataCompleteness.missingTickers?.length > 0) {
        qualityHtml += '<li>Missing Tickers: ' + results.dataCompleteness.missingTickers.join(', ') + '</li>';
      }
      if (results.dataCompleteness.missingFields?.length > 0) {
        qualityHtml += '<li>Missing Fields: ' + results.dataCompleteness.missingFields.join(', ') + '</li>';
      }
      if (results.dataCompleteness.warnings?.length > 0) {
        results.dataCompleteness.warnings.forEach(w => {
          qualityHtml += '<li>' + w + '</li>';
        });
      }
      
      if (results.apiMode) {
        qualityHtml += '<li><strong>API Mode: Data collection should be automatic</strong></li>';
      }
      
      qualityHtml += '</ul>';
      document.getElementById('dataQualityContent').innerHTML = qualityHtml;
    }
  }
  
  // Initial load
  if (window.frameworkResults) {
    updateDashboard(window.frameworkResults);
  } else {
    document.getElementById('warnings').innerHTML = 
      '<div class="warning">Waiting for framework execution...</div>';
  }
});
</script>

</body>
</html>
