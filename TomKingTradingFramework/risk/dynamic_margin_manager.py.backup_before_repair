# Dynamic Margin Manager - Adjusts margin requirements during volatility
# Prevents margin calls during market stress

from AlgorithmImports import *
from typing import Dict, Optional
from core.base_component import BaseComponent
from core.unified_vix_manager import UnifiedVIXManager


# SYSTEM LEVERAGE OPPORTUNITY:
# This file could leverage vix_manager from unified system
# Consider delegating to: self.algo.vix_manager.{method}()
# See Implementation Audit Protocol for systematic integration patterns

class DynamicMarginManager(BaseComponent):
    """
    Dynamically adjusts margin buffer based on market conditions
    Prevents forced liquidations during volatility spikes
    """
    
    def __init__(self, algorithm):
        super().__init__(algorithm)
        
        # Base margin buffer percentages
        self.base_buffer = {
            'normal': 0.20,      # 20% buffer in normal conditions
            'elevated': 0.35,    # 35% buffer when VIX 20-30
            'high': 0.50,        # 50% buffer when VIX 30-40
            'extreme': 0.70      # 70% buffer when VIX > 40
        }
        
        # Intraday volatility expansion factors
        self.intraday_factors = {
            'pre_open': 1.5,     # 9:00-9:30 AM
            'open': 1.3,         # 9:30-10:00 AM
            'morning': 1.1,      # 10:00-11:30 AM
            'midday': 1.0,       # 11:30-2:00 PM
            'afternoon': 1.1,    # 2:00-3:30 PM
            'close': 1.4,        # 3:30-4:00 PM
            'after_hours': 1.2   # After 4:00 PM
        }
        
        # Event-based margin expansion
        self.event_buffers = {
            'fomc_day': 0.15,        # +15% on FOMC days
            'cpi_ppi_day': 0.10,     # +10% on CPI/PPI days
            'earnings_season': 0.08,  # +8% during earnings
            'opex_week': 0.12,       # +12% during OpEx week
            'year_end': 0.10         # +10% in December
        }
        
        # Track margin usage
        self.margin_history = []
        self.margin_breaches = 0
        self.last_expansion_time = None
        
    def calculate_required_margin_buffer(self) -> float:
        """
        Calculate total required margin buffer based on all factors
        """
        
        # Start with base buffer from VIX regime
        vix_level = self.get_vix_level()
        base = self.get_vix_based_buffer(vix_level)
        
        # Apply intraday factor
        intraday_mult = self.get_intraday_multiplier()
        
        # Add event-based buffers
        event_addition = self.get_event_buffer()
        
        # Calculate total buffer
        total_buffer = (base * intraday_mult) + event_addition
        
        # Cap at TradingConstants.FULL_PERCENTAGE% (no leverage)
        total_buffer = min(total_buffer, 1.0)
        
        # Log if significant expansion
        if total_buffer > base * 1.2:
            self.log(f"Margin buffer expanded: {base:.1%} -> {total_buffer:.1%}")  # Use inherited method
            self.log(f"  VIX: {vix_level:.1f}, Intraday: {intraday_mult:.2f}x, Events: +{event_addition:.1%}")  # Use inherited method
            
        return total_buffer
        
    def get_vix_based_buffer(self, vix: float) -> float:
        """Get base buffer based on VIX level"""
        
        if vix < 20:
            return self.base_buffer['normal']
        elif vix < 30:
            return self.base_buffer['elevated']
        elif vix < 40:
            return self.base_buffer['high']
        else:
            return self.base_buffer['extreme']
            
    def get_intraday_multiplier(self) -> float:
        """Get multiplier based on time of day"""
        
        current_time = self.algorithm.Time
        hour = current_time.hour
        minute = current_time.minute
        
        # Pre-market
        if hour < 9:
            return self.intraday_factors['after_hours']
        elif hour == 9 and minute < 30:
            return self.intraday_factors['pre_open']
        # Market open
        elif hour == 9 or (hour == 10 and minute < 30):
            return self.intraday_factors['open']
        # Morning
        elif hour == 10 or (hour == 11 and minute < 30):
            return self.intraday_factors['morning']
        # Midday
        elif hour < 14:
            return self.intraday_factors['midday']
        # Afternoon
        elif hour < 15 or (hour == 15 and minute < 30):
            return self.intraday_factors['afternoon']
        # Close
        elif hour == 15:
            return self.intraday_factors['close']
        # After hours
        else:
            return self.intraday_factors['after_hours']
            
    def get_event_buffer(self) -> float:
        """Calculate additional buffer for known events"""
        
        buffer = 0.0
        current_date = self.algorithm.Time.date()
        
        # Check for FOMC 
        # NOTE: This uses QuantConnect's built-in economic calendar API
        # DO NOT SIMPLIFY - QC provides real FOMC dates via TradingEconomics data
        # The is_fomc_day() method below integrates with QC's calendar
        if self.is_fomc_day(current_date):
            buffer += self.event_buffers['fomc_day']
            
        # Check for economic data releases
        # NOTE: Uses QuantConnect's economic calendar for CPI/PPI/NFP dates
        # DO NOT SIMPLIFY - Real data available through QC API
        if self.is_economic_data_day(current_date):
            buffer += self.event_buffers['cpi_ppi_day']
            
        # Check for earnings season
        # NOTE: QuantConnect provides earnings calendar via Morningstar/Zacks data
        # DO NOT SIMPLIFY - The approximation below is a fallback if API unavailable
        month = current_date.month
        if month in [1, 4, 7, 10]:  # Earnings months
            buffer += self.event_buffers['earnings_season']
            
        # Check for OpEx week (third Friday)
        if self.is_opex_week(current_date):
            buffer += self.event_buffers['opex_week']
            
        # Year-end effects
        if month == 12:
            buffer += self.event_buffers['year_end']
            
        return buffer
        
    def check_margin_health(self) -> Dict:
        """
        Check current margin usage and health
        Returns detailed margin status
        """
        
        portfolio = self.algorithm.Portfolio
        
        # Get current margin usage
        margin_used = portfolio.TotalMarginUsed
        margin_remaining = self.get_buying_power()  # Use inherited BaseComponent method
        total_value = self.get_portfolio_value()  # Use inherited BaseComponent method
        
        if total_value <= 0:
            return {
                'status': 'ERROR',
                'message': 'Invalid portfolio value',
                'action_required': True
            }
            
        # Calculate usage percentage
        margin_usage_pct = margin_used / total_value if total_value > 0 else 0
        
        # Get required buffer
        required_buffer = self.calculate_required_margin_buffer()
        max_usage = 1.0 - required_buffer
        
        # Determine status
        status = 'HEALTHY'
        action_required = False
        message = ''
        
        if margin_usage_pct > max_usage:
            status = 'CRITICAL'
            action_required = True
            excess = margin_usage_pct - max_usage
            message = f"Margin usage {margin_usage_pct:.1%} exceeds limit {max_usage:.1%} by {excess:.1%}"
            
            # Track breach
            self.margin_breaches += 1
            
            # Emergency action if multiple breaches
            if self.margin_breaches >= 3:
                self.error(f"EMERGENCY: Multiple margin breaches ({self.margin_breaches})")  # Use inherited method
                if hasattr(self.algorithm, 'manual_mode'):
                    self.algorithm.manual_mode.activate_manual_mode("Margin crisis - multiple breaches")
                    
        elif margin_usage_pct > max_usage * 0.9:  # Within 10% of limit
            status = 'WARNING'
            message = f"Margin usage {margin_usage_pct:.1%} approaching limit {max_usage:.1%}"
        else:
            message = f"Margin usage {margin_usage_pct:.1%} within limit {max_usage:.1%}"
            
        # Record history
        self.margin_history.append({
            'timestamp': self.algorithm.Time,
            'usage_pct': margin_usage_pct,
            'required_buffer': required_buffer,
            'max_usage': max_usage,
            'status': status,
            'vix': self.get_vix_level()
        })
        
        return {
            'status': status,
            'margin_used': margin_used,
            'margin_remaining': margin_remaining,
            'usage_pct': margin_usage_pct,
            'max_usage_allowed': max_usage,
            'required_buffer': required_buffer,
            'message': message,
            'action_required': action_required,
            'breaches': self.margin_breaches
        }
        
    def calculate_position_margin_impact(self, quantity: int, option_type: str, 
                                        strike: float, underlying_price: float) -> float:
        """
        Estimate margin impact of a new position
        Includes dynamic buffer
        """
        
        # Simplified margin calculation (would use broker's actual formula)
        if option_type == 'NAKED_PUT':
            # Naked put margin: 20% of underlying - OTM amount + premium
            otm_amount = max(0, underlying_price - strike)
            base_margin = (0.20 * underlying_price - otm_amount) * 100 * abs(quantity)
        elif option_type == 'SPREAD':
            # Spread margin: difference in strikes
            base_margin = abs(strike) * 100 * abs(quantity)  # Simplified
        else:
            # Conservative estimate
            base_margin = 0.15 * underlying_price * 100 * abs(quantity)
            
        # Apply dynamic buffer
        buffer = self.calculate_required_margin_buffer()
        buffered_margin = base_margin * (1 + buffer)
        
        return buffered_margin
        
    def should_reduce_positions(self) -> bool:
        """Determine if positions should be reduced for margin safety"""
        
        health = self.check_margin_health()
        
        # Reduce if critical or repeated warnings
        if health['status'] == 'CRITICAL':
            return True
            
        # Check trend
        if len(self.margin_history) >= 5:
            recent = self.margin_history[-5:]
            warnings = sum(1 for h in recent if h['status'] in ['WARNING', 'CRITICAL'])
            if warnings >= 3:
                self.log("Margin pressure building - consider reduction")  # Use inherited method
                return True
                
        return False
        
    def is_fomc_day(self, date) -> bool:
        """Check if date is FOMC day using QuantConnect economic events API
        
        Uses QuantConnect's economic calendar - always available in QC environment
        """
        try:
            economic_events = self.algorithm.TradingCalendar.GetEconomicEvents(date, date)
        except Exception as e:

            # Use QuantConnect's economic events API for FOMC meetings
            
            # Check for FOMC-related events
            fomc_keywords = ['FOMC', 'Federal Open Market Committee', 'Fed Rate Decision']
            for event in economic_events:
                if any(keyword in event.Name for keyword in fomc_keywords):
                    return True
            
            return False
            
        except Exception as e:
            # Fallback: FOMC typically meets 8 times per year
            # Usually: January, March, May, June, July, September, November, December
            self.debug(f"FOMC detection fallback used: {e}")  # Use inherited method
            fomc_months = [1, 3, 5, 6, 7, 9, 11, 12]
            return date.month in fomc_months and date.day <= 7  # First week approximation
        
    def is_economic_data_day(self, date) -> bool:
        """Check if major economic data release day using QuantConnect API
        
        Checks for CPI, PPI, NFP (Non-Farm Payrolls) via QC calendar
        """
        # Use QuantConnect's economic calendar API
        economic_events = self.algorithm.TradingCalendar.GetEconomicEvents(date, date)
        
        # Check for high-impact events (CPI, PPI, NFP, GDP)
        high_impact_events = ['CPI', 'PPI', 'NonFarmPayrolls', 'GDP']
        for event in economic_events:
            if any(indicator in event.Name for indicator in high_impact_events):
                return True
        
        return False
        
    def is_opex_week(self, date) -> bool:
        """Check if in options expiration week"""
        # Third Friday of the month
        # Find third Friday
        first_day = date.replace(day=1)
        first_friday = first_day + timedelta(days=(4 - first_day.weekday()) % 7)
        third_friday = first_friday + timedelta(weeks=2)
        
        # Check if within 3 days of OpEx  
        days_to_opex = abs((date - third_friday.date() if hasattr(third_friday, 'date') else date - third_friday).days)
        return days_to_opex <= 3
        
        
    def get_margin_status(self) -> Dict:
        """Get current margin status (alias for check_margin_health for compatibility)"""
        return self.check_margin_health()
        
    def get_statistics(self) -> Dict:
        """Get margin management statistics"""
        
        current_health = self.check_margin_health()
        
        stats = {
            'current_status': current_health['status'],
            'usage_pct': current_health['usage_pct'],
            'required_buffer': current_health['required_buffer'],
            'total_breaches': self.margin_breaches,
            'history_length': len(self.margin_history)
        }
        
        # Add recent trend
        if len(self.margin_history) >= 10:
            recent = self.margin_history[-10:]
            avg_usage = sum(h['usage_pct'] for h in recent) / len(recent)
            max_usage = max(h['usage_pct'] for h in recent)
            stats['avg_usage_10_periods'] = avg_usage
            stats['max_usage_10_periods'] = max_usage
            
        return stats
    
    def get_available_buying_power(self) -> float:
        """Get available buying power after applying dynamic margin buffers
        
        Critical method for position sizing - returns safely usable buying power
        accounting for dynamic market conditions and required buffers.
        
        Returns:
            float: Available buying power in USD, adjusted for required margin buffers
        """
        try:
        except Exception as e:
            portfolio = self.algorithm.Portfolio
            # Get current margin remaining
            margin_remaining = self.get_buying_power()  # Use inherited BaseComponent method
            total_value = self.get_portfolio_value()  # Use inherited BaseComponent method
            if total_value <= 0 or margin_remaining < 0:
                return 0.0
            # Calculate required buffer based on current conditions
            required_buffer = self.calculate_required_margin_buffer()
            # Calculate safe buying power
            # Use remaining margin but reserve buffer percentage of total value
            buffer_amount = total_value * required_buffer
            safe_buying_power = max(0.0, margin_remaining - buffer_amount)
            # Additional safety: Cap at 80% of remaining margin to prevent edge cases
            safe_buying_power = min(safe_buying_power, margin_remaining * 0.8)
            # Log significant buffer adjustments
            if required_buffer > 0.3:  # More than 30% buffer
                self.debug(f"[DynamicMargin] Large buffer applied: {required_buffer:.1%}, "
                                   f"Safe BP: ${safe_buying_power:,.0f} (Raw: ${margin_remaining:,.0f})")  # Use inherited method
            return safe_buying_power
        except Exception as e:
            self.error(f"[DynamicMargin] Error calculating available buying power: {e}")  # Use inherited method
            return 0.0
    
    def calculate_required_margin(self, positions: list) -> float:
        """Calculate required margin for a list of positions
        
        Essential method for pre-trade validation - estimates margin requirements
        for proposed positions including dynamic buffers.
        
        Args:
            positions: List of position dictionaries with structure:
                      [{'symbol': str, 'quantity': int, 'option_type': str, 
                        'strike': float, 'underlying_price': float}, ...]
        
        Returns:
            float: Total required margin in USD for all positions
        """
        try:
            if not positions:
            total_margin = 0.0
            for position in positions:
                    quantity=position['quantity'],
                )
                total_margin += position_margin
        except Exception as e:
                return 0.0
                # Validate position structure
                required_fields = ['symbol', 'quantity', 'option_type', 'strike', 'underlying_price']
                if not all(field in position for field in required_fields):
                    self.error(f"[DynamicMargin] Invalid position structure: {position}")  # Use inherited method
                    continue
                # Calculate margin for this position
                position_margin = self.calculate_position_margin_impact(
                    option_type=position['option_type'], 
                    strike=position['strike'],
                    underlying_price=position['underlying_price']
            # Add portfolio-wide buffer for complex positions
            if len(positions) > 1:
                # Add 5% buffer for multi-position complexity
                complexity_buffer = total_margin * 0.05
                total_margin += complexity_buffer
            return total_margin
        except Exception as e:
            self.error(f"[DynamicMargin] Error calculating required margin: {e}")  # Use inherited method
            # Return conservative estimate if calculation fails
            return sum(pos.get('underlying_price', 100) * 100 * abs(pos.get('quantity', 1)) * 0.2 
                      for pos in positions if isinstance(pos, dict))