TOM KING TRADING FRAMEWORK v17.2
?? TABLE OF CONTENTS
CORE FRAMEWORK SECTIONS
1. Framework Purpose & Modes
2. PDF Reference Guide
3. Required User Input
4. Required Data Structure
5. Execution Sequence
6. Core Calculation Rules
7. Error Handling
8. Output Format Sections
9. Framework Limitations
10. Troubleshooting Guide
API INTEGRATION SECTIONS
11. TastyTrade API Setup
12. API Authentication
13. API Data Collection
14. API Order Execution
15. WebSocket Streaming
16. API Mode Integration
IMPLEMENTATION SECTIONS
17. Complete Pattern Analysis Code v17.2
18. HTML Dashboard Template
19. Testing Procedures

FRAMEWORK PURPOSE & MODES
This framework executes the Tom King trading methodology by analyzing positions, calculating opportunities, and generating specific trade recommendations based on real market data. It bridges strategy documentation with live market execution through automated pattern analysis and position management.
Three Execution Modes
1. API Mode - Real-time data from TastyTrade
2. Manual Mode - Web searches
3. Test Mode - Simulated data
Framework Features
* Complete search result parsing instructions
* Progressive Friday pre-market analysis (3 phases)
* Complete integration example with BP table
* TastyTrade API integration
* API error handling & fallback mechanisms
* Symbol utilities & Greeks monitoring
* Section 9B advanced strategies
* August 5, 2024 disaster prevention
* Comprehensive test suite
* Real-time position tracking
* WebSocket streaming
* Complete HTML dashboard
* Pound sterling (£) pricing throughout
Critical Requirement
This framework REQUIRES the analysis tool (REPL) to execute the JavaScript pattern analysis code. The framework cannot function without executing this code.

PDF REFERENCE GUIDE
The framework references the "Tom King Complete Trading System Documentation" PDF. Use this guide to locate specific information:
SectionPDF PagesFramework UsageKey Quotes & Principles1-2Tom's philosophy, risk management mindsetMathematical Formulas2-5Position sizing, Kelly Criterion, strike calculationsRisk Metrics3-4Health scores, expectancy, drawdown toleranceCorrelation Calculations3-4Group exposure, coefficient checksVIX-Adjusted Formulas4-5Sizing by volatility, butterfly debitsWeekly Iron Condor Variations4-50DTE structures, broken wings, Batman spreadsComplete Margin & BP Requirements5-6Micro/Mini/Full futures, ETF requirementsNever Trade List6-7Products/strategies Tom avoidsAugust 5, 2024 Lesson7-8The �308k loss, correlation disasterWin Rate Targets8-9Strategy-specific expectationsManagement Protocols by DTE9-1021 DTE rule, 50% rule, defensive linesTax Optimization10-11UK/US considerations, Section 1256Critical Foundation11-13Non-negotiable rules, correlation groups, VIX regimesPhase 1: �30-40k13-15Foundation strategies, 0DTE, IPMCC, stranglesPhase 2: �40-60k15-18Scaling, enhanced 0DTE, LT112, ratio spreadsPhase 3: �60-75k18-22Optimization, butterflies, ES futures upgradePhase 4: �75k+22-24Professional deployment, full systemComplete Specifications24-36Detailed specs for all 10 strategiesDaily Execution Checklist37-38Day-by-day tasksAutomation Triggers38-39Entry/exit/risk triggersP&L Expectations39-40Monthly targets by account sizeCritical Success Factors40-41Non-negotiables, optimizations, reality checksLegal Disclaimer41-42Risk warnings, prerequisitesCommon Mistakes42-43Fatal errors, profit killersMonthly Checklist43-44Weekly and monthly tasksTom's 40-Year Wisdom45-49Account blowups, lessons, final rules
REQUIRED USER INPUT
Option 1: Manual Mode Input
Provide your trading data in this EXACT format:
Account Value: �[amount]
Current Positions: [strategy ticker (DTE, entry price, current P&L%)] or "none"
Buying Power Used: [%]
Current Date/Time: [Day, Date, Time EST]
VIX Level: [current]
Portfolio Margin: [Yes/No]
Month P&L: �[amount] (optional)
Example Input Format (DO NOT USE THESE VALUES):
�75000 | ES LT112 (85 DTE, 6420, +5%), MCL strangle (55 DTE, 2.80, +15%), MGC strangle (55 DTE, 3.20, +8%), QQQ IPMCC (280 DTE, 380/weekly, -2%) | 32% | Friday Jan 10 10:15 AM EST | VIX 15.2 | No | �2450
Option 2: API Mode Input
Mode: API
Client Secret: [your_oauth2_secret] 
Refresh Token: [your_refresh_token]
Environment: [production]
Option 3: Test Mode Override
To test specific day scenarios, add: "Pretend it's [Day] [Date] [Time]" to your input. Example: �40000 | none | 0% | Pretend it's Friday 01/10 9:15 AM EST | VIX 15.2 | No

REQUIRED DATA STRUCTURE
SearchedData Structure Definition
The framework requires searchedData object with this EXACT structure (populated from searches OR API):
const searchedDataStructure = {
  ES: {
    // Basic Price Data
    currentPrice: number,        // Search: "ES current price" OR API: /market-data
    openPrice: number,           // Search: "ES opening price" OR API: /market-data
    previousClose: number,       // Search: "ES yesterday close" OR API: /market-data
    
    // Range Data
    high5d: number,              // Search: "ES 5-day high" OR API: calculated
    low5d: number,               // Search: "ES 5-day low" OR API: calculated
    high20d: number,             // Search: "ES 20-day high" OR API: calculated
    low20d: number,              // Search: "ES 20-day low" OR API: calculated
    
    // Technical Indicators
    atr: number,                 // Search: "ES ATR" OR API: calculated
    rsi: number,                 // Search: "ES RSI" OR API: calculated
    ema8: number,                // Search: "ES 8 EMA" OR API: calculated
    ema21: number,               // Search: "ES 21 EMA" OR API: calculated
    vwap: number,                // Search: "ES VWAP" OR API: streaming
    
    // Volatility Data
    iv: number,                  // Search: "ES implied volatility" OR API: /option-chains
    ivRank: number,              // Search: "ES IV rank" OR API: calculated
    ivPercentile: number,        // Search: "ES IV percentile" OR API: calculated
    
    // Option Chain Data
    optionChain: {
      // Strangle strikes (90 DTE)
      put5Delta: number,         // Search: "ES 90 DTE 5 delta put strike" OR API: /option-chains
      put5DeltaBid: number,      // Search: "ES 90 DTE 5 delta put bid" OR API: /market-data
      call5Delta: number,        // Search: "ES 90 DTE 5 delta call strike" OR API: /option-chains
      call5DeltaBid: number,     // Search: "ES 90 DTE 5 delta call bid" OR API: /market-data
      
      // 0DTE spreads (Friday only)
      atmStrike: number,         // Search: "ES 0DTE ATM strike" OR API: calculated
      call30Wide: {
        shortStrike: number,     // Search: "ES 0DTE call spread strikes" OR API: calculated
        longStrike: number,
        credit: number           // Search: "ES 0DTE call spread credit" OR API: /market-data
      },
      put30Wide: {
        shortStrike: number,     // Search: "ES 0DTE put spread strikes" OR API: calculated
        longStrike: number,
        credit: number           // Search: "ES 0DTE put spread credit" OR API: /market-data
      },
      ironCondor: {
        credit: number           // Search: "ES 0DTE iron condor credit" OR API: calculated
      }
    }
  },
  // Additional tickers follow same structure
  SPY: { /* same structure */ },
  VIX: { currentLevel: number, avg20d: number },
  DXY: { currentLevel: number, trend: string },
  TIME: { 
    currentEST: string,          // Search: "current time EST" OR API: Date.now()
    currentUK: string,           // Search: "current UK time" OR API: calculated
    marketStatus: string         // Derived from time OR API: /trading-status
  }
};
How to Parse Search Results (CRITICAL SECTION)
This section is ESSENTIAL for manual mode operation. Without these parsing instructions, manual mode cannot function.

Price Data Parsing:
* Search result: "ES is currently trading at $6,468.50, up $48.50 from the open"
  - currentPrice: 6468.50  // Extract number after "trading at $"
  - dayChange: 48.50       // Extract number after "up $" or "down $"
* Search result: "SPY opened at $540.25 and is now $542.10"
  - openPrice: 540.25      // Number after "opened at"
  - currentPrice: 542.10   // Number after "now"

Range Data Parsing:
* Search result: "5-day range: 6380 - 6485"
  - high5d: 6485          // Number after dash
  - low5d: 6380           // Number before dash
* Search result: "20-day range: Low 6250, High 6520"
  - high20d: 6520         // Number after "High"
  - low20d: 6250          // Number after "Low"

Technical Indicators Parsing:
* Search result: "ATR(14) is 45 points"
  - atr: 45               // Extract number before "points"
* Search result: "RSI reading: 58.3 (neutral)"
  - rsi: 58               // Round to integer
* Search result: "8 EMA at 5420, 21 EMA at 5415"
  - ema8: 5420            // Number after "8 EMA at"
  - ema21: 5415           // Number after "21 EMA at"
* Search result: "VWAP currently 5422.50"
  - vwap: 5422.50         // Number after "VWAP"

Volatility Data Parsing:
* Search result: "Implied Volatility: 15.2%"
  - iv: 15.2             // Number before "%"
* Search result: "IV Rank: 35th percentile"
  - ivRank: 35           // Number before "th" or "%"
* Search result: "IV Percentile is 42%"
  - ivPercentile: 42     // Number before "%"

Option Chain Parsing:
* Search result: "90 DTE 5-delta put: 6200 strike, bid 2.50, ask 2.75"
  - put5Delta: 6200      // Number before "strike"
  - put5DeltaBid: 2.50   // Number after "bid"
  - put5DeltaAsk: 2.75   // Number after "ask"
* Search result: "90 DTE 5-delta call: 6700 strike, bid 2.45, ask 2.60"
  - call5Delta: 6700     // Number before "strike"
  - call5DeltaBid: 2.45  // Number after "bid"

0DTE Option Chain Parsing (Friday Only):
* Search result: "0DTE ATM 5425 strike"
  - atmStrike: 5425      // Number before "strike"
* Search result: "0DTE 5455/5485 call spread: 1.85 credit"
  - call30Wide.shortStrike: 5455  // First number
  - call30Wide.longStrike: 5485   // Second number
  - call30Wide.credit: 1.85       // Number before "credit"

Spread Credit Calculations:
* For vertical spreads: Credit = Short Bid - Long Ask
* Example: Short 6450 bid 4.25, Long 6480 ask 1.75
  - Spread credit = 4.25 - 1.75 = 2.50
* For iron condors: Total Credit = Put Spread Credit + Call Spread Credit
* Example: Put spread 1.90, Call spread 1.85
  - Iron condor credit = 1.90 + 1.85 = 3.75
Handling Missing or Failed Searches:
// If search fails or returns no results:
ivRank: null         // Mark as null
// Framework will show "NO DATA" and continue

// If partial data returned:
optionChain: {
  put5Delta: 6200,   // Found this
  put5DeltaBid: null, // But not this
  call5Delta: 6700,   // Found this
  call5DeltaBid: null // But not this
}

EXECUTION SEQUENCE
STEP 1: VALIDATE & PARSE
1. Parse user input for all required fields
2. Detect current day/time (or apply testing override if provided)
3. Verify day matches date
4. Identify allowed strategies for detected day
5. Calculate available buying power based on phase
6. In API mode: Authenticate with TastyTrade
7. In API mode: Fetch account balances and positions automatically
STEP 2: GATHER MARKET DATA
API Mode (Automatic)
// Automatic data collection via API
const api = new TastyTradeAPI(clientSecret, refreshToken);
await api.authenticate();
const searchedData = await api.buildSearchedData();
Manual Mode (Web Searches)
MANDATORY SEARCHES - NO EXCEPTIONS:
Core Market Searches (ALWAYS):
1. Search: "current time EST and UK time"
2. Search: "ES futures current price opening price 5-day high low 20-day range ATR"
3. Search: "SPY current price support resistance RSI 8 EMA 21 EMA"
4. Search: "VIX current level 20-day average regime"
5. Search: "DXY dollar index level trend"
Phase-Based Ticker Searches: Based on account value phase (See PDF Pages 13-24):
* Phase 1 (�30-40k): MCL, MGC, GLD, TLT
* Phase 2 (�40-60k): Add MES, MNQ, 6A, M6E, SLV, XOP
* Phase 3 (�60-75k): Add ES upgrade, CL, GC, LE, HE, ZC, ZS, ZW, 6E, 6B
* Phase 4 (�75k+): All products available
FOR EACH QUALIFIED TICKER (based on phase): IF ticker not at concentration limit:
* Search: "[TICKER] current price 20-day high low"
* Search: "[TICKER] IV rank IV percentile ATR"
* Search: "[TICKER] 90 DTE 5 delta put strike bid"
* Search: "[TICKER] 90 DTE 5 delta call strike bid"
Progressive Friday Pre-Market Analysis (3-PHASE STRUCTURE):
This progressive analysis is CRITICAL for successful 0DTE execution on Fridays.

+--- PHASE 1: 9:00-9:30 AM EST - OVERNIGHT ASSESSMENT ---+
Purpose: Understand overnight market dynamics and positioning
MANDATORY SEARCHES:
1. Search: "ES overnight high low current from yesterday close"
   - Extract: Overnight range, current bias
2. Search: "ES Globex volume overnight session total contracts"
   - Extract: Volume levels, unusual activity
3. Search: "Economic calendar today Fed speakers data releases times"
   - Extract: Key events, timing, potential volatility
4. Search: "Major overnight news Europe Asia market moves"
   - Extract: Global context, risk events
5. Search: "Dollar index overnight movement trend"
   - Extract: USD strength/weakness

CALCULATIONS:
- Overnight range as % of yesterday's range
- Distance from yesterday's value area
- Initial bias: Bullish/Bearish/Neutral

+--- PHASE 2: 9:30-10:00 AM EST - OPENING RANGE DEVELOPMENT ---+
Purpose: Identify early market structure and momentum
MANDATORY SEARCHES:
1. Search: "ES opening range first 30 minutes high low volume"
   - Extract: Opening range boundaries
2. Search: "SPY opening price 30-minute range VWAP deviation"
   - Extract: ETF correlation, VWAP magnet
3. Search: "ES order flow imbalance buying selling pressure delta"
   - Extract: Aggressive buyers vs sellers
4. Search: "VIX opening level change from yesterday"
   - Extract: Volatility expectations
5. Search: "Major sector rotation technology financials energy"
   - Extract: Sector leadership

CALCULATIONS:
- Opening range width vs 10-day average
- VWAP deviation bands
- Momentum oscillator readings
- Initial 0DTE strike selections

+--- PHASE 3: 10:00-10:30 AM EST - FINAL 0DTE PREPARATION ---+
Purpose: Lock in exact entry triggers and position sizing
MANDATORY SEARCHES:
1. Search: "ES current position from open percentage move trend"
   - Extract: % move from open, trend strength
2. Search: "ES 0DTE option chain ATM 30-point spreads current bid ask"
   - Extract: Exact strikes and credits
3. Search: "ES gamma exposure levels max pain pinning levels"
   - Extract: Key magnetic levels
4. Search: "0DTE implied move expected range probability"
   - Extract: Market maker expectations
5. Search: "Current market internals ADD VOLD TICK readings"
   - Extract: Breadth confirmation

FINAL CALCULATIONS:
- Exact trigger levels: ±0.5% from open (per PDF Page 25)
- Call spread trigger: ES above [OpenPrice × 1.005]
- Put spread trigger: ES below [OpenPrice × 0.995]
- Iron condor zone: Between triggers
- Position size: Based on phase and BP available
- Expected credits for each scenario

VISUAL COUNTDOWN:
⏰ TIME REMAINING: [30 - CurrentMinutes] minutes until 10:30 AM
📊 MARKET STATUS: [TRENDING/RANGING/CHOPPY]
🎯 READY TO EXECUTE: [YES/NO - Reason]
STEP 3: CALCULATE WITH REAL DATA
Execute pattern analysis code in the analysis tool using searched/API data to calculate:
* Position health scores using PDF formulas (Pages 3-4)
* Pattern quality ratings for each ticker with specific strikes
* Concentration group usage per PDF limits (Page 12)
* VIX regime BP limits per PDF (Pages 11-12)
* Optimal position sizing by phase (Pages 13-24)
* Expected returns based on win rates (Pages 8-9)
* Generate Position Allocation Table based on current phase
STEP 4: OUTPUT RESULTS
Generate comprehensive analysis with:
* Text-based position analysis with health scores
* SPECIFIC trade recommendations with exact strikes and credits
* Position allocation table showing BP optimization by phase
* HTML dashboard with calculated values
* In API mode: Prepared order payloads ready for submission
* NO PLACEHOLDERS - ONLY REAL DATA FROM SEARCHES OR API

COMPLETE INTEGRATION EXAMPLE
This example demonstrates the FULL framework execution for a Phase 2 account (£40-60k).

EXAMPLE SCENARIO: £40,000 Account on Friday, January 12, 2024 at 10:15 AM EST

Step 1: Determine Phase & Available Strategies
Account Value: £40,000
Phase: 2 (£40-60k range)
Available Strategies: 
- 0DTE: 2 contracts maximum (Friday only, after 10:30 AM)
- LT112: 4 positions (using MES, not ES)
- IPMCC: 2 positions
- Strangles: 3 positions (90 DTE)
- Ratio Spreads: 2 positions

Step 2: Execute Phase-Specific Searches
CORE SEARCHES (All Phases):
✓ Search: "current time EST and UK time"
  Result: "10:15 AM EST, 3:15 PM UK"
✓ Search: "ES futures current price opening price 5-day high low"
  Result: "ES at 5421.50, opened 5410, 5-day: 5380-5485"
✓ Search: "VIX current level 20-day average"
  Result: "VIX 15.2, 20-day avg 16.8"

PHASE 2 TICKER SEARCHES:
✓ Search: "MES current price IV rank"
  Result: "MES 5421.50, IV rank 35th percentile"
✓ Search: "MCL crude oil current price 90 DTE options"
  Result: "MCL 72.45, 90 DTE: 68 put 0.85 bid, 77 call 0.80 bid"
✓ Search: "MGC gold current price volatility"
  Result: "MGC 2045, IV 12.5%"

Step 3: Calculate Buying Power Usage
Current Positions: None
BP Used: 0%
BP Available: 100%
Phase 2 Target: 55-65% BP usage
Gap to Minimum: 55%

Step 4: Generate Recommendations Based on Data
PATTERN ANALYSIS RESULTS:
✓ MES: EXCELLENT setup for LT112 (above 8 EMA, RSI 52)
✓ MCL: GOOD setup for strangle (IV rank 35, good premium)
✓ MGC: GOOD setup for strangle (low IV but stable range)
✓ ES 0DTE: Waiting for 10:30 AM (15 minutes)

Step 5: Position Allocation Table
+---------------------------------------------------------------+
|      POSITION ALLOCATION & BP OPTIMIZATION TABLE              |
|              Phase 2: £40,000 Account                         |
+---------------------------------------------------------------+

Strategy    | Max Pos | Current | Avail | BP/Pos | BP Used | Can Add | Priority
------------|---------|---------|-------|--------|---------|---------|----------
LT112 (MES) | 4       | 0       | 4     | 3%     | 0%      | YES     | HIGH
STRANGLE    | 3       | 0       | 3     | 2.5%   | 0%      | YES     | HIGH
0DTE        | 2       | 0       | 2     | 2%     | 0%      | WAIT    | FRIDAY
IPMCC       | 2       | 0       | 2     | 8%     | 0%      | YES     | MEDIUM
RATIO       | 2       | 0       | 2     | 2%     | 0%      | YES     | LOW

VIX REGIME (15.2): NORMAL - Target 55-65% BP usage
Current: 0% | Gap to Min: 55% | Available: £40,000

OPTIMIZATION PLAN TO REACH PHASE TARGET:
1. IMMEDIATE: Enter 2 MES LT112 positions (6% BP)
2. IMMEDIATE: Enter MCL & MGC strangles (5% BP)
3. AT 10:30 AM: Execute 1 ES 0DTE spread (2% BP)
4. NEXT WEEK: Add IPMCC on QQQ (8% BP)
5. TOTAL: Would use 21% BP, need 34% more for target

Step 6: Specific Trade Recommendations
📊 RECOMMENDATIONS WITH EXACT STRIKES:
1. MES LT112 #1: Buy 90 DTE 5350/5500 for £135 (3% BP)
2. MES LT112 #2: Buy 90 DTE 5375/5525 for £140 (3% BP)
3. MCL Strangle: Sell 68P/77C for £1.65 credit (2.5% BP)
4. MGC Strangle: Sell 2000P/2090C for £1.45 credit (2.5% BP)
5. [10:30 AM] ES 0DTE: Based on market position (2% BP)

TOTAL BP AFTER EXECUTION: 13%
REMAINING TO TARGET: 42%

CORE CALCULATION RULES
The 10 Essential Rules (from PDF Pages 11-13):
1. BP LIMIT: Never exceed phase-specific BP usage (40-50% Phase 1, up to 80% Phase 4)
2. VIX REGIME: Adjust BP deployment per PDF Page 12
3. CONCENTRATION: Maximum 2 positions per correlation group (3 for Phase 4)
4. DAY MATCHING: Only trade strategies allowed on current day
5. DATA FIRST: No recommendations without actual market data
6. EXIT PRIORITY: Use PDF exit rules (Pages 9-10)
7. PATTERN QUALITY: Only trade EXCELLENT or GOOD setups
8. EXACT STRIKES: Calculate specific strikes from real chains
9. SUSTAINABILITY: Alert if monthly return exceeds 12% (PDF Page 41)
10. POSITION SIZING: Use phase-based maximums (Pages 13-24)
BP Maximization by Phase:
function getBPTargetByPhase(accountValue, vixLevel) {
  if (accountValue < 40000) {
    // Phase 1: Conservative
    return { min: 40, max: 50 };
  } else if (accountValue < 60000) {
    // Phase 2: Scaling
    return { min: 55, max: 65 };
  } else if (accountValue < 75000) {
    // Phase 3: Optimization
    return { min: 60, max: 75 };
  } else {
    // Phase 4: Professional
    return getVIXRegimeLimits(vixLevel);
  }
}
Complete BP Requirements Table (PDF Pages 5-6, 13-24):
Strategy    | Micro BP | Full BP | Phase 1 | Phase 2 | Phase 3 | Phase 4
------------|----------|---------|---------|---------|---------|--------
STRANGLE    | 2.5%     | 3.5%    | 1       | 3       | 4       | 5
LT112       | 3% (MES) | 6% (ES) | 0       | 4       | 1       | 3
IPMCC       | 8%       | 8%      | 1       | 2       | 3       | 4
0DTE        | 2%       | 2%      | 1       | 2       | 3       | 4
BUTTERFLY   | 0.5%     | 0.5%    | 0       | 0       | 2       | 4
RATIO       | 2%       | 2%      | 0       | 2       | 4       | 5
DIAGONAL    | 1.5%     | 1.5%    | 0       | 0       | 2       | 4
LEAP        | 2%       | 2%      | 0       | 2       | 3       | 10
BOX         | 0%       | 0%      | 0       | 0       | 1       | 2

ERROR HANDLING
Unified Error System:
* ? ERROR: Critical issues requiring immediate attention
* ?? BLOCKED: Cannot proceed without resolution
* ?? WARNING: Important but non-blocking issues
* ?? INFO: Informational messages
Common Errors:
* NO DATA: "Cannot recommend without market data - initiating searches"
* BP EXCEEDED: "Would use X%, phase maximum Y% - reduce position size"
* GROUP LIMIT: "Correlation group at maximum per PDF Page 12"
* WRONG DAY: "Strategy only available on [Day] per phase schedule"
* EXIT TRIGGER: "Position requires immediate closure per PDF Pages 9-10"
* API FAILURE: "API connection failed - falling back to manual mode"

OUTPUT FORMAT SECTIONS
Position Allocation Table (MANDATORY):
+---------------------------------------------------------------+
�      POSITION ALLOCATION & BP OPTIMIZATION TABLE              �
�              Phase [X]: �[Account Value]                      �
+---------------------------------------------------------------+

Strategy    | Max Pos | Current | Avail | BP/Pos | BP Used | Can Add | Priority
------------|---------|---------|-------|--------|---------|---------|----------
[Phase-specific strategies based on PDF Pages 13-24]

VIX REGIME ([Level]): [Regime] - Target [Min]-[Max]% BP usage
Current: [X]% | Gap to Min: [Y]% | Available: [Z]%

OPTIMIZATION PLAN TO REACH PHASE TARGET:
[Phase-specific recommendations]
Friday Pre-Market Analysis (Before 10:30 AM):
+---------------------------------------------------------------+
�         PRE-MARKET 0DTE ANALYSIS - [Time] EST                 �
�            (See PDF Page 25 for Specifications)               �
+---------------------------------------------------------------+

ES OVERNIGHT MOVEMENT:
+- Range: $[Low] - $[High] ([Range] points)
+- Current: $[Price] ([Change]% from close)
+- Direction: [BULLISH/BEARISH/NEUTRAL]

+---------------------------------------------------------------+
�      KEY LEVELS FOR 10:30 AM EXECUTION                        �
�         (Per Tom King 0DTE Rules - PDF Page 25)               �
�---------------------------------------------------------------�
� ?? CALL SPREAD TRIGGER: ES above $[Price] (+0.5%)            �
�    � Strikes: [Short]/[Long] (30pt width)                    �
�    � Expected Credit: �[Amount]                              �
�---------------------------------------------------------------�
� ?? PUT SPREAD TRIGGER: ES below $[Price] (-0.5%)             �
�    � Strikes: [Short]/[Long] (30pt width)                    �
�    � Expected Credit: �[Amount]                              �
�---------------------------------------------------------------�
� ?? IRON CONDOR ZONE: ES between $[Low] and $[High]           �
�    � Combined Credit: �[Amount]                              �
+---------------------------------------------------------------+

? COUNTDOWN: [Minutes] minutes until 10:30 AM execution
Pattern Analysis with Phase-Specific Strikes:
+---------------------------------------------------------------+
�     PATTERN QUALITY ANALYSIS - PHASE [X] TICKERS              �
+---------------------------------------------------------------+

?? EXCELLENT SETUPS ([Count]):
[Phase-appropriate tickers with specific strikes and credits]

?? GOOD SETUPS ([Count]):
[Tickers meeting partial criteria]

?? AVOID ([Count]):
[Tickers on Tom's Never Trade List - PDF Page 6-7]

? NO DATA ([Count]):
[Tickers requiring searches]

FRAMEWORK LIMITATIONS
Technical Limitations:
* Manual Search Parsing: Requires extraction from search results
* Time Zone: Assumes EST unless specified
* Data Completeness: Full analysis requires complete market data
* Weekend/Holiday: Limited functionality when markets closed
* Option Chain: Requires manual bid/ask searches (Manual mode)
* API Rate Limits: 120 requests/minute (API mode)
Operational Limitations:
* Analysis Tool Required: Cannot function without JavaScript execution
* Real-Time Data: Framework uses searched data or API feeds
* PDF Reference: Requires separate PDF document for complete rules
* Browser Environment: Dashboard requires modern browser
* Phase Progression: Must follow account value phases

TROUBLESHOOTING GUIDE
Common Issues & Solutions:
"No market data provided"
* Solution: Execute all phase-specific searches (Manual) OR check API connection
* Required: Core market data + phase-qualified tickers
* Format: Parse results into searchedData structure
"API authentication failed"
* Solution: Verify credentials are correct
* Check: Token hasn't expired
* Try: Refresh token generation
"Pattern analysis failed"
* Solution: Check data structure has required fields
* Minimum fields: currentPrice, high20d, low20d
* Verify: No undefined values in critical fields
"Dashboard shows NO DATA"
* Solution: Ensure executeFramework() completed
* Check: Browser console for errors
* Verify: window.frameworkResults exists
"Position health undefined"
* Solution: Check position format matches specification
* Format: TICKER STRATEGY (DTE, entry, P&L%)
* Example: ES LT112 (85 DTE, 6420, +5%)
"Phase not detected"
* Solution: Verify account value provided
* Check: getPhaseByAccountValue() function
* Ranges: �30k, �40k, �60k, �75k+ thresholds

TASTYTRADE API SETUP
OAuth2 Credentials (Store Securely!)
const API_CREDENTIALS = {
  CLIENT_ID: 'bfca2bd1-b3f3-4941-b542-0267812f1b2f',
  CLIENT_SECRET: '98911c87a7287ac6665fc96a9a467d54fd02f7ed',
  REFRESH_TOKEN: 'eyJhbGciOiJFZERTQSIsInR5cCI6InJ0K2p3dCIsImtpZCI6IkZqVTdUT25qVEQ2WnVySlg2cVlwWmVPbzBDQzQ5TnIzR1pUN1E4MTc0cUkiLCJqa3UiOiJodHRwczovL2ludGVyaW9yLWFwaS5hcjIudGFzdHl0cmFkZS5zeXN0ZW1zL29hdXRoL2p3a3MifQ.eyJpc3MiOiJodHRwczovL2FwaS50YXN0eXRyYWRlLmNvbSIsInN1YiI6IlUyYTUyMWEwZS0zZmNmLTQzMjgtOGI5NS02MjA1ZDY4ODUwOGUiLCJpYXQiOjE3NTY0MTE3NzcsImF1ZCI6ImJmY2EyYmQxLWIzZjMtNDk0MS1iNTQyLTAyNjc4MTJmMWIyZiIsImdyYW50X2lkIjoiRzRmMzdmMTZjLWNlYTktNDhlYi05N2FiLTA1YzI0YjdiMDQ2OCIsInNjb3BlIjoicmVhZCB0cmFkZSBvcGVuaWQifQ.bA7Mt0YbQj5aCptb3BlxD67YnzdlWysWzqGYbNChCTMV1VfmRxsQMQ7yGMcrv28izZuIihzC7_-tWKkLhxZTAw'
};

// Default to PRODUCTION environment
const CURRENT_ENV = ENVIRONMENTS.PRODUCTION;
Environments
const ENVIRONMENTS = {
  SANDBOX: {
    API_BASE: 'https://api.cert.tastyworks.com',
    STREAMER: 'wss://streamer.cert.tastyworks.com',
    DXLINK: 'wss://tasty-openapi-ws.dxfeed.com/realtime'
  },
  PRODUCTION: {
    API_BASE: 'https://api.tastyworks.com',
    STREAMER: 'wss://streamer.tastyworks.com',
    DXLINK: 'wss://tasty-openapi-ws.dxfeed.com/realtime'
  }
};

API AUTHENTICATION
Token Manager Class
class TokenManager {
  constructor(refreshToken, clientSecret) {
    this.refreshToken = refreshToken;
    this.clientSecret = clientSecret;
    this.accessToken = null;
    this.tokenExpiry = null;
  }
  
  async getValidToken() {
    const now = Date.now();
    if (!this.accessToken || now >= this.tokenExpiry) {
      this.accessToken = await this.generateAccessToken();
      this.tokenExpiry = now + (14 * 60 * 1000); // Refresh 1 minute early
    }
    return this.accessToken;
  }
  
  async generateAccessToken() {
    const env = CURRENT_ENV || ENVIRONMENTS.PRODUCTION;
    const response = await fetch(`${env.API_BASE}/oauth/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'TomKingFramework/1.0'
      },
      body: JSON.stringify({
        grant_type: 'refresh_token',
        refresh_token: this.refreshToken,
        client_secret: this.clientSecret
      })
    });
    
    const data = await response.json();
    return data.access_token;
  }
}

API ERROR HANDLING & FALLBACK MECHANISMS
Complete error handling system for robust API operation with automatic fallback to manual mode.

class APIFailureHandler {
  constructor() {
    this.failureCount = 0;
    this.lastFailure = null;
    this.fallbackMode = false;
    this.retryDelays = [1000, 5000, 15000, 30000]; // Progressive backoff
  }
  
  async handleFailure(error, context) {
    this.failureCount++;
    this.lastFailure = Date.now();
    
    console.error(`API Failure #${this.failureCount}:`, {
      context,
      error: error.message,
      code: error.code,
      time: new Date().toISOString()
    });
    
    switch(error.code) {
      case 401: // Authentication failure
        return this.handleAuthFailure();
      case 429: // Rate limited
        return this.handleRateLimit();
      case 500: // Server error
      case 502: // Bad gateway
      case 503: // Service unavailable
        return this.handleServerError();
      case 'ENOTFOUND':
      case 'ETIMEDOUT':
      case 'ECONNREFUSED':
        return this.handleNetworkError();
      default:
        return this.handleUnknownError(error);
    }
  }
  
  async handleAuthFailure() {
    return {
      action: 'SWITCH_TO_MANUAL',
      message: 'Authentication failed - switching to manual mode',
      instructions: 'Please re-enter credentials or use manual data entry'
    };
  }
  
  async handleRateLimit() {
    const waitTime = 60000; // 1 minute
    console.log(`Rate limited - waiting ${waitTime/1000} seconds`);
    await new Promise(r => setTimeout(r, waitTime));
    return { action: 'RETRY' };
  }
  
  async handleServerError() {
    if (this.failureCount >= 3) {
      this.fallbackMode = true;
      return {
        action: 'EMERGENCY_MANUAL_MODE',
        message: 'TastyTrade API unavailable - emergency manual mode activated',
        instructions: 'Use manual data entry until service restored'
      };
    }
    const delay = this.retryDelays[Math.min(this.failureCount - 1, 3)];
    await new Promise(r => setTimeout(r, delay));
    return { action: 'RETRY' };
  }
  
  async handleNetworkError() {
    const delay = this.retryDelays[Math.min(this.failureCount - 1, 3)];
    console.log(`Network error - retrying in ${delay/1000} seconds`);
    await new Promise(r => setTimeout(r, delay));
    return { action: 'RETRY_WITH_BACKOFF' };
  }
  
  async handleUnknownError(error) {
    console.error('Unknown error:', error);
    if (this.failureCount >= 5) {
      return {
        action: 'SWITCH_TO_MANUAL',
        message: 'Multiple failures detected - switching to manual mode'
      };
    }
    return { action: 'LOG_AND_CONTINUE' };
  }
  
  reset() {
    this.failureCount = 0;
    this.lastFailure = null;
    this.fallbackMode = false;
  }
}

class DataSynchronizer {
  constructor() {
    this.lastSync = null;
    this.syncInterval = 5000; // 5 seconds
    this.dataCache = new Map();
    this.subscriptions = new Set();
  }
  
  async syncPositions(api) {
    try {
      const positions = await api.refreshPositions();
      this.dataCache.set('positions', positions);
      this.lastSync = Date.now();
      return positions;
    } catch (error) {
      console.error('Position sync failed:', error);
      return this.dataCache.get('positions') || [];
    }
  }
  
  async syncMarketData(api, symbols) {
    const results = {};
    for (const symbol of symbols) {
      try {
        const data = await api.getQuote(symbol);
        results[symbol] = data;
        this.dataCache.set(`quote_${symbol}`, data);
      } catch (error) {
        // Use cached data if available
        results[symbol] = this.dataCache.get(`quote_${symbol}`) || null;
      }
    }
    return results;
  }
  
  startAutoSync(api, symbols) {
    this.stopAutoSync();
    this.syncTimer = setInterval(async () => {
      await this.syncPositions(api);
      await this.syncMarketData(api, symbols);
    }, this.syncInterval);
  }
  
  stopAutoSync() {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
      this.syncTimer = null;
    }
  }
}

SYMBOL UTILITIES
Essential utilities for symbol conversion and date calculations.

// Convert OCC symbol to TastyTrade streamer format
function occToStreamerSymbol(occSymbol) {
  // OCC format: SPXW  240112C05000000
  // Streamer format: .SPXW240112C5000
  const symbol = occSymbol.substring(0, 6).trim();
  const year = '20' + occSymbol.substring(6, 8);
  const month = occSymbol.substring(8, 10);
  const day = occSymbol.substring(10, 12);
  const type = occSymbol.substring(12, 13);
  const strike = parseInt(occSymbol.substring(13)) / 1000;
  
  return `.${symbol}${year}${month}${day}${type}${strike}`;
}

// Get next Friday for expiration
function getNextFriday(date = new Date()) {
  const result = new Date(date);
  const day = result.getDay();
  const daysUntilFriday = (5 - day + 7) % 7 || 7;
  result.setDate(result.getDate() + daysUntilFriday);
  return result;
}

// Get 45 DTE expiration date
function get45DTEExpiration(date = new Date()) {
  const result = new Date(date);
  result.setDate(result.getDate() + 45);
  return getNextFriday(result);
}

// Get 90 DTE expiration date
function get90DTEExpiration(date = new Date()) {
  const result = new Date(date);
  result.setDate(result.getDate() + 90);
  return getNextFriday(result);
}

// Format expiration date for API
function formatExpiration(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

// Calculate DTE from expiration string
function calculateDTE(expiration) {
  const exp = new Date(expiration);
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  exp.setHours(0, 0, 0, 0);
  const diffTime = exp - today;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  return diffDays;
}

GREEKS MONITOR
Complete Greeks monitoring with portfolio-level calculations.

class GreeksMonitor {
  constructor(api) {
    this.api = api;
    this.positions = [];
    this.portfolioGreeks = {
      delta: 0,
      gamma: 0,
      theta: 0,
      vega: 0,
      rho: 0
    };
    this.updateInterval = 30000; // 30 seconds
    this.alerts = [];
  }
  
  async updatePositionGreeks() {
    try {
      this.positions = await this.api.refreshPositions();
      this.portfolioGreeks = this.calculatePortfolioGreeks();
      this.checkGreekAlerts();
      return this.portfolioGreeks;
    } catch (error) {
      console.error('Greeks update failed:', error);
      return this.portfolioGreeks;
    }
  }
  
  calculatePortfolioGreeks() {
    const greeks = {
      delta: 0,
      gamma: 0,
      theta: 0,
      vega: 0,
      rho: 0
    };
    
    for (const position of this.positions) {
      if (position.greeks) {
        greeks.delta += (position.greeks.delta || 0) * position.quantity;
        greeks.gamma += (position.greeks.gamma || 0) * position.quantity;
        greeks.theta += (position.greeks.theta || 0) * position.quantity;
        greeks.vega += (position.greeks.vega || 0) * position.quantity;
        greeks.rho += (position.greeks.rho || 0) * position.quantity;
      }
    }
    
    return greeks;
  }
  
  checkGreekAlerts() {
    this.alerts = [];
    
    // Delta neutral check
    if (Math.abs(this.portfolioGreeks.delta) > 100) {
      this.alerts.push({
        type: 'WARNING',
        greek: 'DELTA',
        message: `Portfolio delta ${this.portfolioGreeks.delta.toFixed(0)} - consider hedging`
      });
    }
    
    // Gamma risk check
    if (Math.abs(this.portfolioGreeks.gamma) > 50) {
      this.alerts.push({
        type: 'WARNING',
        greek: 'GAMMA',
        message: `High gamma exposure ${this.portfolioGreeks.gamma.toFixed(0)}`
      });
    }
    
    // Theta decay check
    if (this.portfolioGreeks.theta < -500) {
      this.alerts.push({
        type: 'INFO',
        greek: 'THETA',
        message: `Daily theta decay: £${Math.abs(this.portfolioGreeks.theta).toFixed(0)}`
      });
    }
    
    return this.alerts;
  }
  
  startMonitoring() {
    this.stopMonitoring();
    this.monitorTimer = setInterval(() => {
      this.updatePositionGreeks();
    }, this.updateInterval);
  }
  
  stopMonitoring() {
    if (this.monitorTimer) {
      clearInterval(this.monitorTimer);
      this.monitorTimer = null;
    }
  }
  
  getGreeksSummary() {
    return `
    📊 PORTFOLIO GREEKS:
    Delta: ${this.portfolioGreeks.delta.toFixed(1)}
    Gamma: ${this.portfolioGreeks.gamma.toFixed(1)}
    Theta: £${this.portfolioGreeks.theta.toFixed(0)}/day
    Vega: £${this.portfolioGreeks.vega.toFixed(0)}/1% IV
    Rho: £${this.portfolioGreeks.rho.toFixed(0)}/1% rate
    
    ${this.alerts.map(a => `⚠️ ${a.message}`).join('\n')}
    `;
  }
}

API DATA COLLECTION
TastyTrade API Client
class TastyTradeAPI {
  constructor(tokenManager, environment = 'production') {
    this.tokenManager = tokenManager || new TokenManager(API_CREDENTIALS.REFRESH_TOKEN, API_CREDENTIALS.CLIENT_SECRET);
    this.env = environment;
    this.baseURL = ENVIRONMENTS[environment.toUpperCase()].API_BASE;
    this.accountNumber = null;
    this.positions = [];
    this.balance = null;
    this.marketDataCache = new Map();
    this.cacheTTL = 5000; // 5 seconds
  }
  
  async initialize() {
    // Get account info
    const accounts = await this.request('/customers/me/accounts');
    this.accountNumber = accounts.data.items[0]['account-number'];
    
    // Load positions and balance
    await this.refreshPositions();
    await this.refreshBalance();
    
    return true;
  }
  
  async request(endpoint, options = {}) {
    const token = await this.tokenManager.getValidToken();
    
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${token}`,
        'User-Agent': 'TomKingFramework/1.0',
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  async refreshPositions() {
    const data = await this.request(`/accounts/${this.accountNumber}/positions`);
    this.positions = data.data.items;
    return this.positions;
  }
  
  async refreshBalance() {
    const data = await this.request(`/accounts/${this.accountNumber}/balances`);
    this.balance = {
      netLiq: parseFloat(data.data['net-liquidating-value']),
      buyingPower: parseFloat(data.data['derivative-buying-power']),
      cashBalance: parseFloat(data.data['cash-balance']),
      bpUsed: parseFloat(data.data['derivative-buying-power-used']),
      totalBP: parseFloat(data.data['derivative-buying-power']) + 
               parseFloat(data.data['derivative-buying-power-used'])
    };
    return this.balance;
  }
  
  async getQuotes(symbols) {
    const params = new URLSearchParams();
    symbols.forEach(symbol => {
      if (symbol.startsWith('/')) {
        params.append('future', symbol);
      } else if (symbol.includes(' ')) {
        params.append('equity-option', symbol);
      } else {
        params.append('equity', symbol);
      }
    });
    
    return this.request(`/market-data/by-type?${params}`);
  }
  
  async getOptionChain(symbol) {
    const chain = await this.request(`/option-chains/${symbol}/nested`);
    return this.parseOptionChain(chain);
  }
  
  parseOptionChain(chainData) {
    // Parse and structure option chain for framework use
    const expirations = chainData.data.items[0].expirations;
    return expirations.map(exp => ({
      date: exp['expiration-date'],
      dte: exp['days-to-expiration'],
      strikes: exp.strikes.map(strike => ({
        strike: strike['strike-price'],
        call: strike.call,
        put: strike.put,
        callStreamer: strike['call-streamer-symbol'],
        putStreamer: strike['put-streamer-symbol']
      }))
    }));
  }
  
  formatPositionsForFramework() {
    return this.positions.map(pos => {
      const ticker = pos.symbol.replace('/', '');
      const strategy = this.identifyStrategy(pos);
      const dte = pos['days-to-expiration'] || 0;
      const entry = pos['average-open-price'] || 0;
      const pl = pos['unrealized-day-gain-percent'] || 0;
      
      return `${ticker} ${strategy} (${dte} DTE, ${entry}, ${pl >= 0 ? '+' : ''}${pl}%)`;
    }).join(', ') || 'none';
  }
  
  identifyStrategy(position) {
    const dte = position['days-to-expiration'] || 0;
    
    if (dte === 0) return '0DTE';
    if (dte > 100 && dte < 130) return 'LT112';
    if (dte > 80 && dte < 100) return 'STRANGLE';
    if (dte > 300) return 'LEAP';
    if (position['underlying-symbol']) return 'IPMCC';
    
    return 'UNKNOWN';
  }
  
  async buildSearchedData() {
    const collector = new MarketDataCollector(this);
    return await collector.buildSearchedData();
  }
  
  async getAccountStatus() {
    await this.refreshBalance();
    const status = await this.request(`/accounts/${this.accountNumber}/trading-status`);
    
    return {
      netLiq: this.balance.netLiq,
      buyingPower: this.balance.buyingPower,
      cashBalance: this.balance.cashBalance,
      positions: this.positions,
      canTrade: status.data['can-trade']
    };
  }
  
  async getQuoteToken() {
    const response = await this.request('/api-quote-tokens');
    return {
      token: response.data.token,
      url: response.data['dxlink-url']
    };
  }
  
  async buildSearchedDataOld() {
    try {
      // Fetch all required market data
      const [esData, spyData, vixData] = await Promise.all([
        this.getQuotes(['/ES']),
        this.getQuotes(['SPY']),
        this.getQuotes(['VIX'])
      ]);
      
      // Get option chains for 0DTE analysis
      const esChain = await this.getOptionChain('ES');
      
      // Structure data for framework
      const searchedData = {
        ES: {
          currentPrice: parseFloat(esData.data.items[0].last),
          openPrice: parseFloat(esData.data.items[0].open),
          previousClose: parseFloat(esData.data.items[0]['previous-close']),
          high20d: parseFloat(esData.data.items[0]['20-day-high']),
          low20d: parseFloat(esData.data.items[0]['20-day-low']),
          iv: parseFloat(esData.data.items[0]['implied-volatility']),
          optionChain: this.extract0DTEStrikes(esChain)
        },
        SPY: {
          currentPrice: parseFloat(spyData.data.items[0].last),
          openPrice: parseFloat(spyData.data.items[0].open),
          ivRank: parseFloat(spyData.data.items[0]['iv-rank'])
        },
        VIX: {
          currentLevel: parseFloat(vixData.data.items[0].last),
          avg20d: parseFloat(vixData.data.items[0]['20-day-average'])
        },
        TIME: {
          currentEST: new Date().toLocaleTimeString('en-US', { timeZone: 'America/New_York' }),
          currentUK: new Date().toLocaleTimeString('en-GB', { timeZone: 'Europe/London' }),
          marketStatus: await this.getMarketStatus()
        }
      };
      
      return searchedData;
    } catch (error) {
      console.error('Error building searchedData:', error);
      throw error;
    }
  }
  
  extract0DTEStrikes(chain) {
    // Find today's expiration
    const today = new Date().toISOString().split('T')[0];
    const todayChain = chain.find(exp => exp.date === today);
    
    if (!todayChain) return null;
    
    // Calculate ATM and spread strikes
    const atmStrike = todayChain.strikes.find(s => 
      Math.abs(s.strike - this.currentESPrice) < 5
    );
    
    return {
      atmStrike: atmStrike?.strike,
      call30Wide: {
        shortStrike: atmStrike?.strike + 20,
        longStrike: atmStrike?.strike + 50
      },
      put30Wide: {
        shortStrike: atmStrike?.strike - 20,
        longStrike: atmStrike?.strike - 50
      }
    };
  }
  
  async getMarketStatus() {
    const status = await this.request(`/accounts/${this.accountNumber}/trading-status`);
    return status.data['is-frozen'] ? 'CLOSED' : 'OPEN';
  }
}

Market Data Collector Class
class MarketDataCollector {
  constructor(api) {
    this.api = api;
  }
  
  async buildSearchedData() {
    // Collect all required market data for Tom King strategies
    const searchedData = {
      currentTime: new Date().toISOString(),
      
      // ES data
      ES: await this.getESData(),
      
      // SPY data
      SPY: await this.getSPYData(),
      
      // VIX data
      VIX: await this.getVIXData(),
      
      // Option chains
      esOptions: await this.getESOptionChains(),
      spyOptions: await this.getSPYOptionChains()
    };
    
    return searchedData;
  }
  
  async getESData() {
    const quotes = await this.api.getQuotes(['/ES']);
    if (!quotes.data.items[0]) throw new Error('ES quote not available');
    const es = quotes.data.items[0];
    
    return {
      currentPrice: parseFloat(es.last),
      openPrice: parseFloat(es.open),
      previousClose: parseFloat(es['previous-close'] || es.close),
      dayOpen: parseFloat(es.open),
      dayHigh: parseFloat(es.high),
      dayLow: parseFloat(es.low),
      dayChange: parseFloat(es.last) - parseFloat(es.open),
      dayChangePercent: ((parseFloat(es.last) - parseFloat(es.open)) / parseFloat(es.open) * 100),
      bid: parseFloat(es.bid),
      ask: parseFloat(es.ask),
      volume: parseInt(es.volume),
      high5d: parseFloat(es['5-day-high'] || es.high),
      low5d: parseFloat(es['5-day-low'] || es.low),
      high20d: parseFloat(es['20-day-high'] || es.high),
      low20d: parseFloat(es['20-day-low'] || es.low),
      iv: parseFloat(es['implied-volatility'] || 0),
      ivRank: parseFloat(es['iv-rank'] || 0)
    };
  }
  
  async getSPYData() {
    const quotes = await this.api.getQuotes(['SPY']);
    if (!quotes.data.items[0]) throw new Error('SPY quote not available');
    const spy = quotes.data.items[0];
    
    return {
      currentPrice: parseFloat(spy.last),
      openPrice: parseFloat(spy.open),
      dayHigh: parseFloat(spy.high),
      dayLow: parseFloat(spy.low),
      dayChange: parseFloat(spy.last) - parseFloat(spy.open),
      bid: parseFloat(spy.bid),
      ask: parseFloat(spy.ask),
      volume: parseInt(spy.volume),
      ivRank: parseFloat(spy['iv-rank'] || 0)
    };
  }
  
  async getVIXData() {
    const quotes = await this.api.getQuotes(['VIX']);
    if (!quotes.data.items[0]) throw new Error('VIX quote not available');
    const vix = quotes.data.items[0];
    
    return {
      current: parseFloat(vix.last),
      dayHigh: parseFloat(vix.high),
      dayLow: parseFloat(vix.low),
      regime: this.getVIXRegime(parseFloat(vix.last))
    };
  }
  
  getVIXRegime(vixLevel) {
    if (vixLevel < 12) return { level: 1, description: 'Very Low', bpLimit: '45%' };
    if (vixLevel < 15) return { level: 2, description: 'Low', bpLimit: '60%' };
    if (vixLevel < 20) return { level: 3, description: 'Normal', bpLimit: '80%' };
    if (vixLevel < 30) return { level: 4, description: 'Elevated', bpLimit: '80%' };
    return { level: 5, description: 'High', bpLimit: '80%', warning: 'PUTS ONLY' };
  }
  
  async getESOptionChains() {
    try {
      // Get 0DTE for Friday
      const friday0DTE = await this.api.getOptionChain('/ES');
      const chains = friday0DTE.filter(exp => exp.dte <= 1);
      
      return {
        '0DTE': chains[0] ? this.processOptionChain(chains[0]) : null,
        '45DTE': this.findChainByDTE(friday0DTE, 45),
        '120DTE': this.findChainByDTE(friday0DTE, 120)
      };
    } catch (error) {
      console.error('Failed to get ES option chains:', error);
      return { '0DTE': null, '45DTE': null, '120DTE': null };
    }
  }
  
  async getSPYOptionChains() {
    try {
      const spyChain = await this.api.getOptionChain('SPY');
      
      return {
        '45DTE': this.findChainByDTE(spyChain, 45),
        '90DTE': this.findChainByDTE(spyChain, 90)
      };
    } catch (error) {
      console.error('Failed to get SPY option chains:', error);
      return { '45DTE': null, '90DTE': null };
    }
  }
  
  findChainByDTE(chains, targetDTE) {
    const closest = chains.reduce((prev, curr) => {
      return Math.abs(curr.dte - targetDTE) < Math.abs(prev.dte - targetDTE) ? curr : prev;
    });
    return this.processOptionChain(closest);
  }
  
  processOptionChain(chain) {
    if (!chain || !chain.strikes) return null;
    
    // Find key strikes
    const atmStrike = this.findATMStrike(chain.strikes);
    const put5Delta = this.find5DeltaStrike(chain.strikes, 'put');
    const call5Delta = this.find5DeltaStrike(chain.strikes, 'call');
    
    return {
      expiration: chain.date,
      dte: chain.dte,
      atmStrike,
      put5Delta,
      call5Delta,
      strikes: chain.strikes.slice(0, 20) // Limit strikes for performance
    };
  }
  
  findATMStrike(strikes) {
    // Find closest strike to current price
    return strikes[Math.floor(strikes.length / 2)];
  }
  
  find5DeltaStrike(strikes, type) {
    // Approximation - in production would use actual delta values
    if (type === 'put') {
      return strikes[Math.floor(strikes.length * 0.1)];
    } else {
      return strikes[Math.floor(strikes.length * 0.9)];
    }
  }
}

API ORDER PREPARATION (MANUAL SUBMISSION ONLY)
Order Preparation Class - Generates order details for manual review
class OrderBuilder {
  constructor(api) {
    this.api = api;
  }
  
  async build0DTESpread(direction, strikes, credit) {
    const order = {
      'time-in-force': 'Day',
      'order-type': 'Limit',
      'price': credit.toFixed(2),
      'price-effect': 'Credit',
      'legs': []
    };
    
    if (direction === 'CALL') {
      order.legs = [
        {
          'instrument-type': 'Future Option',
          'symbol': `./ESZ4 EW4Z4 241227C${strikes.short}`,
          'quantity': 1,
          'action': 'Sell to Open'
        },
        {
          'instrument-type': 'Future Option',
          'symbol': `./ESZ4 EW4Z4 241227C${strikes.long}`,
          'quantity': 1,
          'action': 'Buy to Open'
        }
      ];
    } else {
      order.legs = [
        {
          'instrument-type': 'Future Option',
          'symbol': `./ESZ4 EW4Z4 241227P${strikes.short}`,
          'quantity': 1,
          'action': 'Sell to Open'
        },
        {
          'instrument-type': 'Future Option',
          'symbol': `./ESZ4 EW4Z4 241227P${strikes.long}`,
          'quantity': 1,
          'action': 'Buy to Open'
        }
      ];
    }
    
    return order;
  }
  
  async prepareLT112Complex(putStrike, hedgeStrike) {
    // Prepare LT112 order for manual review
    const expiration = this.get120DTEExpiration();
    const orderDetails = {
      strategy: 'LT112 Complex',
      expiration: expiration,
      putStrike: putStrike,
      hedgeStrike: hedgeStrike,
      
      orderJSON: {
        'time-in-force': 'GTC',
        'order-type': 'Limit',
        'price': '0.00', // To be calculated
        'price-effect': 'Debit',
        'legs': [
          {
            'instrument-type': 'Future Option',
            'symbol': `./ESZ4 EW4Z4 ${expiration}P${putStrike}`,
            'quantity': 1,
            'action': 'Buy to Open'
          },
          {
            'instrument-type': 'Future Option',
            'symbol': `./ESZ4 EW4Z4 ${expiration}P${hedgeStrike}`,
            'quantity': 1,
            'action': 'Sell to Open'
          }
        ]
      }
    };
    
    // Calculate pricing and BP effect
    try {
      const dryRun = await this.api.request(`/accounts/${this.api.accountNumber}/orders/dry-run`, {
        method: 'POST',
        body: JSON.stringify(orderDetails.orderJSON)
      });
      
      orderDetails.bpEffect = Math.abs(dryRun.data['buying-power-effect']['change-in-buying-power']);
    } catch (error) {
      orderDetails.error = error.message;
    }
    
    orderDetails.instructions = `
    MANUAL SUBMISSION REQUIRED:
    1. Review LT112 structure
    2. Verify 120 DTE expiration
    3. Check BP requirement: £${orderDetails.bpEffect}
    4. Submit manually on first Wednesday only
    `;
    
    return orderDetails;
  }
  
  getNextFriday() {
    const now = new Date();
    const dayOfWeek = now.getDay();
    const daysUntilFriday = (5 - dayOfWeek + 7) % 7 || 7;
    const friday = new Date(now);
    friday.setDate(now.getDate() + daysUntilFriday);
    return friday.toISOString().split('T')[0].replace(/-/g, '').slice(2);
  }
  
  get120DTEExpiration() {
    const target = new Date();
    target.setDate(target.getDate() + 120);
    const month = target.getMonth();
    const year = target.getFullYear();
    const firstDay = new Date(year, month, 1);
    const firstFriday = new Date(year, month, 1 + (5 - firstDay.getDay() + 7) % 7);
    const thirdFriday = new Date(firstFriday);
    thirdFriday.setDate(firstFriday.getDate() + 14);
    return thirdFriday.toISOString().split('T')[0].replace(/-/g, '').slice(2);
  }
}

WEBSOCKET STREAMING
DXLink Streamer
class DXLinkStreamer {
  constructor(url, token) {
    this.url = url;
    this.token = token;
    this.ws = null;
    this.channel = 3;
    this.keepaliveInterval = null;
    this.callbacks = new Map();
  }
  
  async connect() {
    this.ws = new WebSocket(this.url);
    
    return new Promise((resolve, reject) => {
      this.ws.onopen = () => {
        this.setup();
        resolve();
      };
      
      this.ws.onerror = reject;
      
      this.ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      };
    });
  }
  
  setup() {
    this.send({
      type: 'SETUP',
      channel: 0,
      version: '0.1-DXF-JS/0.3.0',
      keepaliveTimeout: 60,
      acceptKeepaliveTimeout: 60
    });
  }
  
  handleMessage(data) {
    switch(data.type) {
      case 'SETUP':
        this.authorize();
        break;
        
      case 'AUTH_STATE':
        if (data.state === 'AUTHORIZED') {
          this.openChannel();
          this.startKeepalive();
        }
        break;
        
      case 'CHANNEL_OPENED':
        this.setupFeed();
        break;
        
      case 'FEED_CONFIG':
        // Ready to subscribe
        if (this.callbacks.has('ready')) {
          this.callbacks.get('ready')();
        }
        break;
        
      case 'FEED_DATA':
        if (this.callbacks.has('data')) {
          this.callbacks.get('data')(data.data);
        }
        break;
    }
  }
  
  authorize() {
    this.send({
      type: 'AUTH',
      channel: 0,
      token: this.token
    });
  }
  
  openChannel() {
    this.send({
      type: 'CHANNEL_REQUEST',
      channel: this.channel,
      service: 'FEED',
      parameters: { contract: 'AUTO' }
    });
  }
  
  setupFeed() {
    this.send({
      type: 'FEED_SETUP',
      channel: this.channel,
      acceptAggregationPeriod: 0.1,
      acceptDataFormat: 'COMPACT',
      acceptEventFields: {
        Quote: ['eventSymbol', 'bidPrice', 'askPrice', 'bidSize', 'askSize'],
        Greeks: ['eventSymbol', 'delta', 'gamma', 'theta', 'vega', 'volatility'],
        Trade: ['eventSymbol', 'price', 'size', 'time'],
        Summary: ['eventSymbol', 'openInterest', 'dayOpenPrice', 'dayHighPrice', 'dayLowPrice']
      }
    });
  }
  
  subscribe(symbols, events = ['Quote', 'Greeks']) {
    const subscriptions = [];
    symbols.forEach(symbol => {
      events.forEach(type => {
        subscriptions.push({ type, symbol });
      });
    });
    
    this.send({
      type: 'FEED_SUBSCRIPTION',
      channel: this.channel,
      reset: true,
      add: subscriptions
    });
  }
  
  onReady(callback) {
    this.callbacks.set('ready', callback);
  }
  
  onData(callback) {
    this.callbacks.set('data', callback);
  }
  
  startKeepalive() {
    this.keepaliveInterval = setInterval(() => {
      this.send({ type: 'KEEPALIVE', channel: 0 });
    }, 30000);
  }
  
  send(message) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }
  
  disconnect() {
    if (this.keepaliveInterval) {
      clearInterval(this.keepaliveInterval);
    }
    if (this.ws) {
      this.ws.close();
    }
  }
}

Account Streamer Class
class AccountStreamer {
  constructor(url, token) {
    this.ws = new WebSocket(url);
    this.token = token;
    this.heartbeatInterval = null;
    this.onOrderUpdate = null;
    this.onPositionUpdate = null;
  }
  
  connect(accountNumbers) {
    return new Promise((resolve) => {
      this.ws.onopen = () => {
        this.send({
          action: 'connect',
          value: accountNumbers,
          'auth-token': this.token,
          'request-id': 1
        });
        
        this.heartbeatInterval = setInterval(() => {
          this.send({
            action: 'heartbeat',
            'auth-token': this.token
          });
        }, 10000);
        
        resolve();
      };
      
      this.ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'Order' && this.onOrderUpdate) {
          this.onOrderUpdate(data.data);
        } else if (data.type === 'Position' && this.onPositionUpdate) {
          this.onPositionUpdate(data.data);
        }
      };
    });
  }
  
  send(data) {
    this.ws.send(JSON.stringify(data));
  }
  
  disconnect() {
    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
    this.ws.close();
  }
}

Greeks Monitor
class GreeksMonitor {
  constructor(api, dxlink) {
    this.api = api;
    this.dxlink = dxlink;
    this.greeks = new Map();
  }
  
  async subscribeToPositionGreeks() {
    const positions = await this.api.refreshPositions();
    const optionSymbols = positions
      .filter(p => p['instrument-type'].includes('Option'))
      .map(p => p['streamer-symbol']);
    
    // Subscribe via DXLink
    this.dxlink.subscribe(optionSymbols, ['Greeks', 'Quote']);
    
    // Handle updates
    this.dxlink.onData((data) => {
      if (data[0] === 'Greeks') {
        this.updateGreeks(data[1]);
      }
    });
  }
  
  updateGreeks(greeksData) {
    greeksData.forEach(greek => {
      this.greeks.set(greek.eventSymbol, {
        delta: greek.delta,
        gamma: greek.gamma,
        theta: greek.theta,
        vega: greek.vega,
        iv: greek.volatility,
        timestamp: Date.now()
      });
    });
  }
  
  getPortfolioGreeks() {
    let totalDelta = 0;
    let totalGamma = 0;
    let totalTheta = 0;
    let totalVega = 0;
    
    this.greeks.forEach((greek, symbol) => {
      const position = this.api.positions.find(p => 
        p['streamer-symbol'] === symbol
      );
      
      if (position) {
        const multiplier = position.quantity * position.multiplier;
        totalDelta += greek.delta * multiplier;
        totalGamma += greek.gamma * multiplier;
        totalTheta += greek.theta * multiplier;
        totalVega += greek.vega * multiplier;
      }
    });
    
    return { totalDelta, totalGamma, totalTheta, totalVega };
  }
}

API MODE INTEGRATION
Complete API Initialization Function
async function initializeAPIMode(clientSecret = API_CREDENTIALS.CLIENT_SECRET, refreshToken = API_CREDENTIALS.REFRESH_TOKEN, environment = 'production') {
  try {
    console.log('Initializing API mode with stored credentials...');
    
    // Initialize core components
    const tokenManager = new TokenManager(refreshToken, clientSecret);
    const api = new TastyTradeAPI(tokenManager, environment);
    
    // Authenticate and get account info
    await api.initialize();
    console.log(`Connected to account: ${api.accountNumber}`);
    
    // Get account status
    const accountStatus = await api.getAccountStatus();
    console.log(`Net Liq: £${accountStatus.netLiq.toLocaleString()}`);
    console.log(`Buying Power: £${accountStatus.buyingPower.toLocaleString()}`);
    
    // Setup real-time data streaming
    const quoteToken = await api.getQuoteToken();
    const dxlink = new DXLinkStreamer(quoteToken.url, quoteToken.token);
    await dxlink.connect();
    
    dxlink.onReady = () => {
      console.log('Real-time data streaming ready');
      // Subscribe to key symbols
      dxlink.subscribe(['SPY', '/ES', 'VIX', '/MES'], ['Quote', 'Greeks']);
    };
    
    dxlink.onData = (data) => {
      // Handle real-time updates
      console.log('Real-time update:', data);
    };
    
    // Setup account streaming for order updates
    const accessToken = await tokenManager.getValidToken();
    const accountStreamer = new AccountStreamer(
      ENVIRONMENTS[environment.toUpperCase()].STREAMER,
      accessToken
    );
    await accountStreamer.connect([api.accountNumber]);
    
    accountStreamer.onOrderUpdate = (order) => {
      console.log('Order Update:', order.status, order.id);
    };
    
    accountStreamer.onPositionUpdate = (position) => {
      console.log('Position Update:', position);
    };
    
    // Collect market data
    const collector = new MarketDataCollector(api);
    const searchedData = await collector.buildSearchedData();
    
    return {
      api,
      dxlink,
      accountStreamer,
      tokenManager,
      orderBuilder: new OrderBuilder(api),
      accountStatus,
      searchedData,
      userData: {
        accountValue: accountStatus.netLiq,
        buyingPower: accountStatus.buyingPower,
        currentPositions: api.formatPositionsForFramework(),
        phase: getPhaseByAccountValue(accountStatus.netLiq)
      }
    };
  } catch (error) {
    console.error('API initialization failed:', error);
    console.log('\\nFalling back to manual mode...');
    console.log('Please use web searches to gather required data.');
    return null;
  }
}

Quick Test Function for API Integration
async function testAPIConnection() {
  console.log('Testing API connection with stored credentials...');
  
  try {
    const apiContext = await initializeAPIMode();
    
    if (!apiContext) {
      console.log('API initialization failed. Check credentials.');
      return false;
    }
    
    console.log('\\n✅ API Test Results:');
    console.log(`   Account: ${apiContext.api.accountNumber}`);
    console.log(`   Net Liq: £${apiContext.accountStatus.netLiq.toLocaleString()}`);
    console.log(`   Buying Power: £${apiContext.accountStatus.buyingPower.toLocaleString()}`);
    console.log(`   Phase: ${apiContext.userData.phase}`);
    console.log(`   Positions: ${apiContext.userData.currentPositions}`);
    
    // Test market data collection
    console.log('\\n📊 Market Data Test:');
    console.log(`   ES Price: ${apiContext.searchedData.ES.currentPrice}`);
    console.log(`   VIX Level: ${apiContext.searchedData.VIX.current}`);
    console.log(`   VIX Regime: ${apiContext.searchedData.VIX.regime.description}`);
    
    // Cleanup
    apiContext.dxlink.disconnect();
    apiContext.accountStreamer.disconnect();
    
    console.log('\\n✅ API test completed successfully!');
    return true;
    
  } catch (error) {
    console.error('API test failed:', error);
    return false;
  }
}

Complete API Mode Execution
async function executeFrameworkWithAPI(clientSecret = API_CREDENTIALS.CLIENT_SECRET, refreshToken = API_CREDENTIALS.REFRESH_TOKEN, environment = 'production') {
  console.log('+---------------------------------------------------------------+');
  console.log('�           ?? API MODE - TASTYWORKS INTEGRATION                �');
  console.log('+---------------------------------------------------------------+');
  
  try {
    // Initialize API components
    const tokenManager = new TokenManager(refreshToken, clientSecret);
    const api = new TastyTradeAPI(tokenManager, environment);
    const orderBuilder = new OrderBuilder(api);
    
    // Authenticate and initialize
    console.log('Authenticating with TastyWorks...');
    await api.initialize();
    console.log('? Connected to TastyWorks API');
    
    // Get account data
    console.log(`Account: ${api.accountNumber}`);
    console.log(`Net Liq: �${api.balance.netLiq.toLocaleString()}`);
    console.log(`BP Used: ${((api.balance.bpUsed / api.balance.totalBP) * 100).toFixed(1)}%`);
    
    // Build framework input from API data
    const userInput = [
      `�${Math.round(api.balance.netLiq)}`,
      api.formatPositionsForFramework(),
      `${((api.balance.bpUsed / api.balance.totalBP) * 100).toFixed(1)}%`,
      new Date().toLocaleDateString('en-US', { 
        weekday: 'long', 
        month: 'numeric', 
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        timeZone: 'America/New_York'
      }) + ' EST',
      'VIX ' + (await api.getQuotes(['VIX'])).data.items[0].last,
      api.balance.netLiq > 111000 ? 'Yes' : 'No'
    ].join(' | ');
    
    console.log('');
    console.log('Framework Input:', userInput);
    
    // Build market data from API
    console.log('');
    console.log('Fetching market data...');
    const searchedData = await api.buildSearchedData();
    console.log('? Market data collected');
    
    // Initialize streaming (optional)
    console.log('');
    console.log('Setting up real-time streaming...');
    const quoteToken = await api.request('/api-quote-tokens');
    const dxlink = new DXLinkStreamer(
      ENVIRONMENTS[environment.toUpperCase()].DXLINK,
      quoteToken.data.token
    );
    await dxlink.connect();
    
    // Subscribe to position Greeks
    const greeksMonitor = new GreeksMonitor(api, dxlink);
    await greeksMonitor.subscribeToPositionGreeks();
    console.log('? Streaming connected');
    
    // Execute framework analysis
    console.log('');
    console.log('Running pattern analysis...');
    const results = executeFramework(userInput, searchedData);
    
    // Enhance results with API capabilities
    if (results.success) {
      results.apiMode = true;
      results.api = api;
      results.orderBuilder = orderBuilder;
      results.greeksMonitor = greeksMonitor;
      
      // Add order preparation for recommendations (NO AUTO SUBMISSION)
      if (results.strikeRecommendation && results.userData.dayOfWeek === 'Friday') {
        const orderDetails = await orderBuilder.prepare0DTESpread(
          results.strikeRecommendation.recommendation.includes('CALL') ? 'CALL' : 'PUT',
          results.strikeRecommendation.strikes,
          5.00 // Target credit
        );
        
        results.strikeRecommendation.orderDetails = orderDetails;
        
        console.log('');
        console.log('📋 Order prepared for MANUAL submission:');
        console.log(`   Strategy: ${orderDetails.strategy}`);
        console.log(`   Direction: ${orderDetails.direction}`);
        console.log(`   BP Impact: £${orderDetails.bpEffect}`);
        console.log('');
        console.log(orderDetails.instructions);
      }
    }
    
    return results;
    
  } catch (error) {
    console.error('? API Error:', error.message);
    console.log('');
    console.log('Falling back to manual mode...');
    return null;
  }
}
Mode Selection Helper
function selectExecutionMode(input) {
  // Check if API mode requested
  if (input.toLowerCase().includes('mode: api')) {
    const lines = input.split('\n');
    let clientSecret, refreshToken, environment = 'production';
    
    lines.forEach(line => {
      if (line.includes('Client Secret:')) {
        clientSecret = line.split(':')[1].trim();
      }
      if (line.includes('Refresh Token:')) {
        refreshToken = line.split(':')[1].trim();
      }
      if (line.includes('Environment:')) {
        environment = line.split(':')[1].trim();
      }
    });
    
    if (clientSecret && refreshToken) {
      return { mode: 'API', clientSecret, refreshToken, environment };
    }
  }
  
  // Check if test mode
  if (input.toLowerCase().includes('test mode') || input.toLowerCase().includes("pretend it's")) {
    return { mode: 'TEST' };
  }
  
  // Default to manual mode
  return { mode: 'MANUAL', input };
}

COMPLETE PATTERN ANALYSIS CODE v17.2
// ============================================
// TOM KING PATTERN ANALYSIS - COMPLETE v17.2
// With Full API Integration Support
// ============================================
// Execute this ENTIRE code block in the analysis tool

// Configuration flags
const DEBUG = false;
const PRODUCTION = true;
const API_MODE = window.apiMode || false;

// ============================================
// SECTION 1: INPUT PARSING & VALIDATION
// ============================================

function parseAndValidateInput(inputString) {
  try {
    // Check for API mode
    if (API_MODE && window.apiData) {
      return parseAPIInput(window.apiData);
    }
    
    // Check for testing override - flexible patterns
    const testPatterns = [
      /Pretend it'?s (\w+day) (\d{1,2}\/\d{1,2}) (\d{1,2}:\d{2} [AP]M)/i,
      /Pretend it'?s (\w+) (\d{1,2}\/\d{1,2}) (\d{1,2}:\d{2})/i,
      /Pretend it'?s (\w+day) (\w+ \d{1,2})/i,
      /Pretend it'?s (\w+day)/i
    ];
    
    let overrideDay = null;
    let overrideTime = null;
    let overrideDate = null;
    let testMatch = null;
    
    for (const pattern of testPatterns) {
      testMatch = inputString.match(pattern);
      if (testMatch) {
        overrideDay = testMatch[1];
        overrideDate = testMatch[2] || new Date().toLocaleDateString();
        overrideTime = testMatch[3] || '10:15 AM';
        
        // Normalize day name
        if (overrideDay.length === 3) {
          const dayMap = {
            'Mon': 'Monday', 'Tue': 'Tuesday', 'Wed': 'Wednesday',
            'Thu': 'Thursday', 'Fri': 'Friday', 'Sat': 'Saturday', 'Sun': 'Sunday'
          };
          overrideDay = dayMap[overrideDay] || overrideDay;
        }
        
        inputString = inputString.replace(testMatch[0], '').trim();
        break;
      }
    }
    
    const parts = inputString.split('|').map(p => p.trim());
    
    if (parts.length < 6) {
      throw new Error('?? BLOCKED: Missing required input fields');
    }
    
    const parsed = {
      accountValue: parseInt(parts[0].replace(/[�,]/g, '')),
      positions: parsePositions(parts[1]),
      bpUsed: parseFloat(parts[2].replace('%', '')),
      dayOfWeek: overrideDay || parts[3].split(' ')[0],
      dateStr: overrideDate || parts[3],
      timeStr: overrideTime || extractTime(parts[3]),
      vixLevel: parseFloat(parts[4].split(' ')[1]),
      portfolioMargin: parts[5]?.toLowerCase() === 'yes',
      monthPL: parts[6] ? parseInt(parts[6].replace(/[�,]/g, '')) : 0,
      testingMode: !!overrideDay,
      apiMode: API_MODE
    };
    
    // Determine phase based on account value (PDF Pages 13-24)
    parsed.phase = getPhaseByAccountValue(parsed.accountValue);
    
    // Validate critical fields
    if (!parsed.accountValue || parsed.accountValue < 30000) {
      throw new Error('?? BLOCKED: Minimum account size �30,000 (Phase 1)');
    }
    
    if (!parsed.dayOfWeek || !['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'].includes(parsed.dayOfWeek)) {
      throw new Error('?? BLOCKED: Invalid or missing day of week');
    }
    
    // Weekend check
    if (parsed.dayOfWeek === 'Saturday' || parsed.dayOfWeek === 'Sunday') {
      parsed.isWeekend = true;
    }
    
    // Critical VIX check
    if (parsed.vixLevel == null || isNaN(parsed.vixLevel)) {
      throw new Error('? ERROR: VIX data is required - cannot proceed');
    }
    
    return { success: true, error: null, data: parsed };
  } catch (error) {
    return { success: false, error: error.message, data: null };
  }
}

function parseAPIInput(apiData) {
  return {
    success: true,
    error: null,
    data: {
      accountValue: apiData.netLiq,
      positions: apiData.positions,
      bpUsed: apiData.bpUsedPercent,
      dayOfWeek: apiData.dayOfWeek,
      dateStr: apiData.dateStr,
      timeStr: apiData.timeStr,
      vixLevel: apiData.vixLevel,
      portfolioMargin: apiData.portfolioMargin,
      monthPL: apiData.monthPL || 0,
      testingMode: false,
      apiMode: true,
      phase: getPhaseByAccountValue(apiData.netLiq)
    }
  };
}

function getPhaseByAccountValue(accountValue) {
  // Based on PDF Pages 13-24
  if (accountValue < 40000) return 1; // Phase 1: �30-40k
  if (accountValue < 60000) return 2; // Phase 2: �40-60k  
  if (accountValue < 75000) return 3; // Phase 3: �60-75k
  return 4; // Phase 4: �75k+
}

function extractTime(dateStr) {
  const timeMatch = dateStr.match(/(\d{1,2}:\d{2}\s*(?:AM|PM)?)/i);
  return timeMatch ? timeMatch[1] : '10:15 AM';
}

function parsePositions(positionsStr) {
  if (positionsStr == null || 
      positionsStr.toLowerCase() === 'none' || 
      positionsStr === '0' ||
      positionsStr.toLowerCase() === 'no positions') {
    return [];
  }
  
  const positions = [];
  
  // Flexible patterns to catch variations
  const patterns = [
    // Standard format: ES LT112 (85 DTE, 6420, +5%)
    /([A-Z0-9]+)\s+([A-Z0-9]+)\s*\((\d+)\s*DTE,\s*([0-9.]+)(?:\/weekly)?,\s*([+-]?\d+)%?\)/gi,
    // Alternative: ES strangle @ 2.80 (+15%)
    /([A-Z0-9]+)\s+([a-z]+)\s*@\s*�?([0-9.]+)\s*\(([+-]?\d+)%?\)/gi,
    // Simple format: ES LT112 +5%
    /([A-Z0-9]+)\s+([A-Z0-9]+)\s*([+-]?\d+)%/gi
  ];
  
  patterns.forEach(pattern => {
    let match;
    const str = positionsStr.replace(/\s+/g, ' ');
    pattern.lastIndex = 0;
    
    while ((match = pattern.exec(str)) !== null) {
      const ticker = match[1].toUpperCase();
      const strategy = match[2].toUpperCase();
      const dte = parseInt(match[3]) || 90;
      const entry = parseFloat(match[4]) || parseFloat(match[3]) || 0;
      const plMatch = match[5] || match[4] || match[3];
      const pl = plMatch ? parseInt(plMatch.replace('%', '')) : 0;
      
      // Check for 0 DTE position (immediate exit trigger)
      if (dte === 0 && strategy !== '0DTE') {
        console.warn(`?? WARNING: ${ticker} ${strategy} at 0 DTE - requires immediate action`);
      }
      
      // Calculate entry week for LT112
      let entryWeek = null;
      if (strategy === 'LT112') {
        const daysHeld = 120 - dte;
        entryWeek = Math.ceil((daysHeld % 30) / 7) || 1;
      }
      
      const exists = positions.some(p => 
        p.ticker === ticker && p.strategy === strategy
      );
      
      if (!exists) {
        positions.push({
          ticker,
          strategy,
          dte,
          entry,
          pl,
          bpUsed: estimateBPForPosition(ticker, strategy),
          entryWeek
        });
      }
    }
  });
  
  return positions;
}

function estimateBPForPosition(ticker, strategy) {
  // References Position Sizing by Phase (PDF Pages 13-24)
  const isMicro = ticker.startsWith('M') || ticker === 'MCL' || ticker === 'MGC';
  
  const bpMap = {
    'STRANGLE': isMicro ? 2.5 : 3.5,
    'LT112': ticker === 'ES' ? 6 : ticker === 'MES' ? 3 : 4,
    'IPMCC': 8,
    '0DTE': 2,
    'LEAP': 2,
    'BUTTERFLY': 0.5,
    'RATIO': 2,
    'DIAGONAL': 1.5,
    'BOX': 0 // Self-financing
  };
  
  return bpMap[strategy.toUpperCase()] || 3;
}

// ============================================
// SECTION 2: PHASE-BASED TICKER QUALIFICATIONS
// ============================================

function getQualifiedTickersByPhase(phase, accountValue) {
  // References PDF Pages 13-24 for phase-specific products
  const tickers = {
    core: ['ES', 'SPY', 'VIX', 'DXY'],
    tradeable: []
  };
  
  switch(phase) {
    case 1: // �30-40k (PDF Pages 13-15)
      tickers.tradeable = ['MCL', 'MGC', 'GLD', 'TLT'];
      break;
      
    case 2: // �40-60k (PDF Pages 15-18)
      tickers.tradeable = ['MCL', 'MGC', 'GLD', 'TLT', 'MES', 'MNQ', 
                          'SLV', 'XOP', '6A', 'M6E'];
      break;
      
    case 3: // �60-75k (PDF Pages 18-22)
      tickers.tradeable = ['ES', 'CL', 'GC', 'LE', 'HE', 'ZC', 'ZS', 'ZW',
                          '6E', '6B', 'ZB', 'ZN', 'TLT', 'GLD', 'SLV'];
      break;
      
    case 4: // �75k+ (PDF Pages 22-24)
      tickers.tradeable = ['ES', 'NQ', 'RTY', 'CL', 'GC', 'SI', 'NG', 
                          'RB', 'HO', 'LE', 'HE', 'ZC', 'ZS', 'ZW', 
                          'KC', 'SB', 'CC', '6E', '6B', '6A', '6C', 
                          '6J', '6S', 'ZB', 'ZN', 'ZF', 'ZT', 
                          'SPY', 'QQQ', 'IWM', 'GLD', 'SLV', 'TLT', 
                          'XLE', 'XOP'];
      break;
  }
  
  return tickers;
}

function calculateMaxPositionsByPhase(strategy, phase, accountValue) {
  // References PDF Pages 36 (Position Sizing Quick Reference)
  const limits = {
    '0DTE': {
      1: 1,  // Phase 1: �30-40k
      2: 2,  // Phase 2: �40-60k
      3: 3,  // Phase 3: �60-75k
      4: 4   // Phase 4: �75k+
    },
    'LT112': {
      1: 0,  // Not available in Phase 1
      2: 4,  // MES positions
      3: 1,  // ES position
      4: 3   // Multiple ES positions
    },
    'STRANGLE': {
      1: 1,
      2: 3,
      3: 4,
      4: 5
    },
    'IPMCC': {
      1: 1,
      2: 2,
      3: 3,
      4: 4
    },
    'LEAP': {
      1: 0,
      2: 2,
      3: 3,
      4: 10  // Full ladder system
    },
    'RATIO': {
      1: 0,
      2: 2,
      3: 4,
      4: 5
    },
    'BUTTERFLY': {
      1: 0,
      2: 0,
      3: 2,
      4: 4
    },
    'DIAGONAL': {
      1: 0,
      2: 0,
      3: 2,
      4: 4
    },
    'BOX': {
      1: 0,
      2: 0,
      3: 1,
      4: 2
    }
  };
  
  return limits[strategy.toUpperCase()]?.[phase] || 0;
}

function generatePhaseAllocationTable(userData, searchedData, concentrationStatus) {
  const { accountValue, positions, bpUsed, vixLevel, dayOfWeek, phase } = userData;
  
  // Get phase-specific strategies
  const phaseStrategies = getPhaseStrategies(phase);
  const table = [];
  let totalBPAvailable = 0;
  
  phaseStrategies.forEach(strategy => {
    const maxPos = calculateMaxPositionsByPhase(strategy, phase, accountValue);
    const currentPos = positions.filter(p => p.strategy === strategy).length;
    const bpPerPos = getPhaseAdjustedBP(strategy, phase, accountValue);
    const currentBP = currentPos * bpPerPos;
    const availablePos = maxPos - currentPos;
    const canAddBP = availablePos * bpPerPos;
    
    // Determine priority based on day and phase
    let priority = getPhasePriority(strategy, dayOfWeek, phase);
    
    table.push({
      strategy,
      maxPos,
      currentPos,
      availablePos,
      bpPerPos,
      currentBP,
      canAddBP,
      priority
    });
    
    totalBPAvailable += canAddBP;
  });
  
  return { table, totalBPAvailable, phase };
}

function getPhaseStrategies(phase) {
  // Based on PDF phase descriptions
  const strategies = {
    1: ['0DTE', 'IPMCC', 'STRANGLE'],
    2: ['0DTE', 'LT112', 'STRANGLE', 'IPMCC', 'RATIO', 'LEAP'],
    3: ['0DTE', 'LT112', 'STRANGLE', 'IPMCC', 'RATIO', 'LEAP', 'BUTTERFLY', 'DIAGONAL', 'BOX'],
    4: ['0DTE', 'LT112', 'STRANGLE', 'IPMCC', 'RATIO', 'LEAP', 'BUTTERFLY', 'DIAGONAL', 'BOX']
  };
  
  return strategies[phase] || strategies[1];
}

function getPhaseAdjustedBP(strategy, phase, accountValue) {
  // Phase-specific BP requirements
  const requirements = {
    '0DTE': 2,
    'LT112': phase >= 3 && accountValue >= 55000 ? 6 : 3,
    'STRANGLE': 3,
    'IPMCC': 8,
    'LEAP': 2,
    'RATIO': 2,
    'BUTTERFLY': 0.5,
    'DIAGONAL': 1.5,
    'BOX': 0
  };
  
  return requirements[strategy] || 3;
}

function getPhasePriority(strategy, dayOfWeek, phase) {
  // Phase-specific priorities
  let priority = 'Monitor';
  
  if (strategy === '0DTE' && dayOfWeek === 'Friday') {
    priority = 'TODAY 10:30';
  } else if (strategy === 'LT112' && dayOfWeek === 'Wednesday' && phase >= 2) {
    priority = phase >= 3 ? 'WEEKLY STACK' : 'TODAY';
  } else if (strategy === 'STRANGLE' && dayOfWeek === 'Tuesday') {
    priority = 'TODAY';
  } else if (strategy === 'IPMCC' && dayOfWeek === 'Friday') {
    priority = 'Roll today';
  } else if (strategy === 'LEAP' && dayOfWeek === 'Monday' && phase >= 2) {
    priority = 'TODAY';
  } else if (strategy === 'BUTTERFLY' && dayOfWeek === 'Friday' && phase >= 3) {
    priority = 'After 0DTE';
  } else if (strategy === 'BOX' && phase >= 3) {
    priority = 'Check rates';
  }
  
  return priority;
}

// ============================================
// SECTION 3: CORRELATION GROUPS (PDF Page 12)
// ============================================

function getAllCorrelationGroups() {
  // From PDF Page 12 - Critical Foundation section
  return {
    'A1': { 
      name: 'Equity Index Futures',
      tickers: ['ES', 'MES', 'NQ', 'MNQ', 'RTY', 'M2K', 'MYM', 'YM'],
      limit: 2,
      correlation: 'HIGH (0.85+)'
    },
    'A2': { 
      name: 'Equity ETFs',
      tickers: ['SPY', 'QQQ', 'IWM', 'DIA', 'VOO', 'VTI'],
      limit: 3,
      correlation: 'HIGH (0.80+)'
    },
    'B1': { 
      name: 'Safe Haven Metals',
      tickers: ['GC', 'MGC', 'GLD', 'IAU'],
      limit: 2,
      correlation: 'TIGHT (0.95+)'
    },
    'B2': { 
      name: 'Industrial Metals',
      tickers: ['SI', 'SIL', 'SLV', 'HG', 'PL', 'PA'],
      limit: 2,
      correlation: 'MODERATE (0.60+)'
    },
    'C1': { 
      name: 'Crude Complex',
      tickers: ['CL', 'MCL', 'QM', 'XOP', 'USO', 'UCO'],
      limit: 2,
      correlation: 'VERY HIGH (0.95+)'
    },
    'C2': { 
      name: 'Natural Gas',
      tickers: ['NG', 'UNG', 'BOIL'],
      limit: 1,
      correlation: 'INDEPENDENT'
    },
    'D1': { 
      name: 'Grains',
      tickers: ['ZC', 'ZS', 'ZW', 'ZR'],
      limit: 2,
      correlation: 'WEATHER-DRIVEN'
    },
    'D2': { 
      name: 'Proteins',
      tickers: ['LE', 'HE', 'GF'],
      limit: 1,
      correlation: 'SEASONAL'
    },
    'E': { 
      name: 'Currencies',
      tickers: ['6E', '6B', '6A', '6C', '6J', '6S', 'M6E', 'M6A', 'DX', 'FXE', 'FXB'],
      limit: 2,
      correlation: 'DOLLAR-DEPENDENT'
    }
  };
}

function checkConcentrationLimits(positions, newTicker) {
  const groups = getAllCorrelationGroups();
  
  let tickerGroup = null;
  let groupData = null;
  
  for (const [groupId, data] of Object.entries(groups)) {
    if (data.tickers.includes(newTicker)) {
      tickerGroup = groupId;
      groupData = data;
      break;
    }
  }
  
  if (!tickerGroup) {
    return { allowed: true, message: 'Ticker not in correlation matrix' };
  }
  
  const currentInGroup = positions.filter(p => 
    groupData.tickers.includes(p.ticker)
  ).length;
  
  return {
    allowed: currentInGroup < groupData.limit,
    group: tickerGroup,
    groupName: groupData.name,
    current: currentInGroup,
    limit: groupData.limit,
    message: currentInGroup >= groupData.limit ? 
      `?? BLOCKED: ${groupData.name} at maximum (${groupData.limit}) per PDF Page 12` :
      `? ${groupData.name}: ${currentInGroup}/${groupData.limit} positions`
  };
}

// ============================================
// SECTION 4: VIX REGIME & BP MANAGEMENT
// ============================================

function getVIXRegimeLimits(vixLevel) {
  // References PDF Page 12 - VIX Regimes
  let regime = '';
  let min = 40;
  let max = 50;
  
  if (vixLevel < 13) {
    regime = 'LOW';
    min = 40;
    max = 50;
  } else if (vixLevel < 18) {
    regime = 'NORMAL';
    min = 60;
    max = 70;
  } else if (vixLevel < 25) {
    regime = 'ELEVATED';
    min = 75;
    max = 80;
  } else if (vixLevel < 30) {
    regime = 'HIGH';
    min = 50;
    max = 60;
  } else {
    regime = 'CRISIS';
    min = 80;
    max = 80;
  }
  
  return { 
    regime, 
    min, 
    max,
    optimal: (min + max) / 2,
    message: `VIX ${vixLevel} = ${regime} regime: Deploy ${min}-${max}% BP (PDF Page 12)`
  };
}

function checkVIXSpikeOpportunity(vixLevel, accountValue) {
  // References PDF Page 13 - VIX Spike Protocol
  if (vixLevel > 30) {
    return {
      triggered: true,
      protocol: 'VIX SPIKE OPPORTUNITY PROTOCOL (PDF Page 13)',
      actions: [
        '1. Close all profitable strangles immediately',
        '2. Close all call sales to prevent unlimited loss',
        '3. Deploy 80% of BP into 45 DTE, 20-delta puts',
        '4. Use SPX for tax efficiency',
        '5. Ladder entries over 3 days'
      ],
      expectedReturn: '15-20% in 30-45 days',
      deployment: Math.round(accountValue * 0.8),
      warning: '?? GENERATIONAL OPPORTUNITY - Act with discipline (PDF Page 13)'
    };
  }
  return { triggered: false };
}

function calculatePhaseBPOptimization(currentBP, phase, vixRegime, availableSlots, dayOfWeek) {
  // Phase-based BP targets override VIX in lower phases
  let targetRange = vixRegime;
  
  if (phase === 1) {
    targetRange = { min: 40, max: 50 };
  } else if (phase === 2) {
    targetRange = { min: 55, max: 65 };
  } else if (phase === 3) {
    targetRange = { min: 60, max: 75 };
  }
  // Phase 4 uses full VIX regime
  
  const gap = targetRange.min - currentBP;
  const plan = [];
  let projectedBP = currentBP;
  
  if (gap <= 0) {
    return {
      needed: false,
      message: `Already at ${currentBP}% - within Phase ${phase} target`,
      plan: []
    };
  }
  
  // Phase-specific priority order
  const priorities = getPhaseOptimizationPriorities(phase, dayOfWeek, availableSlots);
  
  priorities.forEach(item => {
    if (projectedBP >= targetRange.min) return;
    
    const canAdd = item.day === 'Any' || item.day === dayOfWeek;
    if (canAdd && item.slots > 0) {
      const positionsNeeded = Math.min(
        item.slots,
        Math.ceil((targetRange.min - projectedBP) / item.bp)
      );
      
      if (positionsNeeded > 0) {
        plan.push({
          strategy: item.strategy,
          positions: positionsNeeded,
          bpAdded: positionsNeeded * item.bp,
          when: item.day === dayOfWeek ? 'TODAY' : `Next ${item.day}`
        });
        projectedBP += positionsNeeded * item.bp;
      }
    }
  });
  
  return {
    needed: true,
    currentBP,
    targetMin: targetRange.min,
    targetMax: targetRange.max,
    gap,
    projectedBP,
    plan,
    phase,
    message: plan.length > 0 ? 
      `Phase ${phase}: Add ${plan.length} position types to reach ${projectedBP}% BP usage` :
      'No available slots for optimization in current phase'
  };
}

function getPhaseOptimizationPriorities(phase, dayOfWeek, availableSlots) {
  // Phase-specific optimization priorities
  const priorities = {
    1: [ // Phase 1 priorities
      { strategy: '0DTE', bp: 2, day: 'Friday', slots: availableSlots['0DTE'] || 0 },
      { strategy: 'IPMCC', bp: 8, day: 'Any', slots: availableSlots['IPMCC'] || 0 },
      { strategy: 'Strangle', bp: 3, day: 'Tuesday', slots: availableSlots['STRANGLE'] || 0 }
    ],
    2: [ // Phase 2 priorities
      { strategy: '0DTE', bp: 2, day: 'Friday', slots: availableSlots['0DTE'] || 0 },
      { strategy: 'LT112', bp: 3, day: 'Wednesday', slots: availableSlots['LT112'] || 0 },
      { strategy: 'Strangle', bp: 3, day: 'Any', slots: availableSlots['STRANGLE'] || 0 },
      { strategy: 'Ratio', bp: 2, day: 'Tuesday', slots: availableSlots['RATIO'] || 0 },
      { strategy: 'LEAP', bp: 2, day: 'Monday', slots: availableSlots['LEAP'] || 0 }
    ],
    3: [ // Phase 3 priorities
      { strategy: '0DTE', bp: 2, day: 'Friday', slots: availableSlots['0DTE'] || 0 },
      { strategy: 'LT112', bp: 6, day: 'Wednesday', slots: availableSlots['LT112'] || 0 },
      { strategy: 'Butterfly', bp: 0.5, day: 'Friday', slots: availableSlots['BUTTERFLY'] || 0 },
      { strategy: 'Box', bp: 0, day: 'Any', slots: availableSlots['BOX'] || 0 },
      { strategy: 'Diagonal', bp: 1.5, day: 'Any', slots: availableSlots['DIAGONAL'] || 0 }
    ],
    4: [ // Phase 4 - all strategies
      { strategy: '0DTE', bp: 2, day: 'Friday', slots: availableSlots['0DTE'] || 0 },
      { strategy: 'LT112', bp: 6, day: 'Wednesday', slots: availableSlots['LT112'] || 0 },
      { strategy: 'Strangle', bp: 3, day: 'Any', slots: availableSlots['STRANGLE'] || 0 },
      { strategy: 'IPMCC', bp: 8, day: 'Any', slots: availableSlots['IPMCC'] || 0 },
      { strategy: 'LEAP', bp: 2, day: 'Monday', slots: availableSlots['LEAP'] || 0 }
    ]
  };
  
  return priorities[phase] || priorities[1];
}

// ============================================
// SECTION 5: POSITION HEALTH ANALYSIS
// ============================================

function getPDFExitTarget(strategy, targetType) {
  // References PDF Pages 9-10 - Management Protocols by DTE
  const pdfTargets = {
    'STRANGLE': { 
      profit: 50,
      dte: 21,
      reference: 'PDF Page 9 - 50% Rule'
    },
    'LT112': { 
      nakedProfit: 90,
      manageDTE: 30,
      spreadHold: true,
      reference: 'PDF Page 26 - LT112 Specs'
    },
    'IPMCC': { 
      maxLoss: -30,
      rollDTE: 90,
      weeklyTarget: 90,
      reference: 'PDF Pages 28-31 - IPMCC Specs'
    },
    '0DTE': { 
      profit: 50,
      stopMultiple: 2,
      timeStopHour: 15,
      reference: 'PDF Page 25 - 0DTE Specs'
    },
    'LEAP': {
      profit: 30,
      avgDays: 40,
      reference: 'PDF Page 28 - LEAP Specs'
    },
    'RATIO': {
      profit: 50,
      defenseDelta: 25,
      reference: 'PDF Page 32 - Ratio Specs'
    },
    'BUTTERFLY': {
      holdToExpiry: true,
      reference: 'PDF Pages 31-32 - Butterfly Specs'
    },
    'DIAGONAL': {
      profit: 50,
      vixLimit: 15,
      reference: 'PDF Pages 32-33 - Diagonal Specs'
    }
  };
  
  const strategy_upper = strategy.toUpperCase();
  if (!pdfTargets[strategy_upper]) {
    return null;
  }
  
  return pdfTargets[strategy_upper][targetType] || null;
}

function analyzePositionHealth(position) {
  let score = 100;
  let action = 'HOLD';
  let exitTrigger = false;
  
  // Check for 0 DTE emergency
  if (position.dte === 0 && position.strategy !== '0DTE') {
    exitTrigger = true;
    action = `? ERROR: 0 DTE - CLOSE IMMEDIATELY`;
    score = 0;
    return { score, action, exitTrigger };
  }
  
  try {
    switch(position.strategy.toUpperCase()) {
      case 'STRANGLE':
        const strangleProfit = getPDFExitTarget('STRANGLE', 'profit');
        const strangleDTE = getPDFExitTarget('STRANGLE', 'dte');
        const strangleRef = getPDFExitTarget('STRANGLE', 'reference');
        
        if (position.pl >= strangleProfit) {
          exitTrigger = true;
          action = `EXIT - ${strangleProfit}% TARGET (${strangleRef})`;
        } else if (position.dte <= strangleDTE) {
          exitTrigger = true;
          action = `EXIT - ${strangleDTE} DTE RULE (${strangleRef})`;
        } else if (position.pl >= 30 && position.dte <= 45) {
          action = `CONSIDER - Near profit zone`;
        }
        score = Math.max(0, 100 - (90 - position.dte) - (strangleProfit - position.pl));
        break;
        
      case 'LT112':
        const nakedTarget = getPDFExitTarget('LT112', 'nakedProfit');
        const manageDTE = getPDFExitTarget('LT112', 'manageDTE');
        const lt112Ref = getPDFExitTarget('LT112', 'reference');
        
        if (position.pl >= nakedTarget && position.dte > manageDTE) {
          action = `CLOSE NAKED PUTS - ${nakedTarget}% TARGET (${lt112Ref})`;
        } else if (position.dte <= manageDTE) {
          action = `CLOSE NAKED PUTS - ${manageDTE} DTE (${lt112Ref})`;
        } else if (position.pl >= 50) {
          action = `MONITOR - Approaching target`;
        }
        score = Math.max(0, 100 - (120 - position.dte) * 0.5);
        break;
        
      case 'IPMCC':
        const maxLoss = getPDFExitTarget('IPMCC', 'maxLoss');
        const rollDTE = getPDFExitTarget('IPMCC', 'rollDTE');
        const weeklyTarget = getPDFExitTarget('IPMCC', 'weeklyTarget');
        const ipmccRef = getPDFExitTarget('IPMCC', 'reference');
        
        if (position.pl <= maxLoss) {
          exitTrigger = true;
          action = `EXIT - ${Math.abs(maxLoss)}% LEAP LOSS (${ipmccRef})`;
        } else if (position.dte <= rollDTE) {
          action = `ROLL LEAP - <${rollDTE} DTE (${ipmccRef})`;
        } else if (position.weeklyPL && position.weeklyPL >= weeklyTarget) {
          action = `CLOSE WEEKLY - ${weeklyTarget}% TARGET`;
        }
        score = Math.max(0, 100 - Math.abs(position.pl));
        break;
        
      case '0DTE':
        const profitTarget = getPDFExitTarget('0DTE', 'profit');
        const stopMultiple = getPDFExitTarget('0DTE', 'stopMultiple');
        const timeStopHour = getPDFExitTarget('0DTE', 'timeStopHour');
        const odteRef = getPDFExitTarget('0DTE', 'reference');
        const hour = new Date().getHours();
        
        if (position.pl >= profitTarget) {
          exitTrigger = true;
          action = `EXIT - ${profitTarget}% TARGET (${odteRef})`;
        } else if (position.pl <= -(stopMultiple * 100)) {
          exitTrigger = true;
          action = `EXIT - ${stopMultiple}X STOP (${odteRef})`;
        } else if (hour >= timeStopHour) {
          exitTrigger = true;
          action = `EXIT - ${timeStopHour}:00 TIME STOP (${odteRef})`;
        } else if (hour >= 14) {
          action = `PREPARE - Approaching time stop`;
        }
        score = position.pl >= 0 ? 75 : 25;
        break;
        
      case 'LEAP':
        const leapProfit = getPDFExitTarget('LEAP', 'profit');
        const avgDays = getPDFExitTarget('LEAP', 'avgDays');
        const leapRef = getPDFExitTarget('LEAP', 'reference');
        
        if (position.pl >= leapProfit) {
          exitTrigger = true;
          action = `EXIT - ${leapProfit}% TARGET (${leapRef})`;
        } else if (position.daysHeld >= avgDays) {
          action = `EVALUATE - Past ${avgDays} day average`;
        }
        score = Math.max(0, 100 - (position.daysHeld / avgDays * 50));
        break;
        
      case 'RATIO':
        const ratioProfit = getPDFExitTarget('RATIO', 'profit');
        const defenseDelta = getPDFExitTarget('RATIO', 'defenseDelta');
        const ratioRef = getPDFExitTarget('RATIO', 'reference');
        
        if (position.pl >= ratioProfit) {
          exitTrigger = true;
          action = `EXIT - ${ratioProfit}% TARGET (${ratioRef})`;
        } else if (position.testDelta >= defenseDelta) {
          action = `DEFEND - Delta ${defenseDelta} reached (${ratioRef})`;
        }
        score = Math.max(0, 100 - Math.abs(position.pl) * 2);
        break;
        
      case 'BUTTERFLY':
        const butterflyRef = getPDFExitTarget('BUTTERFLY', 'reference');
        action = `HOLD TO EXPIRY (${butterflyRef})`;
        score = 50; // Neutral score for hold strategies
        break;
        
      case 'DIAGONAL':
        const diagProfit = getPDFExitTarget('DIAGONAL', 'profit');
        const vixLimit = getPDFExitTarget('DIAGONAL', 'vixLimit');
        const diagRef = getPDFExitTarget('DIAGONAL', 'reference');
        
        if (position.pl >= diagProfit) {
          exitTrigger = true;
          action = `EXIT - ${diagProfit}% TARGET (${diagRef})`;
        } else if (position.currentVIX > vixLimit) {
          exitTrigger = true;
          action = `EXIT - VIX >${vixLimit} (${diagRef})`;
        }
        score = Math.max(0, 100 - Math.abs(position.pl));
        break;
        
      default:
        action = 'MONITOR - Check PDF for rules';
    }
  } catch (error) {
    action = '? ERROR - Manual review required';
  }
  
  return { score, action, exitTrigger };
}

// ============================================
// SECTION 6: PATTERN ANALYSIS WITH STRIKES
// ============================================

function analyzePatternWithStrikes(ticker, marketData, phase) {
  try {
    if (marketData == null) {
      return {
        ticker,
        quality: '? NO MARKET DATA',
        score: 0,
        recommendation: 'AWAITING SEARCHES',
        visual: '?',
        error: 'No market data object provided'
      };
    }
    
    // Check if ticker is on Never Trade List (PDF Pages 6-7)
    const neverTradeList = ['OJ', 'LBS', 'DX', 'VX', 'NG', 'ZR', 'PA'];
    if (neverTradeList.includes(ticker)) {
      return {
        ticker,
        quality: '?? NEVER TRADE',
        score: 0,
        recommendation: 'Tom avoids this product (PDF Page 6-7)',
        visual: '??',
        error: 'On Never Trade List'
      };
    }
    
    // Special handling for NG (Natural Gas) - Phase 4 only with experience
    if (ticker === 'NG' && phase < 4) {
      return {
        ticker,
        quality: '?? REQUIRES PHASE 4',
        score: 0,
        recommendation: 'Natural Gas requires 2+ years experience',
        visual: '??',
        error: 'Not qualified for this phase'
      };
    }
    
    if (marketData[ticker] == null) {
      return {
        ticker,
        quality: '? NO DATA',
        score: 0,
        recommendation: 'SEARCH REQUIRED',
        visual: '?',
        error: `No data for ${ticker} - execute searches`
      };
    }
    
    const data = marketData[ticker];
    
    // Validate required fields exist
    const requiredFields = ['currentPrice', 'high20d', 'low20d'];
    const missingFields = requiredFields.filter(field => data[field] == null);
    
    if (missingFields.length > 0) {
      return {
        ticker,
        quality: '? INCOMPLETE DATA',
        score: 0,
        recommendation: 'PARTIAL DATA ONLY',
        visual: '?',
        error: `Missing fields: ${missingFields.join(', ')}`
      };
    }
    
    // Calculate metrics with null checks
    const range20d = data.high20d != null && data.low20d != null && data.currentPrice != null ? 
      ((data.high20d - data.low20d) / data.currentPrice) * 100 : null;
    
    const dayChange = data.currentPrice != null && data.openPrice != null ? 
      ((data.currentPrice - data.openPrice) / data.openPrice) * 100 : 0;
    
    const ivRank = data.ivRank || 0;
    const ivPercentile = data.ivPercentile || ivRank;
    
    // Get thresholds from PDF (Page 27)
    const excellentRange = 5;  // <5% range
    const excellentIV = 50;     // >50th percentile
    const goodRange = 10;       // <10% range
    const goodIV = 30;          // >30th percentile
    
    let quality = '?? POOR';
    let score = 0;
    let visual = '??';
    let specificRecommendation = null;
    
    // Pattern quality assessment
    if (range20d == null) {
      quality = '? CANNOT CALCULATE';
      visual = '?';
      score = 0;
    } else if (range20d < excellentRange && ivRank > excellentIV) {
      quality = '?? EXCELLENT';
      score = 95;
      visual = '??';
      
      // Generate specific recommendation with strikes
      if (data.optionChain && data.optionChain.put5Delta && data.optionChain.call5Delta) {
        const putBid = data.optionChain.put5DeltaBid || 'SEARCH REQUIRED';
        const callBid = data.optionChain.call5DeltaBid || 'SEARCH REQUIRED';
        const totalCredit = (putBid !== 'SEARCH REQUIRED' && callBid !== 'SEARCH REQUIRED') ?
          (putBid + callBid).toFixed(2) : 'CALCULATE';
        
        specificRecommendation = {
          type: 'STRANGLE',
          putStrike: data.optionChain.put5Delta,
          putBid: putBid,
          callStrike: data.optionChain.call5Delta,
          callBid: callBid,
          totalCredit: totalCredit,
          bpRequired: estimateBPForPosition(ticker, 'STRANGLE'),
          entry: 'ENTER NOW - Meets all criteria'
        };
      }
    } else if (range20d < goodRange && ivRank > goodIV) {
      quality = '?? GOOD';
      score = 75;
      visual = '??';
      
      // Still provide strikes but with monitoring note
      if (data.optionChain && data.optionChain.put5Delta && data.optionChain.call5Delta) {
        specificRecommendation = {
          type: 'STRANGLE',
          putStrike: data.optionChain.put5Delta,
          callStrike: data.optionChain.call5Delta,
          note: 'Monitor for improvement - near entry criteria'
        };
      }
    } else if (range20d < 15 && ivRank > 20) {
      quality = '?? FAIR';
      score = 50;
      visual = '??';
    } else {
      quality = '?? AVOID';
      score = 25;
      visual = '??';
    }
    
    // Phase-specific adjustments
    if (phase <= 2 && !['MCL', 'MGC', 'GLD', 'TLT', 'MES', 'MNQ'].includes(ticker)) {
      quality = '? NOT QUALIFIED';
      visual = '?';
      score = 0;
      recommendation = `Requires Phase ${ticker === 'ES' ? 3 : 4}`;
    }
    
    // Generate recommendation text
    let recommendation = 'WAIT';
    if (specificRecommendation) {
      if (specificRecommendation.entry) {
        recommendation = `${specificRecommendation.putStrike}P / ${specificRecommendation.callStrike}C @ �${specificRecommendation.totalCredit}`;
      } else if (specificRecommendation.note) {
        recommendation = `${specificRecommendation.putStrike}P / ${specificRecommendation.callStrike}C - ${specificRecommendation.note}`;
      }
    } else if (visual === '??') {
      recommendation = 'AVOID - Outside PDF parameters';
    } else if (visual === '?') {
      recommendation = 'INCOMPLETE - Need option chain data';
    }
    
    return {
      ticker,
      quality,
      score,
      visual,
      recommendation,
      specificRecommendation,
      phase,
      metrics: {
        currentPrice: data.currentPrice,
        dayChange: dayChange != null ? dayChange.toFixed(2) : 'N/A',
        range20d: range20d != null ? range20d.toFixed(1) : 'N/A',
        ivRank: ivRank || 'NO DATA',
        ivPercentile: ivPercentile || 'NO DATA'
      }
    };
  } catch (error) {
    return {
      ticker,
      quality: '? ERROR',
      score: 0,
      recommendation: 'ANALYSIS FAILED',
      visual: '?',
      error: error.message
    };
  }
}

// ============================================
// SECTION 7: AUGUST 2024 LESSON IMPLEMENTATION
// ============================================

function checkAugust2024Rules(positions, newPosition) {
  // Implements lessons from �308k loss (PDF Pages 7-8)
  const warnings = [];
  
  // Rule 1: Never exceed 3 positions in same correlation group
  const groups = getAllCorrelationGroups();
  for (const [groupId, data] of Object.entries(groups)) {
    const groupPositions = positions.filter(p => data.tickers.includes(p.ticker));
    if (groupPositions.length >= 3) {
      warnings.push(`?? AUGUST 2024 WARNING: ${data.name} approaching limit (Tom lost �308k with 6 correlated)`);
    }
  }
  
  // Rule 2: Check for same expiration clustering
  const expirationMap = {};
  positions.forEach(p => {
    if (!expirationMap[p.dte]) expirationMap[p.dte] = [];
    expirationMap[p.dte].push(p);
  });
  
  Object.entries(expirationMap).forEach(([dte, positions]) => {
    if (positions.length >= 3) {
      warnings.push(`?? AUGUST 2024 WARNING: ${positions.length} positions at ${dte} DTE (diversify expirations)`);
    }
  });
  
  // Rule 3: Check total directional exposure
  const bullishCount = positions.filter(p => 
    ['LT112', 'LEAP', 'IPMCC'].includes(p.strategy)
  ).length;
  
  if (bullishCount >= 4) {
    warnings.push(`?? AUGUST 2024 WARNING: ${bullishCount} bullish positions (Tom had 6 when VIX spiked)`);
  }
  
  return warnings;
}

// ============================================
// SECTION 8: CAPITAL OPTIMIZATION
// ============================================

function identifyCapitalRecycling(positions, currentTime) {
  const recyclable = [];
  let totalBPFreed = 0;
  
  positions.forEach(p => {
    let shouldRecycle = false;
    let reason = '';
    
    try {
      switch(p.strategy.toUpperCase()) {
        case 'STRANGLE':
          if (p.pl >= 50) {
            shouldRecycle = true;
            reason = '50% profit target hit (PDF Page 9)';
          } else if (p.dte <= 21) {
            shouldRecycle = true;
            reason = '21 DTE exit rule (PDF Page 9)';
          }
          break;
          
        case 'LT112':
          if (p.pl >= 90 && p.dte > 30) {
            shouldRecycle = true;
            reason = '90% naked put target (PDF Page 26)';
          } else if (p.dte <= 30) {
            shouldRecycle = true;
            reason = 'Close naked puts at 30 DTE (PDF Page 26)';
          }
          break;
          
        case '0DTE':
          if (currentTime && currentTime.hour >= 14 && currentTime.minute >= 30) {
            shouldRecycle = true;
            reason = '2:30 PM profit taking (PDF Page 25)';
          }
          break;
          
        case 'RATIO':
          if (p.pl >= 50) {
            shouldRecycle = true;
            reason = '50% profit target (PDF Page 32)';
          }
          break;
          
        case 'DIAGONAL':
          if (p.pl >= 50) {
            shouldRecycle = true;
            reason = '50% of max profit (PDF Page 33)';
          }
          break;
      }
      
      if (shouldRecycle) {
        const bpToFree = p.bpUsed || estimateBPForPosition(p.ticker, p.strategy);
        recyclable.push({
          position: `${p.ticker} ${p.strategy}`,
          reason,
          bpToFree
        });
        totalBPFreed += bpToFree;
      }
    } catch (error) {
      if (DEBUG) console.error(`Recycling analysis error for position:`, p);
    }
  });
  
  return {
    count: recyclable.length,
    positions: recyclable,
    totalBPFreed,
    redeploymentOptions: calculateRedeployment(totalBPFreed)
  };
}

function calculateRedeployment(freedBP) {
  const options = [];
  
  if (freedBP >= 8) {
    options.push('IPMCC position (8% BP)');
  }
  if (freedBP >= 6) {
    options.push('ES LT112 position (6% BP)');
  }
  if (freedBP >= 3) {
    options.push(`${Math.floor(freedBP / 3)} strangle positions (3% each)`);
  }
  if (freedBP >= 2) {
    options.push(`${Math.floor(freedBP / 2)} 0DTE or ratio positions (2% each)`);
  }
  
  return options.length > 0 ? options : ['Insufficient BP for new positions'];
}

function calculateSPANCredits(positions, portfolioMargin, accountValue) {
  if (!portfolioMargin) return { credits: [], totalSaved: 0 };
  
  // SPAN correlation pairs from PDF (Portfolio Margin discussion)
  const spanPairs = [
    // Energy complex
    { pair: ['CL', 'RB'], reduction: 30, name: 'Energy crack spread' },
    { pair: ['CL', 'HO'], reduction: 28, name: 'Crude/Heating oil' },
    { pair: ['RB', 'HO'], reduction: 25, name: 'Refined products' },
    { pair: ['CL', 'NG'], reduction: 15, name: 'Energy diversification' },
    
    // Metals
    { pair: ['GC', 'SI'], reduction: 25, name: 'Precious metals' },
    { pair: ['GC', 'HG'], reduction: 20, name: 'Gold/Copper' },
    { pair: ['SI', 'PL'], reduction: 22, name: 'Silver/Platinum' },
    
    // Equity indices
    { pair: ['ES', 'NQ'], reduction: 20, name: 'Equity indices' },
    { pair: ['ES', 'RTY'], reduction: 18, name: 'Large/Small cap' },
    { pair: ['NQ', 'RTY'], reduction: 15, name: 'Tech/Small cap' },
    
    // Agriculture
    { pair: ['ZC', 'ZS'], reduction: 15, name: 'Grain complex' },
    { pair: ['ZC', 'ZW'], reduction: 14, name: 'Corn/Wheat' },
    { pair: ['ZS', 'ZW'], reduction: 12, name: 'Soy/Wheat' },
    { pair: ['LE', 'HE'], reduction: 10, name: 'Meat complex' },
    
    // Fixed Income
    { pair: ['ZB', 'ZN'], reduction: 18, name: 'Duration spread' },
    { pair: ['ZN', 'ZF'], reduction: 15, name: 'Yield curve' },
    
    // Currencies
    { pair: ['6E', '6B'], reduction: 12, name: 'European currencies' },
    { pair: ['6A', '6C'], reduction: 10, name: 'Commodity currencies' },
    { pair: ['6J', '6S'], reduction: 8, name: 'Safe haven FX' }
  ];
  
  const credits = [];
  let totalSaved = 0;
  
  spanPairs.forEach(span => {
    const hasFirst = positions.some(p => p.ticker === span.pair[0]);
    const hasSecond = positions.some(p => p.ticker === span.pair[1]);
    
    if (hasFirst && hasSecond) {
      const saving = Math.round(accountValue * (span.reduction / 100) * 0.01);
      credits.push({
        pair: span.name,
        tickers: `${span.pair[0]}/${span.pair[1]}`,
        reduction: `${span.reduction}%`,
        bpFreed: saving,
        note: 'Portfolio Margin benefit'
      });
      totalSaved += saving;
    }
  });
  
  // Diversification bonus
  const uniqueGroups = new Set();
  positions.forEach(p => {
    const groups = getAllCorrelationGroups();
    for (const [groupId, data] of Object.entries(groups)) {
      if (data.tickers.includes(p.ticker)) {
        uniqueGroups.add(groupId);
        break;
      }
    }
  });
  
  if (uniqueGroups.size >= 4) {
    const diversificationCredit = Math.round(accountValue * 0.05 * 0.01);
    credits.push({
      pair: 'Diversification Bonus',
      tickers: `${uniqueGroups.size} groups`,
      reduction: '5%',
      bpFreed: diversificationCredit,
      note: 'Multi-group diversification'
    });
    totalSaved += diversificationCredit;
  }
  
  return { credits, totalSaved };
}

// ============================================
// SECTION 9: STRATEGY-SPECIFIC ANALYSIS
// ============================================

function analyzeWeeklyStaggering(positions, accountValue, currentDate, phase) {
  // PDF Page 26 - LT112 Stacking
  if (phase < 2) {
    return {
      product: 'N/A',
      recommendation: 'LT112 not available until Phase 2',
      note: 'Minimum �40k required'
    };
  }
  
  if (accountValue < 55000) {
    return {
      product: 'MES',
      recommendation: 'Can add multiple MES positions',
      note: 'No staggering required for MES (PDF Page 26)'
    };
  }
  
  const weekOfMonth = Math.ceil(currentDate.getDate() / 7);
  
  const existingWeeks = positions
    .filter(p => p.strategy === 'LT112')
    .map(p => p.entryWeek || 1);
  
  const staggering = {
    currentWeek: weekOfMonth,
    product: 'ES',
    weeksOpen: [1, 2, 3, 4].filter(w => !existingWeeks.includes(w)),
    sizing: {
      1: 'FULL SIZE - Primary entry',
      2: '50% SIZE - Averaging in',
      3: '50% SIZE - Final average',
      4: 'SKIP - Preserve capital'
    }[weekOfMonth],
    recommendation: 'WAIT'
  };
  
  if (staggering.weeksOpen.includes(weekOfMonth) && weekOfMonth !== 4) {
    staggering.recommendation = 'ADD POSITION';
  } else if (weekOfMonth === 4) {
    staggering.recommendation = 'SKIP THIS WEEK';
  }
  
  return staggering;
}

function calculate0DTECountdown(currentTime) {
  // PDF Page 25 - 0DTE Complete Specs
  if (currentTime == null || currentTime.dayOfWeek !== 'Friday') {
    return null;
  }
  
  if (currentTime.isWeekend) {
    return {
      timeRemaining: -1,
      message: 'MARKET CLOSED - WEEKEND',
      phase: 'CLOSED'
    };
  }
  
  const targetHour = 10;
  const targetMinute = 30;
  
  const now = currentTime.hour * 60 + currentTime.minute;
  const target = targetHour * 60 + targetMinute;
  
  if (now >= target) {
    if (currentTime.hour < 15) {
      return { 
        timeRemaining: 0, 
        message: 'EXECUTION WINDOW OPEN - ENTER NOW',
        phase: 'EXECUTE',
        status: '?? ACTIVE'
      };
    } else if (currentTime.hour < 16) {
      return {
        timeRemaining: -1,
        message: 'APPROACHING 3PM TIME STOP',
        phase: 'CLOSING',
        status: '?? MANAGE'
      };
    } else {
      return {
        timeRemaining: -1,
        message: '0DTE WINDOW CLOSED',
        phase: 'CLOSED',
        status: '?? DONE'
      };
    }
  }
  
  const minutesRemaining = target - now;
  const hours = Math.floor(minutesRemaining / 60);
  const minutes = minutesRemaining % 60;
  
  let phase = '';
  let status = '';
  
  if (currentTime.hour < 9 || (currentTime.hour === 9 && currentTime.minute < 30)) {
    phase = 'OVERNIGHT ASSESSMENT';
    status = '?? PREPARING';
  } else if (currentTime.hour === 9 && currentTime.minute >= 30) {
    phase = 'OPENING RANGE DEVELOPMENT';
    status = '?? ANALYZING';
  } else {
    phase = 'FINAL PREPARATION';
    status = '?? READY';
  }
  
  const timeStr = hours > 0 ? 
    `${hours}h ${minutes}m until 10:30 AM entry` :
    `${minutes} minutes until 10:30 AM entry`;
  
  return {
    timeRemaining: minutesRemaining,
    message: timeStr,
    phase,
    status,
    currentMarketTime: `${currentTime.hour}:${String(currentTime.minute).padStart(2, '0')} EST`
  };
}

function calculate0DTEStrikes(esPrice, percentMove, optionChainData) {
  // PDF Page 25 - Strike Selection Formula
  const movement = percentMove || 0;
  const trigger = esPrice * 0.005; // 0.5% trigger
  const callTrigger = esPrice + trigger;
  const putTrigger = esPrice - trigger;
  
  const round5 = (x) => Math.round(x / 5) * 5;
  
  const strikes = {
    currentPrice: esPrice,
    movement: `${movement > 0 ? '+' : ''}${movement.toFixed(2)}%`,
    openPrice: optionChainData?.openPrice || esPrice - (esPrice * movement / 100),
    recommendation: '',
    strikes: {},
    creditSource: 'PENDING SEARCH'
  };
  
  // Use actual option chain data if available
  if (optionChainData && optionChainData.call30Wide && optionChainData.put30Wide) {
    if (movement > 0.5) {
      strikes.recommendation = '?? CALL SPREAD (Fade the rally)';
      strikes.strikes = {
        short: optionChainData.call30Wide.shortStrike,
        long: optionChainData.call30Wide.longStrike,
        bid: optionChainData.call30Wide.bid || 'SEARCH REQUIRED',
        ask: optionChainData.call30Wide.ask || 'SEARCH REQUIRED',
        credit: optionChainData.call30Wide.credit || 'SEARCH: ES 0DTE call spread'
      };
      strikes.creditSource = 'FROM OPTION CHAIN';
    } else if (movement < -0.5) {
      strikes.recommendation = '?? PUT SPREAD (Fade the drop)';
      strikes.strikes = {
        short: optionChainData.put30Wide.shortStrike,
        long: optionChainData.put30Wide.longStrike,
        bid: optionChainData.put30Wide.bid || 'SEARCH REQUIRED',
        ask: optionChainData.put30Wide.ask || 'SEARCH REQUIRED',
        credit: optionChainData.put30Wide.credit || 'SEARCH: ES 0DTE put spread'
      };
      strikes.creditSource = 'FROM OPTION CHAIN';
    } else {
      strikes.recommendation = '?? IRON CONDOR (Range day)';
      strikes.strikes = {
        putShort: optionChainData.ironCondor?.putShort || round5(esPrice - 60),
        putLong: optionChainData.ironCondor?.putLong || round5(esPrice - 90),
        callShort: optionChainData.ironCondor?.callShort || round5(esPrice + 60),
        callLong: optionChainData.ironCondor?.callLong || round5(esPrice + 90),
        putCredit: optionChainData.ironCondor?.putCredit || 'SEARCH REQUIRED',
        callCredit: optionChainData.ironCondor?.callCredit || 'SEARCH REQUIRED',
        totalCredit: optionChainData.ironCondor?.totalCredit || 'SEARCH: ES 0DTE IC'
      };
      strikes.creditSource = optionChainData.ironCondor ? 'FROM OPTION CHAIN' : 'SEARCH REQUIRED';
    }
  } else {
    // No option chain data - indicate searches required
    if (movement > 0.5) {
      strikes.recommendation = '?? CALL SPREAD (Search for strikes)';
      strikes.strikes = {
        short: round5(esPrice + 20),
        long: round5(esPrice + 50),
        credit: 'EXECUTE SEARCH: "ES 0DTE call spread 30-wide credit"'
      };
    } else if (movement < -0.5) {
      strikes.recommendation = '?? PUT SPREAD (Search for strikes)';
      strikes.strikes = {
        short: round5(esPrice - 20),
        long: round5(esPrice - 50),
        credit: 'EXECUTE SEARCH: "ES 0DTE put spread 30-wide credit"'
      };
    } else {
      strikes.recommendation = '?? IRON CONDOR (Search for strikes)';
      strikes.strikes = {
        putShort: round5(esPrice - 60),
        putLong: round5(esPrice - 90),
        callShort: round5(esPrice + 60),
        callLong: round5(esPrice + 90),
        credit: 'EXECUTE SEARCH: "ES 0DTE iron condor credit"'
      };
    }
    strikes.creditSource = '? NO OPTION CHAIN DATA - SEARCH REQUIRED';
  }
  
  // Add trigger levels
  strikes.triggers = {
    callTrigger: round5(callTrigger),
    putTrigger: round5(putTrigger),
    neutralZone: `${round5(putTrigger)} - ${round5(callTrigger)}`
  };
  
  // Add API execution readiness
  if (API_MODE && window.orderBuilder) {
    strikes.apiReady = true;
    strikes.executable = true;
  }
  
  return strikes;
}
// ============================================
// SECTION 9B: PDF-SPECIFIED STRATEGY IMPLEMENTATIONS
// These implementations complete the framework by adding
// specific calculations from the PDF that were referenced
// but not fully implemented in previous versions
// ============================================

// --------------------------------------------
// BOX SPREAD CALCULATIONS (PDF Page 31)
// --------------------------------------------
function calculateBoxSpreadOpportunity(accountValue, currentRates, searchedData) {
  // Only available for Phase 3+ (�55k+) per PDF
  if (accountValue < 55000) {
    return {
      available: false,
      reason: 'Requires �55k+ account (Phase 3)',
      pdfReference: 'Page 19 - �55k threshold'
    };
  }
  
  // PDF Page 31: Annual Rate = ((Box Width / Price Paid) - 1) � (365 / DTE) � 100
  const evaluateBoxSpread = (width, price, dte) => {
    const annualRate = ((width / price) - 1) * (365 / dte) * 100;
    
    // PDF Page 31: Acceptable rates
    if (annualRate < 1.0) {
      return { rate: annualRate, action: 'EXECUTE MAXIMUM SIZE', quality: 'EXCELLENT' };
    } else if (annualRate < 1.5) {
      return { rate: annualRate, action: 'EXECUTE STANDARD SIZE', quality: 'GOOD' };
    } else if (annualRate < 2.0) {
      return { rate: annualRate, action: 'EXECUTE SMALL SIZE', quality: 'MARGINAL' };
    } else {
      return { rate: annualRate, action: 'SKIP - USE MARGIN', quality: 'POOR' };
    }
  };
  
  // PDF Page 31: Execution best practices
  const executionRules = {
    orderType: 'LIMIT ONLY',
    startPrice: 'Mid - 0.2%',
    increment: '0.05%',
    maxIterations: 8,
    timeRestriction: 'RTH only',
    product: 'SPX only',
    width: 500, // Standard width from PDF
    targetDTE: [365, 730] // 1-2 years from PDF
  };
  
  // Calculate potential BP freed (PDF Page 19)
  const bpFreed = Math.min(20000, accountValue * 0.25);
  const annualCost = bpFreed * 0.01; // 1% cost from PDF
  const monthlyBenefit = (bpFreed * 0.08) / 12; // 8% return on freed capital
  
  return {
    available: true,
    product: 'SPX',
    width: executionRules.width,
    evaluation: searchedData?.SPX?.boxSpreadRate ? 
      evaluateBoxSpread(500, searchedData.SPX.boxSpreadPrice, 365) :
      { action: 'SEARCH REQUIRED', query: 'SPX 365 DTE 500-point box spread price' },
    bpImpact: `Frees �${bpFreed.toLocaleString()} BP`,
    annualCost: `�${annualCost.toFixed(0)}`,
    monthlyBenefit: `�${monthlyBenefit.toFixed(0)} additional income potential`,
    executionRules,
    pdfReference: 'Pages 19, 31 - Box Spread Complete Specs'
  };
}

// --------------------------------------------
// BUTTERFLY STRIKE MATRIX (PDF Pages 31-32)
// --------------------------------------------
function calculateButterflyMatrix(esPrice, percentMove, accountValue, phase) {
  // PDF Page 19: Available at Phase 3+ (�45k+)
  if (phase < 3) {
    return {
      available: false,
      reason: `Phase ${phase} - Requires Phase 3+ for butterflies`,
      pdfReference: 'Page 19 - Phase 3 strategies'
    };
  }
  
  const butterfly = {
    product: 'SPX',
    entry: 'Friday 10:35 AM (after 0DTE)',
    width: 10, // PDF Page 31: 10 points symmetrical
    maxRisk: Math.min(400, accountValue * 0.003), // PDF Page 32: 0.3% weekly
    maxContracts: 5, // PDF Page 32: Maximum 5 butterflies
    pdfReference: 'Pages 31-32 - Butterfly Complete Specs'
  };
  
  // PDF Page 31-32: Strike Selection Matrix
  if (percentMove > 1.0) {
    // After 1% up move
    butterfly.center = Math.round((esPrice - 10) / 5) * 5;
    butterfly.type = 'PUT';
    butterfly.bias = 'Fade the rally';
    butterfly.rationale = 'After 1% up move - put butterfly (PDF Page 31)';
  } else if (percentMove < -1.0) {
    // After 1% down move
    butterfly.center = Math.round((esPrice + 10) / 5) * 5;
    butterfly.type = 'CALL';
    butterfly.bias = 'Fade the drop';
    butterfly.rationale = 'After 1% down move - call butterfly (PDF Page 31)';
  } else if (Math.abs(percentMove) > 0.5) {
    // After 0.5% move either way
    butterfly.center = Math.round(esPrice / 5) * 5;
    butterfly.type = percentMove > 0 ? 'PUT' : 'CALL';
    butterfly.bias = 'Fade the direction';
    butterfly.rationale = 'After 0.5% move - fade direction (PDF Page 32)';
  } else {
    return {
      available: false,
      reason: 'Insufficient movement for butterfly entry',
      currentMove: `${percentMove.toFixed(2)}%`,
      requirement: 'Need >0.5% move',
      pdfReference: 'Page 31 - Strike Selection Matrix'
    };
  }
  
  // Complete strike calculation
  butterfly.strikes = {
    lower: butterfly.center - butterfly.width,
    center: butterfly.center,
    upper: butterfly.center + butterfly.width
  };
  
  // Position sizing from PDF
  butterfly.contracts = Math.min(
    Math.floor(butterfly.maxRisk / 250), // Assume $250 debit
    butterfly.maxContracts
  );
  
  // Expected outcome from PDF Page 9
  butterfly.winRate = '15-20%';
  butterfly.targetReturn = '10:1 reward/risk';
  butterfly.management = 'Hold to expiration (PDF Page 32)';
  
  return butterfly;
}

// --------------------------------------------
// LEAP LADDER SYSTEM (PDF Page 28)
// --------------------------------------------
function executeLEAPLadderSystem(existingLEAPs, accountValue, phase, dayOfWeek, vixLevel) {
  // PDF Page 17: Available at Phase 2+ (�37k+)
  if (accountValue < 37000) {
    return {
      available: false,
      reason: 'Requires �37k+ (Phase 2 enhanced)',
      pdfReference: 'Page 17 - �37k threshold'
    };
  }
  
  // PDF Page 28: Only on Mondays
  if (dayOfWeek !== 'Monday') {
    return {
      available: false,
      reason: 'LEAP entries on Monday only',
      nextEntry: 'Next Monday',
      pdfReference: 'Page 28 - Monday entry rule'
    };
  }
  
  const ladder = {
    product: 'SPY',
    maxPositions: phase >= 4 ? 10 : 4, // PDF Page 28: 10 for Phase 4
    currentCount: existingLEAPs.length,
    dte: 365,
    pdfReference: 'Page 28 - LEAP Ladder Specifications'
  };
  
  // PDF Page 28: The Ladder System
  const weekOfMonth = Math.ceil(new Date().getDate() / 7);
  const deltaByWeek = [12, 13, 14, 12]; // Rotating deltas from PDF
  ladder.targetDelta = deltaByWeek[weekOfMonth - 1] || 12;
  
  // PDF Page 33: VIX optimization for weekly entry
  if (vixLevel < 15) {
    ladder.action = 'SKIP';
    ladder.reason = 'VIX <15 - Skip week (PDF Page 33)';
  } else if (vixLevel > 20) {
    ladder.action = 'DOUBLE SIZE';
    ladder.multiplier = 2;
    ladder.reason = 'VIX >20 - Double size (PDF Page 33)';
  } else {
    ladder.action = 'STANDARD ENTRY';
    ladder.multiplier = 1;
  }
  
  // Management rules from PDF Page 28
  ladder.management = {
    profitTarget: 30, // 30% from PDF
    averageHoldDays: 40,
    rollTrigger: 150, // DTE for rolling
    expectedCredit: 400, // $400 from PDF
    monthlyTarget: '�200-300'
  };
  
  // Check existing positions for profit taking
  ladder.closures = existingLEAPs.filter(p => 
    p.pl >= 30 || p.dte < 150
  ).map(p => ({
    position: p.ticker,
    reason: p.pl >= 30 ? '30% profit target' : '<150 DTE roll trigger',
    action: 'CLOSE'
  }));
  
  // Calculate if we can add new position
  if (ladder.currentCount < ladder.maxPositions && ladder.action !== 'SKIP') {
    ladder.newEntry = {
      delta: ladder.targetDelta,
      contracts: ladder.multiplier,
      strikeCalculation: 'SPY price � (1 - delta/100)',
      expectedPremium: `�${400 * ladder.multiplier}`
    };
  }
  
  return ladder;
}

// --------------------------------------------
// SEASONAL OVERLAY SYSTEM (PDF Pages 34-35)
// --------------------------------------------
function applySeasonalOverlay(currentMonth, positions, phase) {
  // Complete month-by-month overlay from PDF Pages 34-35
  const seasonalMatrix = {
    1: { // January
      actions: ['Short bonds (rate decisions)', 'Load tech for earnings'],
      avoid: ['New agricultural positions'],
      focus: 'Tax loss harvest completed',
      allocation: { equity: 0.7, bonds: -0.2, commodities: 0.3 }
    },
    2: { // February
      actions: ['Spring rally begins', 'Add equity exposure'],
      avoid: ['Safe haven reduction too early'],
      focus: 'Momentum building',
      allocation: { equity: 0.8, bonds: 0.1, commodities: 0.3 }
    },
    3: { // March
      actions: ['Quarter-end volatility prep', 'Triple witching opportunity'],
      avoid: ['Complacency'],
      focus: 'Earnings preparation',
      allocation: { equity: 0.7, bonds: 0.2, commodities: 0.3 }
    },
    4: { // April
      actions: ['Plant agriculture longs', 'Earnings volatility peak'],
      avoid: ['Index strangles'],
      focus: 'Sector rotation',
      allocation: { equity: 0.6, bonds: 0.2, commodities: 0.4 }
    },
    5: { // May
      actions: ['Sell in May defensive', 'Add gold/bond exposure'],
      avoid: ['Aggressive equity'],
      focus: 'Risk reduction',
      allocation: { equity: 0.5, bonds: 0.3, commodities: 0.4 }
    },
    6: { // June
      actions: ['Summer driving season', 'Russell rebalancing'],
      avoid: ['Low liquidity trades'],
      focus: 'Energy plays',
      allocation: { equity: 0.5, bonds: 0.3, commodities: 0.4 }
    },
    7: { // July
      actions: ['Reduce all positions', 'Preserve capital'],
      avoid: ['New initiatives'],
      focus: 'Lowest volume month',
      allocation: { equity: 0.3, bonds: 0.4, commodities: 0.2 }
    },
    8: { // August
      actions: ['Volatility returns', 'Jackson Hole prep'],
      avoid: ['Complacency'],
      focus: 'Increase strangles',
      allocation: { equity: 0.5, bonds: 0.3, commodities: 0.3 }
    },
    9: { // September
      actions: ['Maximum put selling', '0DTE opportunities'],
      avoid: ['Long equity bias'],
      focus: 'Historically worst month',
      allocation: { equity: 0.4, bonds: 0.4, commodities: 0.3 }
    },
    10: { // October
      actions: ['Buy the dip month', 'Add LEAP positions'],
      avoid: ['Panic selling'],
      focus: 'Q4 rally prep',
      allocation: { equity: 0.7, bonds: 0.2, commodities: 0.3 }
    },
    11: { // November
      actions: ['Thanksgiving rally', 'Maximum equity exposure'],
      avoid: ['Premature hedging'],
      focus: 'Year-end rally',
      allocation: { equity: 0.8, bonds: 0.1, commodities: 0.2 }
    },
    12: { // December
      actions: ['Tax loss harvesting', 'Santa rally participation'],
      avoid: ['Pin risk for butterflies'],
      focus: 'Year-end positioning',
      allocation: { equity: 0.7, bonds: 0.2, commodities: 0.2 }
    }
  };
  
  const seasonal = seasonalMatrix[currentMonth];
  if (!seasonal) return null;
  
  // Calculate position adjustments based on seasonal bias
  const adjustments = [];
  
  // Check current allocation vs seasonal targets
  const currentAllocation = calculateCurrentAllocation(positions);
  
  Object.entries(seasonal.allocation).forEach(([asset, target]) => {
    const current = currentAllocation[asset] || 0;
    const diff = target - current;
    
    if (Math.abs(diff) > 0.1) { // 10% threshold
      adjustments.push({
        asset,
        current: `${(current * 100).toFixed(0)}%`,
        target: `${(target * 100).toFixed(0)}%`,
        action: diff > 0 ? 'INCREASE' : 'DECREASE',
        amount: `${Math.abs(diff * 100).toFixed(0)}%`
      });
    }
  });
  
  return {
    month: currentMonth,
    monthName: new Date(2024, currentMonth - 1).toLocaleString('default', { month: 'long' }),
    ...seasonal,
    adjustments,
    pdfReference: 'Pages 34-35 - Seasonal Overlay Calendar'
  };
}

// --------------------------------------------
// ADVANCED 0DTE VARIATIONS (PDF Pages 4-5)
// --------------------------------------------
function calculate0DTEVariations(esPrice, movement, atr, vixLevel) {
  const variations = {
    standard: null,
    brokenWing: null,
    batman: null,
    pdfReference: 'Pages 4-5 - Weekly Iron Condor Variations'
  };
  
  // Standard Iron Condor (PDF Page 4)
  if (Math.abs(movement) <= 0.5) {
    variations.standard = {
      type: 'STANDARD IRON CONDOR',
      callShort: Math.round((esPrice + atr * 0.5) / 5) * 5,
      callLong: Math.round((esPrice + atr * 0.5 + 30) / 5) * 5,
      putShort: Math.round((esPrice - atr * 0.5) / 5) * 5,
      putLong: Math.round((esPrice - atr * 0.5 - 30) / 5) * 5,
      creditTarget: '�400-500',
      when: 'Market flat (�0.5%)'
    };
  }
  
  // Broken Wing Iron Condor - Tom's Preference (PDF Page 4)
  if (Math.abs(movement) <= 0.5) {
    const testedSide = movement > 0 ? 'put' : 'call';
    variations.brokenWing = {
      type: 'BROKEN WING IRON CONDOR',
      preference: "Tom's Preference",
      structure: {},
      creditTarget: '�400-500',
      benefit: 'Reduces risk on trending days'
    };
    
    if (testedSide === 'put') {
      // Bullish bias - wider put wing
      variations.brokenWing.structure = {
        callShort: Math.round((esPrice + atr * 0.5) / 5) * 5,
        callLong: variations.brokenWing.structure.callShort + 30,
        putShort: Math.round((esPrice - atr * 0.5) / 5) * 5,
        putLong: variations.brokenWing.structure.putShort - 50 // WIDER
      };
      variations.brokenWing.bias = 'Bullish - extra put protection';
    } else {
      // Bearish bias - wider call wing
      variations.brokenWing.structure = {
        callShort: Math.round((esPrice + atr * 0.5) / 5) * 5,
        callLong: variations.brokenWing.structure.callShort + 50, // WIDER
        putShort: Math.round((esPrice - atr * 0.5) / 5) * 5,
        putLong: variations.brokenWing.structure.putShort - 30
      };
      variations.brokenWing.bias = 'Bearish - extra call protection';
    }
  }
  
  // Batman Spread - Advanced (PDF Pages 4-5)
  if (vixLevel < 12) {
    variations.batman = {
      type: 'BATMAN SPREAD',
      warning: 'Only for experienced traders',
      requirement: 'VIX <12',
      currentVIX: vixLevel,
      structure: {
        sell: [
          { type: 'ATM Straddle', strike: Math.round(esPrice / 5) * 5, quantity: 2 }
        ],
        buy: [
          { type: 'OTM Put', strike: Math.round((esPrice - 50) / 5) * 5, quantity: 1 },
          { type: 'OTM Call', strike: Math.round((esPrice + 50) / 5) * 5, quantity: 1 }
        ]
      },
      visual: 'Risk graph looks like Batman symbol',
      risk: 'Complex management required'
    };
  } else {
    variations.batman = {
      available: false,
      reason: `VIX at ${vixLevel} - needs <12 for Batman`,
      alternative: 'Use standard or broken wing IC'
    };
  }
  
  return variations;
}

// --------------------------------------------
// ENHANCED STRANGLE POSITIONS (PDF Page 33)
// --------------------------------------------
function calculateEnhancedStrangles(ticker, standardStrangle, phase) {
  if (phase < 2) {
    return {
      available: false,
      reason: 'Enhanced strangles require Phase 2+',
      pdfReference: 'Page 33 - Enhanced Positions'
    };
  }
  
  const enhanced = {
    standard: standardStrangle,
    ratioVersion: null,
    pdfReference: 'Page 33 - Strangle Enhancements'
  };
  
  // PDF Page 33: Add ratio element
  if (standardStrangle && standardStrangle.putStrike && standardStrangle.callStrike) {
    enhanced.ratioVersion = {
      type: 'STRANGLE WITH PUT RATIO',
      structure: 'Standard strangle (1�1) + Put ratio (1�2)',
      puts: {
        long: { strike: standardStrangle.putStrike - 10, quantity: 1 },
        short: { strike: standardStrangle.putStrike, quantity: 2 }
      },
      calls: {
        short: { strike: standardStrangle.callStrike, quantity: 1 }
      },
      benefits: [
        'Reduces BP by 30%',
        'Similar profit potential',
        'Better capital efficiency'
      ],
      management: 'Close at 50% or defend at delta 25',
      bpReduction: '30% less than standard strangle'
    };
  }
  
  return enhanced;
}

// --------------------------------------------
// HELPER FUNCTIONS FOR STRATEGY IMPLEMENTATIONS
// --------------------------------------------

function calculateCurrentAllocation(positions) {
  // Helper for seasonal overlay
  const allocation = { equity: 0, bonds: 0, commodities: 0 };
  let totalBP = 0;
  
  positions.forEach(p => {
    const bp = p.bpUsed || 3;
    totalBP += bp;
    
    // Categorize by asset class
    if (['ES', 'MES', 'NQ', 'SPY', 'QQQ', 'IWM'].includes(p.ticker)) {
      allocation.equity += bp;
    } else if (['ZB', 'ZN', 'TLT', 'GLD'].includes(p.ticker)) {
      allocation.bonds += bp;
    } else {
      allocation.commodities += bp;
    }
  });
  
  // Convert to percentages
  if (totalBP > 0) {
    Object.keys(allocation).forEach(key => {
      allocation[key] = allocation[key] / totalBP;
    });
  }
  
  return allocation;
}

function calculateLEAPStrike(underlying, targetDelta, dte) {
  // Helper for LEAP ladder system
  // This would use actual option chain data in production
  // Placeholder formula: Strike = Current � (1 - delta/100)
  return {
    calculation: `${underlying} price � (1 - ${targetDelta}/100)`,
    note: 'Requires actual option chain for precise strike'
  };
}

// --------------------------------------------
// INTEGRATION FUNCTION FOR ALL STRATEGIES
// --------------------------------------------
function executeAdvancedStrategies(userData, searchedData, phase) {
  const results = {
    boxSpread: null,
    butterfly: null,
    leapLadder: null,
    seasonal: null,
    odteVariations: null,
    enhancedStrangles: null
  };
  
  // Box Spread Opportunity (Phase 3+)
  if (phase >= 3) {
    results.boxSpread = calculateBoxSpreadOpportunity(
      userData.accountValue,
      searchedData.interestRates,
      searchedData
    );
  }
  
  // Butterfly Matrix (Phase 3+, Fridays)
  if (phase >= 3 && userData.dayOfWeek === 'Friday' && searchedData.ES) {
    const percentMove = ((searchedData.ES.currentPrice - searchedData.ES.openPrice) / 
                        searchedData.ES.openPrice) * 100;
    results.butterfly = calculateButterflyMatrix(
      searchedData.ES.currentPrice,
      percentMove,
      userData.accountValue,
      phase
    );
  }
  
  // LEAP Ladder System (Phase 2+, Mondays)
  if (phase >= 2 && userData.dayOfWeek === 'Monday') {
    const existingLEAPs = userData.positions.filter(p => p.strategy === 'LEAP');
    results.leapLadder = executeLEAPLadderSystem(
      existingLEAPs,
      userData.accountValue,
      phase,
      userData.dayOfWeek,
      userData.vixLevel
    );
  }
  
  // Seasonal Overlay (All phases)
  const currentMonth = new Date().getMonth() + 1;
  results.seasonal = applySeasonalOverlay(currentMonth, userData.positions, phase);
  
  // 0DTE Variations (Fridays)
  if (userData.dayOfWeek === 'Friday' && searchedData.ES) {
    const movement = ((searchedData.ES.currentPrice - searchedData.ES.openPrice) / 
                     searchedData.ES.openPrice) * 100;
    results.odteVariations = calculate0DTEVariations(
      searchedData.ES.currentPrice,
      movement,
      searchedData.ES.atr || 45,
      userData.vixLevel
    );
  }
  
  // Enhanced Strangles (Phase 2+)
  if (phase >= 2) {
    // This would be called for each strangle opportunity
    results.enhancedStrangles = {
      available: true,
      note: 'Calculate for each strangle opportunity',
      pdfReference: 'Page 33 - Enhanced Positions'
    };
  }
  
  return results;
}

// ============================================
// EXPORT FOR FRAMEWORK INTEGRATION
// ============================================
// Add to window object for framework access
if (typeof window !== 'undefined') {
  window.advancedStrategies = {
    calculateBoxSpreadOpportunity,
    calculateButterflyMatrix,
    executeLEAPLadderSystem,
    applySeasonalOverlay,
    calculate0DTEVariations,
    calculateEnhancedStrangles,
    executeAdvancedStrategies
  };
}

console.log('? Advanced Strategy Implementations Loaded');
console.log('  - Box Spread Calculator (PDF Page 31)');
console.log('  - Butterfly Strike Matrix (PDF Pages 31-32)');
console.log('  - LEAP Ladder System (PDF Page 28)');
console.log('  - Seasonal Overlay Calendar (PDF Pages 34-35)');
console.log('  - 0DTE Variations: Broken Wing & Batman (PDF Pages 4-5)');
console.log('  - Enhanced Strangle Positions (PDF Page 33)');
console.log('');
console.log('Integration: Call executeAdvancedStrategies() in main framework');

// ============================================
// SECTION 10: SUSTAINABILITY CHECKS
// ============================================

function checkSustainability(monthPL, accountValue) {
  // PDF Pages 39-40 - P&L Expectations
  const currentDay = new Date().getDate();
  const monthlyPercent = (monthPL / accountValue) * 100;
  const projected = (monthPL / currentDay) * 30;
  const projectedPercent = (projected / accountValue) * 100;
  
  let status = 'SUSTAINABLE';
  let warning = null;
  let action = 'CONTINUE';
  
  // Tom's sustainability thresholds
  if (projectedPercent > 15) {
    status = 'DANGEROUS';
    warning = '? ERROR: >15% monthly unsustainable (PDF Page 40)';
    action = 'REDUCE ALL POSITIONS IMMEDIATELY';
  } else if (projectedPercent > 12) {
    status = 'WARNING';
    warning = '?? WARNING: Above 12% sustainability threshold';
    action = 'REDUCE POSITION SIZES';
  } else if (projectedPercent < 6) {
    status = 'UNDERPERFORMING';
    warning = '?? INFO: Below target pace';
    action = 'REVIEW EXECUTION';
  }
  
  return {
    current: monthlyPercent.toFixed(1),
    projected: projectedPercent.toFixed(1),
    target: 8,
    status,
    warning,
    action
  };
}

// ============================================
// SECTION 11: MAIN EXECUTION FRAMEWORK
// ============================================

function executeFramework(userInput, searchedData) {
  console.log('+---------------------------------------------------------------+');
  console.log('�      TOM KING FRAMEWORK v17.2 - PRODUCTION READY             �');
  console.log('+---------------------------------------------------------------+');
  
  try {
    // Step 1: Parse and validate
    const parseResult = parseAndValidateInput(userInput);
    if (!parseResult.success) {
      throw new Error(parseResult.error);
    }
    
    const userData = parseResult.data;
    console.log('? Input validated - Phase ' + userData.phase);
    
    if (userData.apiMode) {
      console.log('?? API MODE ACTIVE');
    } else if (userData.testingMode) {
      console.log('?? TEST MODE ACTIVE - Override time: ' + userData.timeStr);
    } else {
      console.log('?? MANUAL MODE ACTIVE');
    }
    
    if (userData.isWeekend) {
      console.log('?? WARNING: Market closed - Weekend');
    }
    
    // Step 2: Check if data was searched
    if (searchedData == null || Object.keys(searchedData).length === 0) {
      console.log('?? BLOCKED: No market data provided');
      console.log('');
      
      if (userData.apiMode) {
        console.log('API MODE: Data should have been automatically collected');
        console.log('Check API connection and try again');
      } else {
        console.log('MANDATORY SEARCHES - NO EXCEPTIONS:');
        console.log('1. "current time EST and UK time"');
        console.log('2. "ES futures current price opening price 5-day high low 20-day range ATR"');
        console.log('3. "SPY current price support resistance RSI 8 EMA 21 EMA"');
        console.log('4. "VIX current level 20-day average regime"');
        console.log('5. "DXY dollar index level trend"');
        console.log('');
        
        const phaseTickers = getQualifiedTickersByPhase(userData.phase, userData.accountValue);
        console.log('Phase ' + userData.phase + ' qualified tickers:');
        phaseTickers.tradeable.forEach(ticker => {
          console.log('- ' + ticker + ': price, range, IV, option chain');
        });
      }
      
      throw new Error('Cannot proceed without market data');
    }
    
    // Validate data structure matches requirements
    const dataValidation = validateSearchedData(searchedData);
    if (!dataValidation.valid) {
      console.log('?? WARNING: Incomplete market data');
      console.log(`Missing fields: ${dataValidation.missingFields.join(', ')}`);
      console.log('Proceeding with available data...');
    } else {
      console.log('? Market data complete');
    }
    
    // Get current time for various calculations
    const currentTime = extractCurrentTime(userData, searchedData);
    
    // Step 3: Analyze existing positions
    console.log('');
    console.log('ANALYZING EXISTING POSITIONS...');
    const positionHealth = userData.positions.map(p => ({
      ...p,
      ...analyzePositionHealth(p)
    }));
    
    // Check August 2024 rules
    const august2024Warnings = checkAugust2024Rules(userData.positions, null);
    if (august2024Warnings.length > 0) {
      console.log('');
      console.log('+---------------------------------------------------------------+');
      console.log('�         AUGUST 2024 CORRELATION WARNING                       �');
      console.log('+---------------------------------------------------------------+');
      august2024Warnings.forEach(warning => console.log(warning));
    }
    
    // Step 4: Get phase-qualified tickers
    const tickers = getQualifiedTickersByPhase(userData.phase, userData.accountValue);
    console.log(`Phase ${userData.phase}: Qualified for ${tickers.tradeable.length} tickers`);
    
    // Step 5: Check concentration limits
    const concentrationStatus = checkDetailedConcentration(userData.positions);
    
    // Step 6: Get tickers to search based on phase
    const tickersToSearch = getPhaseTickersToSearch(userData.phase, userData.accountValue, concentrationStatus);
    
    if (tickersToSearch.length > 0 && !userData.apiMode) {
      console.log('');
      console.log('+---------------------------------------------------------------+');
      console.log('�      PHASE ' + userData.phase + ' AUTOMATED TICKER SEARCHES                    �');
      console.log('+---------------------------------------------------------------+');
      console.log('');
      console.log('FOR EACH QUALIFIED TICKER (based on phase):');
      console.log('IF ticker not at concentration limit:');
      tickersToSearch.forEach(ticker => {
        console.log(`? ${ticker}: Searching pattern data...`);
        console.log(`  Search: "${ticker} current price 20-day high low"`);
        console.log(`  Search: "${ticker} IV rank IV percentile ATR"`);
        console.log(`  IF NO RESULTS: ? CANNOT PROCEED`);
      });
    }
    
    // Step 7: Generate phase-based allocation table
    const allocationTable = generatePhaseAllocationTable(userData, searchedData, concentrationStatus);
    
    // Step 8: Analyze patterns with phase awareness
    console.log('');
    console.log('PHASE ' + userData.phase + ' PATTERN ANALYSIS...');
    const patterns = {
      excellent: [],
      good: [],
      fair: [],
      poor: [],
      noData: []
    };
    
    tickers.tradeable.forEach(ticker => {
      const analysis = analyzePatternWithStrikes(ticker, searchedData, userData.phase);
      
      if (analysis.visual === '??') {
        patterns.excellent.push(analysis);
      } else if (analysis.visual === '??' && analysis.score >= 70) {
        patterns.good.push(analysis);
      } else if (analysis.visual === '??') {
        patterns.fair.push(analysis);
      } else if (analysis.visual === '??') {
        patterns.poor.push(analysis);
      } else if (analysis.visual === '?') {
        patterns.noData.push(ticker);
        if (DEBUG && analysis.error) {
          console.log(`  ? ${ticker}: ${analysis.error}`);
        }
      }
    });
    
    // Step 9: Calculate phase-optimized BP plan
    const vixRegime = getVIXRegimeLimits(userData.vixLevel);
    const availableSlots = {};
    allocationTable.table.forEach(row => {
      availableSlots[row.strategy] = row.availablePos;
    });
    const bpOptimization = calculatePhaseBPOptimization(
      userData.bpUsed,
      userData.phase,
      vixRegime,
      availableSlots,
      userData.dayOfWeek
    );
    
    // Step 8.5: Execute Section 9B Advanced Strategies
    console.log('');
    console.log('EXECUTING SECTION 9B ADVANCED STRATEGIES...');
    let advancedStrategies = null;
    
    if (userData.phase >= 3) {
      // Only execute for Phase 3+ accounts
      advancedStrategies = executeAdvancedStrategies(userData, searchedData);
      
      if (advancedStrategies && Object.keys(advancedStrategies).length > 0) {
        console.log('✓ Advanced strategies calculated');
        
        // Display advanced strategies summary
        if (advancedStrategies.boxSpreads && advancedStrategies.boxSpreads.length > 0) {
          console.log(`  📦 Box Spreads: ${advancedStrategies.boxSpreads.length} opportunities`);
        }
        if (advancedStrategies.butterflyMatrix && advancedStrategies.butterflyMatrix.length > 0) {
          console.log(`  🦋 Butterfly Matrix: ${advancedStrategies.butterflyMatrix.length} setups`);
        }
        if (advancedStrategies.leapLadder && advancedStrategies.leapLadder.rungs) {
          console.log(`  🪜 LEAP Ladder: ${advancedStrategies.leapLadder.rungs.length} rungs`);
        }
        if (advancedStrategies.seasonal) {
          console.log(`  📅 Seasonal: ${advancedStrategies.seasonal.patterns.join(', ')}`);
        }
      }
    } else {
      console.log('ℹ️ Advanced strategies available at Phase 3+ (£60k+)');
    }
    
    // Step 10: Capital recycling analysis
    const recycling = identifyCapitalRecycling(userData.positions, currentTime);
    
    // Step 11: SPAN margin credits (Phase 4 PM only)
    const spanCredits = calculateSPANCredits(
      userData.positions,
      userData.portfolioMargin,
      userData.accountValue
    );
    
    // Step 12: Weekly staggering analysis (Phase 2+)
    const staggering = analyzeWeeklyStaggering(
      userData.positions,
      userData.accountValue,
      currentTime.date,
      userData.phase
    );
    
    // Step 13: Friday 0DTE countdown
    const countdown = calculate0DTECountdown(currentTime);
    
    // Step 14: Check for VIX spike opportunity
    const vixOpportunity = checkVIXSpikeOpportunity(userData.vixLevel, userData.accountValue);
    
    // Step 15: 0DTE strike calculations if Friday
    let strikeRecommendation = null;
    if (userData.dayOfWeek === 'Friday' && searchedData.ES) {
      const percentMove = searchedData.ES.currentPrice && searchedData.ES.openPrice ?
        ((searchedData.ES.currentPrice - searchedData.ES.openPrice) / searchedData.ES.openPrice) * 100 : 0;
      
      strikeRecommendation = calculate0DTEStrikes(
        searchedData.ES.currentPrice, 
        percentMove,
        searchedData.ES.optionChain
      );
    }
    
    // Step 16: Check sustainability
    const sustainability = checkSustainability(userData.monthPL, userData.accountValue);
    
    // Step 17: Generate comprehensive results
    const results = {
      success: true,
      userData,
      phase: userData.phase,
      positionHealth,
      exitTriggers: positionHealth.filter(p => p.exitTrigger),
      patterns,
      concentrationStatus,
      allocationTable,
      bpOptimization,
      vixRegime,
      vixOpportunity,
      sustainability,
      recycling,
      spanCredits,
      staggering,
      countdown,
      strikeRecommendation,
      advancedStrategies,  // Section 9B strategies
      tickersToSearch,
      currentTime,
      esPrice: searchedData.ES ? searchedData.ES.currentPrice : null,
      dataCompleteness: dataValidation,
      august2024Warnings,
      apiMode: userData.apiMode,
      timestamp: new Date().toISOString()
    };
    
    // Output comprehensive analysis
    displayCompleteResults(results);
    
    // Bridge to HTML dashboard
    if (typeof window !== 'undefined') {
      window.frameworkResults = results;
      console.log('');
      console.log('+---------------------------------------------------------------+');
      console.log('�  ? Results available at window.frameworkResults              �');
      console.log('�  ?? Ready for HTML dashboard visualization                    �');
      console.log('�  ?? Phase ' + userData.phase + ' execution complete                          �');
      if (userData.apiMode) {
        console.log('�  ?? API Mode: Orders ready for submission                     �');
      }
      console.log('+---------------------------------------------------------------+');
    }
    
    return results;
    
  } catch (error) {
    console.error('');
    console.error('+---------------------------------------------------------------+');
    console.error('�  ? FRAMEWORK ERROR                                           �');
    console.error('+---------------------------------------------------------------+');
    console.error('Error:', error.message);
    console.error('');
    console.error('TROUBLESHOOTING:');
    if (userData && userData.apiMode) {
      console.error('1. Check API credentials are correct');
      console.error('2. Verify network connection');
      console.error('3. Try manual mode as fallback');
    } else {
      console.error('1. Ensure all phase-specific searches have been executed');
      console.error('2. Verify input format matches specification');
      console.error('3. Check that searchedData structure is complete');
    }
    console.error('4. Review PDF reference guide for phase rules');
    return { success: false, error: error.message, data: null };
  }
}

// Additional helper functions...

function checkDetailedConcentration(positions) {
  const groups = getAllCorrelationGroups();
  const status = {};
  
  Object.entries(groups).forEach(([groupId, groupData]) => {
    const positionsInGroup = positions.filter(p => 
      groupData.tickers.includes(p.ticker)
    );
    
    status[groupId] = {
      name: groupData.name,
      current: positionsInGroup.length,
      limit: groupData.limit,
      available: groupData.limit - positionsInGroup.length,
      positions: positionsInGroup.map(p => `${p.ticker} ${p.strategy}`),
      correlation: groupData.correlation,
      status: positionsInGroup.length >= groupData.limit ? '?? FULL' : '? OPEN'
    };
  });
  
  return status;
}

function getPhaseTickersToSearch(phase, accountValue, concentrationStatus) {
  const qualified = getQualifiedTickersByPhase(phase, accountValue);
  const toSearch = [];
  
  qualified.tradeable.forEach(ticker => {
    // Find which group this ticker belongs to
    const groups = getAllCorrelationGroups();
    for (const [groupId, data] of Object.entries(groups)) {
      if (data.tickers.includes(ticker)) {
        // Check if group has available slots
        if (concentrationStatus[groupId]?.available > 0) {
          toSearch.push(ticker);
        }
        break;
      }
    }
  });
  
  return toSearch;
}

function validateSearchedData(searchedData) {
  const validation = {
    valid: true,
    missingTickers: [],
    missingFields: [],
    warnings: []
  };
  
  // Check core required tickers
  const requiredTickers = ['ES', 'SPY', 'VIX', 'DXY'];
  requiredTickers.forEach(ticker => {
    if (searchedData[ticker] == null) {
      validation.missingTickers.push(ticker);
      validation.valid = false;
    }
  });
  
  // Validate ES fields (most critical)
  if (searchedData.ES) {
    const requiredESFields = ['currentPrice', 'openPrice', 'high20d', 'low20d'];
    const optionalESFields = ['ivRank', 'atr', 'rsi', 'ema8', 'ema21'];
    
    requiredESFields.forEach(field => {
      if (searchedData.ES[field] == null) {
        validation.missingFields.push(`ES.${field}`);
        validation.valid = false;
      }
    });
    
    optionalESFields.forEach(field => {
      if (searchedData.ES[field] == null) {
        validation.warnings.push(`ES.${field} missing - some analysis limited`);
      }
    });
  }
  
  // Validate VIX (critical for regime)
  if (searchedData.VIX) {
    if (searchedData.VIX.currentLevel == null && searchedData.VIX.current == null) {
      validation.missingFields.push('VIX.currentLevel');
      validation.valid = false;
    }
  }
  
  return validation;
}

function extractCurrentTime(userData, searchedData) {
  const currentTime = {
    dayOfWeek: userData.testingMode ? userData.dayOfWeek : userData.dayOfWeek,
    hour: 10,
    minute: 0,
    date: new Date(),
    isWeekend: userData.isWeekend || false,
    isTradingHours: false,
    marketStatus: 'UNKNOWN'
  };
  
  // Use time from searchedData if available
  if (searchedData.TIME && searchedData.TIME.currentEST) {
    const timeMatch = searchedData.TIME.currentEST.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
    if (timeMatch) {
      let hour = parseInt(timeMatch[1]);
      const minute = parseInt(timeMatch[2]);
      const period = timeMatch[3]?.toUpperCase();
      
      if (period === 'PM' && hour !== 12) hour += 12;
      if (period === 'AM' && hour === 12) hour = 0;
      
      currentTime.hour = hour;
      currentTime.minute = minute;
    }
  } else if (userData.testingMode && userData.timeStr) {
    // Use override time if in test mode
    const timeMatch = userData.timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
    if (timeMatch) {
      let hour = parseInt(timeMatch[1]);
      const minute = parseInt(timeMatch[2]);
      const period = timeMatch[3]?.toUpperCase();
      
      if (period === 'PM' && hour !== 12) hour += 12;
      if (period === 'AM' && hour === 12) hour = 0;
      
      currentTime.hour = hour;
      currentTime.minute = minute;
    }
  }
  
  // Determine market status
  if (!currentTime.isWeekend) {
    if (currentTime.hour >= 9 && currentTime.hour < 16) {
      currentTime.isTradingHours = true;
      currentTime.marketStatus = 'OPEN';
    } else if (currentTime.hour >= 4 && currentTime.hour < 9) {
      currentTime.marketStatus = 'PRE-MARKET';
    } else if (currentTime.hour >= 16 && currentTime.hour < 20) {
      currentTime.marketStatus = 'AFTER-HOURS';
    } else {
      currentTime.marketStatus = 'CLOSED';
    }
  } else {
    currentTime.marketStatus = 'CLOSED - WEEKEND';
  }
  
  return currentTime;
}

// ============================================
// SECTION 12: RESULTS DISPLAY (COMPLETE)
// ============================================

function displayCompleteResults(results) {
  const { patterns, recycling, spanCredits, staggering, countdown, vixOpportunity, strikeRecommendation, allocationTable, bpOptimization, phase, apiMode } = results;
  
  // Phase announcement
  console.log('');
  console.log('+---------------------------------------------------------------+');
  console.log('�          PHASE ' + phase + ' ANALYSIS COMPLETE                          �');
  console.log('�     Account: �' + results.userData.accountValue.toLocaleString().padEnd(10) + '                                    �');
  if (apiMode) {
    console.log('�     Mode: API (Real-time data)                                �');
  }
  console.log('+---------------------------------------------------------------+');
  
  // VIX Spike Opportunity Alert (highest priority)
  if (vixOpportunity && vixOpportunity.triggered) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�   ?????? VIX SPIKE OPPORTUNITY PROTOCOL ACTIVATED ??????     �');
    console.log('+---------------------------------------------------------------+');
    console.log(`VIX at ${results.userData.vixLevel} - GENERATIONAL OPPORTUNITY`);
    console.log(vixOpportunity.warning);
    vixOpportunity.actions.forEach(action => console.log(`  � ${action}`));
    console.log(`Deploy: �${vixOpportunity.deployment.toLocaleString()}`);
    console.log(`Expected: ${vixOpportunity.expectedReturn}`);
  }
  
  // August 2024 Warnings
  if (results.august2024Warnings && results.august2024Warnings.length > 0) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�      ??  AUGUST 2024 CORRELATION WARNINGS                     �');
    console.log('+---------------------------------------------------------------+');
    results.august2024Warnings.forEach(warning => console.log(warning));
  }
  
  // Position Allocation Table (Phase-specific)
  if (allocationTable) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�   PHASE ' + phase + ' POSITION ALLOCATION & BP OPTIMIZATION            �');
    console.log('+---------------------------------------------------------------+');
    console.log('');
    console.log('Strategy    | Max Pos | Current | Avail | BP/Pos | BP Used | Can Add | Priority');
    console.log('------------|---------|---------|-------|--------|---------|---------|----------');
    
    allocationTable.table.forEach(row => {
      const line = `${row.strategy.padEnd(11)} | ${String(row.maxPos).padEnd(7)} | ${String(row.currentPos).padEnd(7)} | ${String(row.availablePos).padEnd(5)} | ${(row.bpPerPos + '%').padEnd(6)} | ${(row.currentBP + '%').padEnd(7)} | ${(row.canAddBP + '%').padEnd(7)} | ${row.priority}`;
      console.log(line);
    });
    
    console.log('------------|---------|---------|-------|--------|---------|---------|----------');
    const totalBP = allocationTable.table.reduce((sum, row) => sum + row.currentBP, 0);
    const totalAvail = allocationTable.table.reduce((sum, row) => sum + row.canAddBP, 0);
    console.log(`TOTAL       | -       | -       | -     | -      | ${(totalBP + '%').padEnd(7)} | ${(totalAvail + '%').padEnd(7)} | -`);
    console.log('');
    
    // Phase-specific BP targets
    const phaseTargets = {
      1: '40-50%',
      2: '55-65%',
      3: '60-75%',
      4: results.vixRegime.min + '-' + results.vixRegime.max + '%'
    };
    
    console.log(`Phase ${phase} BP Target: ${phaseTargets[phase]}`);
    console.log(`Current: ${results.userData.bpUsed}% | Available: ${100 - results.userData.bpUsed}%`);
  }
  
  // BP Optimization Plan
  if (bpOptimization && bpOptimization.needed && bpOptimization.plan.length > 0) {
    console.log('');
    console.log('PHASE ' + phase + ' OPTIMIZATION PLAN TO REACH ' + bpOptimization.targetMin + '% BP:');
    bpOptimization.plan.forEach((item, index) => {
      console.log(`${index + 1}. Add ${item.positions} ${item.strategy} position${item.positions > 1 ? 's' : ''} (+${item.bpAdded}%) ${item.when}`);
    });
    console.log(`Final BP after additions: ${bpOptimization.projectedBP}% ?`);
  }
  
  // Advanced Strategies Display
  if (results.advancedStrategies && results.phase >= 3) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('|      SECTION 9B ADVANCED STRATEGIES (Phase ' + results.phase + ')                 |');
    console.log('+---------------------------------------------------------------+');
    
    // Box Spreads
    if (results.advancedStrategies.boxSpread && results.advancedStrategies.boxSpread.available !== false) {
      console.log('');
      console.log('📦 BOX SPREAD OPPORTUNITIES:');
      if (Array.isArray(results.advancedStrategies.boxSpread)) {
        results.advancedStrategies.boxSpread.forEach(box => {
          console.log(`  ${box.ticker}: ${box.width}pt box for £${box.price}`);
          console.log(`  Risk-free rate: ${box.annualRate.toFixed(2)}% - ${box.quality}`);
        });
      } else if (results.advancedStrategies.boxSpread.rate) {
        console.log(`  Annual rate: ${results.advancedStrategies.boxSpread.rate.toFixed(2)}%`);
        console.log(`  Action: ${results.advancedStrategies.boxSpread.action}`);
      }
    }
    
    // Butterfly Matrix
    if (results.advancedStrategies.butterfly && results.advancedStrategies.butterfly.length > 0) {
      console.log('');
      console.log('🦋 BUTTERFLY MATRIX:');
      const topButterflies = results.advancedStrategies.butterfly.slice(0, 3);
      topButterflies.forEach(fly => {
        console.log(`  Center: ${fly.center}, Wings: ±${fly.width}`);
        console.log(`  Max profit: £${fly.maxProfit}, Cost: £${fly.cost}`);
      });
    }
    
    // LEAP Ladder
    if (results.advancedStrategies.leapLadder && results.advancedStrategies.leapLadder.rungs) {
      console.log('');
      console.log('🪜 LEAP LADDER SYSTEM:');
      results.advancedStrategies.leapLadder.rungs.forEach((rung, i) => {
        console.log(`  Rung ${i + 1}: ${rung.expiration} at ${rung.strike} delta`);
      });
      if (results.advancedStrategies.leapLadder.nextAction) {
        console.log(`  Next: ${results.advancedStrategies.leapLadder.nextAction}`);
      }
    }
    
    // Seasonal Overlay
    if (results.advancedStrategies.seasonal && results.advancedStrategies.seasonal.patterns) {
      console.log('');
      console.log('📅 SEASONAL PATTERNS:');
      results.advancedStrategies.seasonal.patterns.forEach(pattern => {
        console.log(`  ${pattern.pattern}: ${pattern.action}`);
      });
    }
    
    // 0DTE Variations
    if (results.advancedStrategies.odteVariations) {
      console.log('');
      console.log('🎯 0DTE VARIATIONS:');
      if (results.advancedStrategies.odteVariations.brokenWing) {
        console.log(`  Broken Wing: ${results.advancedStrategies.odteVariations.brokenWing.description}`);
      }
      if (results.advancedStrategies.odteVariations.batman) {
        console.log(`  Batman: ${results.advancedStrategies.odteVariations.batman.description}`);
      }
    }
    
    // Enhanced Strangles
    if (results.advancedStrategies.enhancedStrangles && results.advancedStrategies.enhancedStrangles.length > 0) {
      console.log('');
      console.log('💎 ENHANCED STRANGLES:');
      results.advancedStrategies.enhancedStrangles.forEach(strangle => {
        console.log(`  ${strangle.ticker}: ${strangle.putStrike}P/${strangle.callStrike}C`);
        console.log(`  Credit: £${strangle.totalCredit}, Delta-neutral: ${strangle.deltaNeutral}`);
      });
    }
  }
  
  // Friday pre-market section
  if (countdown && countdown.timeRemaining != null) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�        ?? 0DTE PRE-MARKET ANALYSIS (PDF Page 25)              �');
    console.log('+---------------------------------------------------------------+');
    if (countdown.timeRemaining > 0) {
      console.log(`Phase: ${countdown.phase} ${countdown.status || ''}`);
      console.log(`? ${countdown.message}`);
      console.log(`Market Time: ${countdown.currentMarketTime || 'Unknown'}`);
    } else if (countdown.timeRemaining === 0) {
      console.log(`? ${countdown.message}`);
    } else {
      console.log(`${countdown.status} ${countdown.message}`);
    }
    
    if (strikeRecommendation && strikeRecommendation.strikes) {
      const maxContracts = phase; // Phase 1 = 1 contract, Phase 2 = 2, etc.
      console.log('');
      console.log(`ES at ${strikeRecommendation.currentPrice} (${strikeRecommendation.movement} from open)`);
      console.log(`Triggers: Call >${strikeRecommendation.triggers?.callTrigger} | Put <${strikeRecommendation.triggers?.putTrigger}`);
      console.log(`Recommendation: ${strikeRecommendation.recommendation}`);
      console.log(`Phase ${phase} allows: ${maxContracts} contract${maxContracts > 1 ? 's' : ''}`);
      
      if (strikeRecommendation.strikes.short) {
        console.log(`Strikes: ${strikeRecommendation.strikes.short}/${strikeRecommendation.strikes.long}`);
        if (strikeRecommendation.strikes.credit !== 'SEARCH REQUIRED') {
          console.log(`Credit per contract: �${strikeRecommendation.strikes.credit}`);
          console.log(`Total with ${maxContracts} contracts: �${(strikeRecommendation.strikes.credit * maxContracts).toFixed(2)}`);
        }
      }
      
      if (apiMode && strikeRecommendation.apiReady) {
        console.log('');
        console.log('?? API MODE: Order ready for submission via TastyTrade');
      }
    }
  }
  
  // Exit triggers
  if (results.exitTriggers && results.exitTriggers.length > 0) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�      ?? IMMEDIATE EXITS REQUIRED (PDF Pages 9-10)             �');
    console.log('+---------------------------------------------------------------+');
    results.exitTriggers.forEach(p => {
      console.log(`  ${p.ticker} ${p.strategy}: ${p.action}`);
    });
  }
  
  // Capital recycling
  if (recycling && recycling.count > 0) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�           ??  CAPITAL RECYCLING OPPORTUNITIES                 �');
    console.log('+---------------------------------------------------------------+');
    recycling.positions.forEach(r => {
      console.log(`  ${r.position}: ${r.reason} - Frees ${r.bpToFree}% BP`);
    });
    console.log(`  TOTAL BP TO FREE: ${recycling.totalBPFreed}%`);
    console.log(`  Redeployment: ${recycling.redeploymentOptions.join(', ')}`);
  }
  
  // Pattern opportunities with phase awareness
  if (patterns) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�     PHASE ' + phase + ' PATTERN ANALYSIS WITH SPECIFIC STRIKES         �');
    console.log('+---------------------------------------------------------------+');
    
    if (patterns.excellent && patterns.excellent.length > 0) {
      console.log(`\n?? EXCELLENT SETUPS (${patterns.excellent.length}):`);
      patterns.excellent.forEach(p => {
        const price = p.metrics?.currentPrice || 'NO PRICE';
        const range = p.metrics?.range20d || 'N/A';
        const iv = p.metrics?.ivRank || 'N/A';
        console.log(`  ${p.ticker}: ${price} | Range: ${range}% | IV Rank: ${iv}%`);
        if (p.specificRecommendation) {
          const rec = p.specificRecommendation;
          console.log(`    ? Entry: ${rec.putStrike}P @ �${rec.putBid} / ${rec.callStrike}C @ �${rec.callBid}`);
          console.log(`    ? Total Credit: �${rec.totalCredit} | BP Required: ${rec.bpRequired}%`);
        }
      });
    }
    
    if (patterns.good && patterns.good.length > 0) {
      console.log(`\n?? GOOD SETUPS (${patterns.good.length}):`);
      patterns.good.forEach(p => {
        console.log(`  ${p.ticker}: Score ${p.score} - ${p.recommendation}`);
      });
    }
    
    if (patterns.poor && patterns.poor.length > 0) {
      console.log(`\n?? AVOID (${patterns.poor.length}): ${patterns.poor.map(p => p.ticker).join(', ')}`);
      console.log('  ? See PDF Pages 6-7 for Never Trade List');
    }
    
    if (patterns.noData && patterns.noData.length > 0) {
      console.log(`\n? NO DATA (${patterns.noData.length}): ${patterns.noData.join(', ')}`);
      if (apiMode) {
        console.log('  ? API should have collected this data - check connection');
      } else {
        console.log('  ? Execute phase ' + phase + ' searches for these tickers');
      }
    }
  }
  
  // Concentration groups status (PDF Page 12)
  if (results.concentrationStatus) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�     ?? CONCENTRATION GROUP STATUS (PDF Page 12)               �');
    console.log('+---------------------------------------------------------------+');
    
    let hasPositions = false;
    Object.entries(results.concentrationStatus).forEach(([group, status]) => {
      if (status && status.current > 0) {
        hasPositions = true;
        console.log(`  ${group} - ${status.name}: ${status.current}/${status.limit} ${status.status}`);
        if (status.positions && status.positions.length > 0) {
          console.log(`    Positions: ${status.positions.join(', ')}`);
        }
      }
    });
    
    if (!hasPositions) {
      console.log('  No current positions in any correlation group');
    }
    
    // Show available groups for phase
    console.log('');
    console.log('  PHASE ' + phase + ' AVAILABLE SLOTS:');
    Object.entries(results.concentrationStatus).forEach(([group, status]) => {
      if (status && status.available > 0) {
        const groupTickers = getAllCorrelationGroups()[group].tickers;
        const phaseTickers = getQualifiedTickersByPhase(phase, results.userData.accountValue).tradeable;
        const availableInPhase = groupTickers.filter(t => phaseTickers.includes(t));
        
        if (availableInPhase.length > 0) {
          console.log(`    ${group} - ${status.name}: ${status.available} slot${status.available > 1 ? 's' : ''}`);
          console.log(`      Phase ${phase} tickers: ${availableInPhase.join(', ')}`);
        }
      }
    });
  }
  
  // SPAN credits for PM accounts (Phase 4)
  if (spanCredits && spanCredits.totalSaved > 0 && phase === 4) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�        ?? SPAN MARGIN CREDITS (Portfolio Margin)              �');
    console.log('+---------------------------------------------------------------+');
    spanCredits.credits.forEach(c => {
      console.log(`  ${c.tickers}: ${c.reduction} reduction = �${c.bpFreed} freed`);
    });
    console.log(`  TOTAL BP FREED: �${spanCredits.totalSaved}`);
  }
  
  // Weekly staggering (Phase 2+ only)
  if (staggering && results.userData.dayOfWeek === 'Wednesday' && phase >= 2) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�       ?? LT112 WEEKLY STAGGERING (PDF Page 26)                �');
    console.log('+---------------------------------------------------------------+');
    console.log(`  Week ${staggering.currentWeek}: ${staggering.sizing}`);
    console.log(`  Product: ${staggering.product}`);
    console.log(`  Recommendation: ${staggering.recommendation}`);
    
    if (staggering.weeksOpen && staggering.weeksOpen.length > 0) {
      console.log(`  Open Weeks: ${staggering.weeksOpen.join(', ')}`);
    }
  }
  
  // Position sizing recommendations
  if (results.sizing && results.sizing.length > 0) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�      ?? PHASE ' + phase + ' POSITION SIZING OPTIMIZATION               �');
    console.log('+---------------------------------------------------------------+');
    if (results.vixRegime) {
      console.log(`  ${results.vixRegime.message}`);
    }
    console.log(`  Current BP: ${results.userData.bpUsed}%`);
    console.log(`  Available: ${100 - results.userData.bpUsed}%`);
    console.log('');
    console.log('  PHASE ' + phase + ' RECOMMENDED POSITIONS:');
    results.sizing.forEach(s => {
      console.log(`    � ${s.strategy}: ${s.positions} positions (${s.bpRequired}% BP)`);
    });
    console.log('  (See PDF Pages 13-24 for Phase ' + phase + ' specifications)');
  }
  
  // Sustainability check
  if (results.sustainability) {
    console.log('');
    console.log('+---------------------------------------------------------------+');
    console.log('�      ?? MONTHLY SUSTAINABILITY CHECK (PDF Pages 39-40)        �');
    console.log('+---------------------------------------------------------------+');
    console.log(`  Current: �${results.userData.monthPL} (${results.sustainability.current}%)`);
    console.log(`  Projected: ${results.sustainability.projected}% monthly`);
    console.log(`  Target: ${results.sustainability.target}% monthly`);
    console.log(`  Status: ${results.sustainability.status}`);
    
    if (results.sustainability.warning) {
      console.log('');
      console.log(`  ${results.sustainability.warning}`);
      console.log(`  Action Required: ${results.sustainability.action}`);
    }
  }
  
  // Data completeness report
  if (results.dataCompleteness) {
    if (!results.dataCompleteness.valid || results.dataCompleteness.warnings?.length > 0) {
      console.log('');
      console.log('+---------------------------------------------------------------+');
      console.log('�            ??  DATA QUALITY REPORT                            �');
      console.log('+---------------------------------------------------------------+');
      
      if (results.dataCompleteness.missingTickers?.length > 0) {
        console.log(`  Missing Tickers: ${results.dataCompleteness.missingTickers.join(', ')}`);
      }
      if (results.dataCompleteness.missingFields?.length > 0) {
        console.log(`  Missing Fields: ${results.dataCompleteness.missingFields.join(', ')}`);
      }
      if (results.dataCompleteness.warnings?.length > 0) {
        console.log('  Warnings:');
        results.dataCompleteness.warnings.forEach(w => {
          console.log(`    � ${w}`);
        });
      }
    }
  }
}

// ============================================
// EXECUTION
// ============================================

console.log('');
console.log('+---------------------------------------------------------------+');
console.log('�              HOW TO EXECUTE THIS FRAMEWORK                    �');
console.log('+---------------------------------------------------------------+');
console.log('');
console.log('THREE EXECUTION MODES AVAILABLE:');
console.log('');
console.log('MODE 1: API (Automated with TastyTrade)');
console.log('  const results = executeFrameworkWithAPI(clientSecret, refreshToken);');
console.log('');
console.log('MODE 2: MANUAL (Web Searches)');
console.log('  const results = executeFramework(userInput, searchedData);');
console.log('');
console.log('MODE 3: TEST (Simulated Data)');
console.log('  const results = executeFrameworkTest();');
console.log('');
console.log('STEP-BY-STEP GUIDE:');
console.log('');
console.log('1. IDENTIFY YOUR PHASE');
console.log('  Phase 1: �30,000-40,000 (Foundation)');
console.log('  Phase 2: �40,000-60,000 (Scaling)');
console.log('  Phase 3: �60,000-75,000 (Optimization)');
console.log('  Phase 4: �75,000+ (Professional)');
console.log('');
console.log('2. CHOOSE EXECUTION MODE');
console.log('  API: Use TastyTrade credentials');
console.log('  Manual: Execute phase-specific searches');
console.log('  Test: Use simulated data');
console.log('');
console.log('3. RUN ANALYSIS');
console.log('  Framework will automatically:');
console.log('  - Analyze positions');
console.log('  - Calculate opportunities');
console.log('  - Generate recommendations');
console.log('  - Prepare orders (API mode)');
console.log('');
console.log('Framework v17.2 loaded - Production ready with full feature set.');
console.log('ALL v14.0 functionality preserved + TastyTrade API added.');
console.log('');
console.log('+---------------------------------------------------------------+');
console.log('�   ?? Reference PDF for complete strategy specifications       �');
console.log('�   ?? Execute all phase-specific searches (Manual mode)        �');
console.log('�   ?? Use API credentials for automation (API mode)            �');
console.log('�   ? Use actual market data only - no placeholders            �');
console.log('�   ?? Phase-based progression system active                    �');
console.log('+---------------------------------------------------------------+');

// Test mode execution function
function executeFrameworkTest() {
  console.log('+---------------------------------------------------------------+');
  console.log('�              ?? TEST MODE - SIMULATED DATA                    �');
  console.log('+---------------------------------------------------------------+');
  
  const testInput = '�45000 | MES LT112 (85 DTE, 6420, +12%), MCL strangle (55 DTE, 2.80, +48%) | 20% | Pretend it\'s Friday 01/10 9:45 AM EST | VIX 14.8 | No';
  
  const testSearchedData = {
    ES: {
      currentPrice: 6450,
      openPrice: 6440,
      previousClose: 6435,
      high20d: 6520,
      low20d: 6380,
      high5d: 6480,
      low5d: 6420,
      atr: 45,
      rsi: 58,
      ema8: 6445,
      ema21: 6430,
      ivRank: 35,
      ivPercentile: 40,
      optionChain: {
        put5Delta: 6200,
        put5DeltaBid: 2.50,
        call5Delta: 6700,
        call5DeltaBid: 2.75,
        atmStrike: 6450,
        call30Wide: {
          shortStrike: 6470,
          longStrike: 6500,
          credit: 2.25
        },
        put30Wide: {
          shortStrike: 6430,
          longStrike: 6400,
          credit: 2.50
        }
      }
    },
    SPY: {
      currentPrice: 458.50,
      openPrice: 457.25,
      ivRank: 32
    },
    VIX: {
      currentLevel: 14.8,
      avg20d: 15.5
    },
    DXY: {
      currentLevel: 103.5,
      trend: 'UP'
    },
    TIME: {
      currentEST: '9:45 AM',
      currentUK: '2:45 PM',
      marketStatus: 'OPEN'
    },
    MCL: {
      currentPrice: 65.50,
      high20d: 68.00,
      low20d: 63.00,
      ivRank: 52
    }
  };
  
  console.log('Test data loaded:');
  console.log('  Account: �45,000 (Phase 2)');
  console.log('  Positions: 2');
  console.log('  Time: Friday 9:45 AM EST');
  console.log('  VIX: 14.8');
  console.log('');
  
  return executeFramework(testInput, testSearchedData);
}

HTML DASHBOARD TEMPLATE
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tom King Trading Dashboard v17.2 - Production Ready</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<style>
  body { 
    font-family: 'Segoe UI', Arial, sans-serif; 
    padding: 20px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    margin: 0;
  }
  
  .header { 
    background: white; 
    padding: 25px; 
    border-radius: 12px; 
    margin-bottom: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }
  
  .phase-indicator {
    display: inline-block;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: bold;
    margin-left: 15px;
  }
  
  .api-indicator {
    display: inline-block;
    background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: bold;
    margin-left: 10px;
  }
  
  .metrics { 
    display: flex; 
    gap: 30px; 
    margin-top: 15px;
    flex-wrap: wrap;
  }
  
  .metric { 
    color: #7f8c8d;
    font-size: 14px;
  }
  
  .metric span { 
    font-weight: bold; 
    color: #2c3e50;
    font-size: 18px;
  }
  
  .grid { 
    display: grid; 
    grid-template-columns: 1fr 1fr; 
    gap: 20px; 
    margin-bottom: 20px;
  }
  
  @media (max-width: 768px) {
    .grid { grid-template-columns: 1fr; }
  }
  
  .container { 
    background: white; 
    padding: 20px; 
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    margin-bottom: 20px;
  }
  
  .warning {
    background: #e74c3c;
    color: white;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.8; }
    100% { opacity: 1; }
  }
  
  .premarket-box {
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }
  
  .countdown {
    font-size: 32px;
    font-weight: bold;
    text-align: center;
    background: rgba(255,255,255,0.1);
    padding: 15px;
    border-radius: 8px;
    margin: 15px 0;
  }
  
  .order-ready {
    background: linear-gradient(135deg, #27ae60 0%, #16a085 100%);
    color: white;
    padding: 15px;
    border-radius: 8px;
    margin-top: 15px;
    text-align: center;
    font-weight: bold;
  }
  
  .recycling-box {
    background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }
  
  .august-warning {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
  }
  
  .pattern-indicator {
    display: inline-block;
    padding: 5px 10px;
    border-radius: 6px;
    margin: 3px;
    font-weight: bold;
  }
  
  .pattern-excellent { background: #27ae60; color: white; }
  .pattern-good { background: #f39c12; color: white; }
  .pattern-poor { background: #e74c3c; color: white; }
  .pattern-nodata { background: #34495e; color: white; }
  
  table { 
    width: 100%; 
    border-collapse: collapse; 
  }
  
  th { 
    padding: 12px 8px; 
    text-align: left; 
    border-bottom: 2px solid #667eea;
    color: #2c3e50;
  }
  
  td { 
    padding: 10px 8px; 
    border-bottom: 1px solid #ecf0f1;
  }
  
  .exit-trigger {
    background: #ffe5e5;
  }
  
  .no-data {
    text-align: center;
    padding: 20px;
    color: #95a5a6;
  }
  
  canvas {
    max-height: 350px;
  }
  
  .error-message {
    background: #ffebee;
    color: #c62828;
    padding: 10px;
    border-radius: 4px;
    margin: 10px 0;
  }
  
  .status-badge {
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
  }
  
  .status-active { background: #4caf50; color: white; }
  .status-warning { background: #ff9800; color: white; }
  .status-closed { background: #f44336; color: white; }
  
  .bp-table table {
    font-size: 14px;
  }
  
  .bp-table th {
    background: #f8f9fa;
  }
  
  .bp-table .total-row {
    font-weight: bold;
    background: #e8f4f8;
  }
  
  .phase-progress {
    background: #ecf0f1;
    border-radius: 10px;
    padding: 3px;
    margin: 15px 0;
  }
  
  .phase-progress-bar {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 8px;
    border-radius: 8px;
    text-align: center;
    font-weight: bold;
    transition: width 0.3s ease;
  }
  
  .greeks-display {
    display: flex;
    justify-content: space-around;
    margin: 15px 0;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 8px;
  }
  
  .greek-item {
    text-align: center;
  }
  
  .greek-label {
    font-size: 12px;
    color: #7f8c8d;
  }
  
  .greek-value {
    font-size: 20px;
    font-weight: bold;
    color: #2c3e50;
  }
</style>
</head>
<body>

<div class="header">
  <h1>?? Tom King Trading Dashboard v17.2
    <span class="phase-indicator" id="phaseIndicator">Loading...</span>
    <span class="api-indicator" id="apiIndicator" style="display:none;">API MODE</span>
  </h1>
  <div class="metrics">
    <div class="metric">Account: <span id="accountValue">Loading...</span></div>
    <div class="metric">BP Used: <span id="bpUsed">-</span></div>
    <div class="metric">Month P&L: <span id="monthPL">-</span></div>
    <div class="metric">VIX: <span id="vixLevel">-</span></div>
    <div class="metric">ES: <span id="esPrice">-</span></div>
    <div class="metric">Time: <span id="currentTime">-</span></div>
    <div class="metric">Status: <span id="marketStatus" class="status-badge">-</span></div>
  </div>
  <div class="phase-progress">
    <div class="phase-progress-bar" id="phaseProgress">Phase Progress</div>
  </div>
</div>

<!-- API Mode Greeks Display -->
<div id="greeksSection" class="container" style="display:none;">
  <h3>?? Real-Time Portfolio Greeks (API Mode)</h3>
  <div class="greeks-display">
    <div class="greek-item">
      <div class="greek-label">Delta</div>
      <div class="greek-value" id="portfolioDelta">-</div>
    </div>
    <div class="greek-item">
      <div class="greek-label">Gamma</div>
      <div class="greek-value" id="portfolioGamma">-</div>
    </div>
    <div class="greek-item">
      <div class="greek-label">Theta</div>
      <div class="greek-value" id="portfolioTheta">-</div>
    </div>
    <div class="greek-item">
      <div class="greek-label">Vega</div>
      <div class="greek-value" id="portfolioVega">-</div>
    </div>
  </div>
</div>

<!-- Weekend/After-Hours Warning -->
<div id="marketClosedWarning" style="display:none;">
  <div class="warning">
    <h3>?? MARKET CLOSED</h3>
    <div id="marketClosedReason"></div>
  </div>
</div>

<!-- August 2024 Correlation Warning -->
<div id="august2024Warning" style="display:none;">
  <div class="august-warning">
    <h3>?? AUGUST 2024 CORRELATION WARNING</h3>
    <p>Tom lost �308,000 with 6 correlated positions. Don't repeat this mistake!</p>
    <div id="august2024Content"></div>
  </div>
</div>

<!-- Friday Pre-Market Section -->
<div id="premarketSection" style="display:none;">
  <div class="premarket-box">
    <h2 style="color:white;">?? 0DTE PRE-MARKET ANALYSIS - Phase <span id="phaseODTE">-</span></h2>
    <div id="premarketPhase"></div>
    <div class="countdown" id="countdown">Loading...</div>
    <div id="triggerLevels" style="margin-top: 15px;">
      <div>?? CALL SPREAD: ES > <span id="callTrigger">-</span></div>
      <div>?? PUT SPREAD: ES < <span id="putTrigger">-</span></div>
      <div>?? IRON CONDOR: Between triggers</div>
    </div>
    <div id="creditInfo" style="margin-top: 10px; font-size: 14px;"></div>
    <div style="margin-top: 10px;">Max Contracts for Phase: <strong id="maxContracts">-</strong></div>
    <div id="orderReady" class="order-ready" style="display:none;">
      ?? ORDER READY FOR SUBMISSION VIA API
    </div>
  </div>
</div>

<!-- VIX Spike Alert -->
<div id="vixSpikeAlert" style="display:none;">
  <div class="warning">
    <h2>?????? VIX SPIKE OPPORTUNITY PROTOCOL ??????</h2>
    <div id="vixSpikeContent"></div>
  </div>
</div>

<!-- Warnings -->
<div id="warnings"></div>

<!-- Capital Recycling -->
<div id="recyclingSection" style="display:none;">
  <div class="recycling-box">
    <h2 style="color:white;">?? CAPITAL RECYCLING OPPORTUNITIES</h2>
    <div id="recyclingContent"></div>
  </div>
</div>

<!-- Position Allocation Table -->
<div class="container bp-table">
  <h3>Phase <span id="phaseAllocation">-</span> Position Allocation & BP Optimization</h3>
  <table id="allocationTable">
    <thead>
      <tr>
        <th>Strategy</th>
        <th>Max Pos</th>
        <th>Current</th>
        <th>Available</th>
        <th>BP/Pos</th>
        <th>BP Used</th>
        <th>Can Add</th>
        <th>Priority</th>
      </tr>
    </thead>
    <tbody id="allocationRows">
      <tr class="no-data">
        <td colspan="8">Loading allocation data...</td>
      </tr>
    </tbody>
  </table>
  <div id="bpOptimizationPlan" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px;"></div>
</div>

<!-- Position Health -->
<div class="container">
  <h3>Position Health & Exit Triggers</h3>
  <table id="positionTable">
    <thead>
      <tr>
        <th>Position</th>
        <th>DTE</th>
        <th>P&L</th>
        <th>Health</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody id="positionRows">
      <tr class="no-data">
        <td colspan="5">Loading positions...</td>
      </tr>
    </tbody>
  </table>
</div>

<!-- Pattern Analysis -->
<div class="container">
  <h3>Phase <span id="phasePatterns">-</span> Pattern Analysis</h3>
  <div id="patternSummary" style="margin-bottom: 15px;">
    <span class="pattern-indicator pattern-excellent">?? EXCELLENT: 0</span>
    <span class="pattern-indicator pattern-good">?? GOOD: 0</span>
    <span class="pattern-indicator pattern-poor">?? AVOID: 0</span>
    <span class="pattern-indicator pattern-nodata">? NO DATA: 0</span>
  </div>
  <div id="patternDetails">Loading patterns...</div>
</div>

<div class="grid">
  <div class="container">
    <canvas id="bpChart"></canvas>
  </div>
  <div class="container">
    <canvas id="concentrationChart"></canvas>
  </div>
</div>

<!-- Phase-Specific Information -->
<div class="container">
  <h3>Phase <span id="phaseInfo">-</span> Information</h3>
  <div id="phaseContent"></div>
</div>

<!-- SPAN Credits (PM Only) -->
<div id="spanSection" class="container" style="display:none;">
  <h3>?? SPAN Margin Credits (Portfolio Margin - Phase 4)</h3>
  <div id="spanContent"></div>
</div>

<!-- Weekly Staggering -->
<div id="staggeringSection" class="container" style="display:none;">
  <h3>?? LT112 Weekly Staggering (Phase 2+)</h3>
  <div id="staggeringContent"></div>
</div>

<!-- Tickers to Search -->
<div id="tickerSearchSection" class="container" style="display:none;">
  <h3>?? Phase <span id="phaseSearch">-</span> Tickers Requiring Search</h3>
  <div id="tickerSearchContent"></div>
</div>

<!-- Data Quality Report -->
<div id="dataQuality" class="container" style="display:none;">
  <h3>?? Data Quality Report</h3>
  <div id="dataQualityContent"></div>
</div>

<script>
// Complete Dashboard JavaScript Implementation with API Support
window.addEventListener('load', function() {
  // Chart instances
  let bpChart = null;
  let concentrationChart = null;
  
  // Auto-refresh every 30 seconds if framework results exist
  setInterval(() => {
    if (window.frameworkResults) {
      updateDashboard(window.frameworkResults);
    }
  }, 30000);
  
  // Real-time Greeks update for API mode
  setInterval(() => {
    if (window.frameworkResults?.greeksMonitor) {
      updateGreeksDisplay();
    }
  }, 5000);
  
  function updateDashboard(results) {
    if (!results || !results.success) {
      document.getElementById('warnings').innerHTML = 
        '<div class="warning">No analysis results available. Execute framework first.</div>';
      return;
    }
    
    // Update phase indicators
    updatePhaseIndicators(results);
    
    // Update header metrics
    updateHeaderMetrics(results);
    
    // Update warnings and alerts
    updateWarningsAndAlerts(results);
    
    // Update position allocation table
    updateAllocationTable(results);
    
    // Update position health table
    updatePositionHealth(results);
    
    // Update pattern analysis
    updatePatternAnalysis(results);
    
    // Update charts
    updateCharts(results);
    
    // Update optional sections
    updateOptionalSections(results);
    
    // Update phase-specific information
    updatePhaseInfo(results);
    
    // API-specific updates
    if (results.apiMode) {
      updateAPIFeatures(results);
    }
  }
  
  function updatePhaseIndicators(results) {
    const phase = results.phase || 1;
    const accountValue = results.userData.accountValue;
    
    // Update all phase indicators
    document.getElementById('phaseIndicator').textContent = `PHASE ${phase}`;
    document.getElementById('phaseAllocation').textContent = phase;
    document.getElementById('phasePatterns').textContent = phase;
    document.getElementById('phaseInfo').textContent = phase;
    document.getElementById('phaseSearch').textContent = phase;
    document.getElementById('phaseODTE').textContent = phase;
    
    // Show API indicator if in API mode
    if (results.apiMode) {
      document.getElementById('apiIndicator').style.display = 'inline-block';
    }
    
    // Update phase progress bar
    const phaseThresholds = [30000, 40000, 60000, 75000];
    const nextThreshold = phaseThresholds[phase] || 150000;
    const prevThreshold = phaseThresholds[phase - 2] || 30000;
    const progress = ((accountValue - prevThreshold) / (nextThreshold - prevThreshold)) * 100;
    
    const progressBar = document.getElementById('phaseProgress');
    progressBar.style.width = `${Math.min(100, Math.max(0, progress))}%`;
    progressBar.textContent = phase < 4 ? 
      `Phase ${phase}: �${(accountValue/1000).toFixed(0)}k / �${(nextThreshold/1000).toFixed(0)}k` :
      `Phase 4: Professional (�${(accountValue/1000).toFixed(0)}k)`;
  }
  function updateAPIFeatures(results) {
    // Show Greeks display if available
    if (results.greeksMonitor) {
      document.getElementById('greeksSection').style.display = 'block';
      updateGreeksDisplay();
    }
    
    // Show order ready indicator for 0DTE
    if (results.strikeRecommendation?.apiReady) {
      document.getElementById('orderReady').style.display = 'block';
    }
  }
  
  function updateGreeksDisplay() {
    if (!window.frameworkResults?.greeksMonitor) return;
    
    const greeks = window.frameworkResults.greeksMonitor.getPortfolioGreeks();
    
    document.getElementById('portfolioDelta').textContent = 
      greeks.totalDelta.toFixed(2);
    document.getElementById('portfolioGamma').textContent = 
      greeks.totalGamma.toFixed(4);
    document.getElementById('portfolioTheta').textContent = 
      `�${greeks.totalTheta.toFixed(0)}`;
    document.getElementById('portfolioVega').textContent = 
      `�${greeks.totalVega.toFixed(0)}`;
  }
  
  function updateHeaderMetrics(results) {
    document.getElementById('accountValue').textContent = 
      '�' + results.userData.accountValue.toLocaleString();
    
    document.getElementById('bpUsed').textContent = 
      results.userData.bpUsed + '%';
    
    document.getElementById('monthPL').textContent = 
      '�' + results.userData.monthPL.toLocaleString();
    
    document.getElementById('vixLevel').textContent = 
      results.userData.vixLevel + ' (' + results.vixRegime.regime + ')';
    
    document.getElementById('esPrice').textContent = 
      results.esPrice ? results.esPrice.toFixed(2) : 'NO DATA';
    
    document.getElementById('currentTime').textContent = 
      results.userData.dayOfWeek + ' ' + results.userData.timeStr;
    
    const statusEl = document.getElementById('marketStatus');
    statusEl.textContent = results.currentTime.marketStatus;
    statusEl.className = 'status-badge ' + 
      (results.currentTime.marketStatus === 'OPEN' ? 'status-active' :
       results.currentTime.marketStatus.includes('CLOSED') ? 'status-closed' : 
       'status-warning');
  }
  
  function updateWarningsAndAlerts(results) {
    let warningsHtml = '';
    
    // Market closed warning
    if (results.userData.isWeekend || results.currentTime.marketStatus.includes('CLOSED')) {
      document.getElementById('marketClosedWarning').style.display = 'block';
      document.getElementById('marketClosedReason').textContent = 
        results.userData.isWeekend ? 'Market closed for weekend.' : 'Market is currently closed.';
    }
    
    // August 2024 correlation warnings
    if (results.august2024Warnings && results.august2024Warnings.length > 0) {
      document.getElementById('august2024Warning').style.display = 'block';
      let warningContent = '<ul>';
      results.august2024Warnings.forEach(warning => {
        warningContent += '<li>' + warning + '</li>';
      });
      warningContent += '</ul>';
      document.getElementById('august2024Content').innerHTML = warningContent;
    }
    
    // VIX spike alert
    if (results.vixOpportunity?.triggered) {
      document.getElementById('vixSpikeAlert').style.display = 'block';
      let vixHtml = '<p>VIX at ' + results.userData.vixLevel + '</p><ul>';
      results.vixOpportunity.actions.forEach(action => {
        vixHtml += '<li>' + action + '</li>';
      });
      vixHtml += '</ul><p><strong>Deploy: �' + results.vixOpportunity.deployment.toLocaleString() + '</strong></p>';
      document.getElementById('vixSpikeContent').innerHTML = vixHtml;
    }
    
    // Exit triggers
    if (results.exitTriggers?.length > 0) {
      warningsHtml += '<div class="warning"><strong>?? EXIT TRIGGERS:</strong><br>';
      results.exitTriggers.forEach(p => {
        warningsHtml += p.ticker + ' ' + p.strategy + ': ' + p.action + '<br>';
      });
      warningsHtml += '</div>';
    }
    
    // Sustainability warning
    if (results.sustainability?.warning) {
      warningsHtml += '<div class="warning">' + results.sustainability.warning + '<br>' +
        'Action: ' + results.sustainability.action + '</div>';
    }
    
    document.getElementById('warnings').innerHTML = warningsHtml;
    
    // Friday pre-market with phase info
    if (results.countdown && results.userData.dayOfWeek === 'Friday') {
      updatePremarketSection(results);
    }
    
    // Capital recycling
    if (results.recycling?.count > 0) {
      updateRecyclingSection(results);
    }
  }
  
  function updatePremarketSection(results) {
    document.getElementById('premarketSection').style.display = 'block';
    
    const phase = results.phase || 1;
    const maxContracts = phase; // Phase 1 = 1 contract, Phase 2 = 2, etc.
    document.getElementById('maxContracts').textContent = maxContracts;
    
    if (results.countdown.phase) {
      document.getElementById('premarketPhase').innerHTML = 
        '<strong>Phase: ' + results.countdown.phase + '</strong> ' + 
        (results.countdown.status || '');
    }
    
    document.getElementById('countdown').textContent = 
      results.countdown.message || 'No countdown data';
    
    if (results.strikeRecommendation?.triggers) {
      document.getElementById('callTrigger').textContent = 
        results.strikeRecommendation.triggers.callTrigger || 'CALCULATE';
      document.getElementById('putTrigger').textContent = 
        results.strikeRecommendation.triggers.putTrigger || 'CALCULATE';
      
      let creditInfo = 'Credit: ' + (results.strikeRecommendation.creditSource || 'SEARCH REQUIRED');
      if (results.strikeRecommendation.strikes.credit && results.strikeRecommendation.strikes.credit !== 'SEARCH REQUIRED') {
        creditInfo += ' | Total with ' + maxContracts + ' contracts: �' + 
          (results.strikeRecommendation.strikes.credit * maxContracts).toFixed(2);
      }
      document.getElementById('creditInfo').textContent = creditInfo;
    }
  }
  
  function updateRecyclingSection(results) {
    document.getElementById('recyclingSection').style.display = 'block';
    let recycleHtml = '<ul>';
    results.recycling.positions.forEach(r => {
      recycleHtml += '<li>' + r.position + ': ' + r.reason + 
        ' (Frees ' + r.bpToFree + '% BP)</li>';
    });
    recycleHtml += '</ul><strong>Total BP to Free: ' + 
      results.recycling.totalBPFreed + '%</strong><br>' +
      'Redeployment: ' + results.recycling.redeploymentOptions.join(', ');
    document.getElementById('recyclingContent').innerHTML = recycleHtml;
  }
  
  function updateAllocationTable(results) {
    if (!results.allocationTable) return;
    
    const tbody = document.getElementById('allocationRows');
    tbody.innerHTML = '';
    
    results.allocationTable.table.forEach(row => {
      const tr = tbody.insertRow();
      tr.innerHTML = 
        '<td><strong>' + row.strategy + '</strong></td>' +
        '<td>' + row.maxPos + '</td>' +
        '<td>' + row.currentPos + '</td>' +
        '<td>' + row.availablePos + '</td>' +
        '<td>' + row.bpPerPos + '%</td>' +
        '<td>' + row.currentBP + '%</td>' +
        '<td>' + row.canAddBP + '%</td>' +
        '<td>' + row.priority + '</td>';
    });
    
    // Add total row
    const totalRow = tbody.insertRow();
    totalRow.className = 'total-row';
    const totalBP = results.allocationTable.table.reduce((sum, row) => sum + row.currentBP, 0);
    const totalAvail = results.allocationTable.table.reduce((sum, row) => sum + row.canAddBP, 0);
    totalRow.innerHTML = 
      '<td><strong>TOTAL</strong></td>' +
      '<td>-</td><td>-</td><td>-</td><td>-</td>' +
      '<td><strong>' + totalBP + '%</strong></td>' +
      '<td><strong>' + totalAvail + '%</strong></td>' +
      '<td>-</td>';
    
    // BP optimization plan with phase awareness
    if (results.bpOptimization?.needed && results.bpOptimization.plan.length > 0) {
      let planHtml = '<strong>Phase ' + results.phase + ' Optimization Plan to ' + 
        results.bpOptimization.targetMin + '% BP:</strong><ol>';
      results.bpOptimization.plan.forEach(item => {
        planHtml += '<li>Add ' + item.positions + ' ' + item.strategy + 
          ' position' + (item.positions > 1 ? 's' : '') + 
          ' (+' + item.bpAdded + '%) ' + item.when + '</li>';
      });
      planHtml += '</ol><strong>Final BP: ' + results.bpOptimization.projectedBP + '%</strong>';
      document.getElementById('bpOptimizationPlan').innerHTML = planHtml;
    }
  }
  
  function updatePositionHealth(results) {
    const tbody = document.getElementById('positionRows');
    tbody.innerHTML = '';
    
    if (results.positionHealth?.length > 0) {
      results.positionHealth.forEach(p => {
        const row = tbody.insertRow();
        row.innerHTML = 
          '<td>' + p.ticker + ' ' + p.strategy + '</td>' +
          '<td>' + p.dte + '</td>' +
          '<td>' + (p.pl >= 0 ? '+' : '') + p.pl + '%</td>' +
          '<td>' + p.score + '/100</td>' +
          '<td>' + p.action + '</td>';
        
        if (p.exitTrigger) {
          row.className = 'exit-trigger';
        }
      });
    } else {
      tbody.innerHTML = '<tr class="no-data"><td colspan="5">No current positions</td></tr>';
    }
  }
  
  function updatePatternAnalysis(results) {
    if (!results.patterns) return;
    
    const excellentCount = results.patterns.excellent?.length || 0;
    const goodCount = results.patterns.good?.length || 0;
    const poorCount = results.patterns.poor?.length || 0;
    const noDataCount = results.patterns.noData?.length || 0;
    
    document.getElementById('patternSummary').innerHTML = 
      '<span class="pattern-indicator pattern-excellent">?? EXCELLENT: ' + excellentCount + '</span> ' +
      '<span class="pattern-indicator pattern-good">?? GOOD: ' + goodCount + '</span> ' +
      '<span class="pattern-indicator pattern-poor">?? AVOID: ' + poorCount + '</span> ' +
      '<span class="pattern-indicator pattern-nodata">? NO DATA: ' + noDataCount + '</span>';
    
    let patternHtml = '';
    
    if (excellentCount > 0) {
      patternHtml += '<h4>?? Excellent Opportunities:</h4><ul>';
      results.patterns.excellent.forEach(p => {
        patternHtml += '<li><strong>' + p.ticker + '</strong>: ' + 
          (p.metrics?.currentPrice || 'NO PRICE') + ' ' +
          '(Range: ' + (p.metrics?.range20d || 'N/A') + '%, ' +
          'IV: ' + (p.metrics?.ivRank || 'N/A') + '%)';
        
        if (p.specificRecommendation) {
          const rec = p.specificRecommendation;
          patternHtml += '<br>? Strikes: ' + rec.putStrike + 'P @ �' + rec.putBid + 
            ' / ' + rec.callStrike + 'C @ �' + rec.callBid +
            '<br>? Total Credit: �' + rec.totalCredit;
        }
        patternHtml += '</li>';
      });
      patternHtml += '</ul>';
    }
    
    if (goodCount > 0) {
      patternHtml += '<h4>?? Good Opportunities:</h4><ul>';
      results.patterns.good.forEach(p => {
        patternHtml += '<li>' + p.ticker + ': Score ' + p.score + ' - ' + p.recommendation + '</li>';
      });
      patternHtml += '</ul>';
    }
    
    document.getElementById('patternDetails').innerHTML = patternHtml || 'No qualifying patterns found';
  }
  
  function updatePhaseInfo(results) {
    const phase = results.phase || 1;
    const phaseInfo = {
      1: {
        title: 'Phase 1: Foundation (�30-40k)',
        strategies: ['0DTE (1 contract)', 'IPMCC (1 position)', 'Strangles (1 position)'],
        tickers: ['MCL', 'MGC', 'GLD', 'TLT'],
        target: '8-10% monthly',
        nextPhase: '�40,000'
      },
      2: {
        title: 'Phase 2: Scaling (�40-60k)',
        strategies: ['0DTE (2 contracts)', 'LT112 (MES)', 'IPMCC (2 positions)', 'Strangles (3)', 'Ratio Spreads', 'LEAPs'],
        tickers: ['MCL', 'MGC', 'GLD', 'TLT', 'MES', 'MNQ', 'SLV', 'XOP', '6A', 'M6E'],
        target: '10-12% monthly',
        nextPhase: '�60,000'
      },
      3: {
        title: 'Phase 3: Optimization (�60-75k)',
        strategies: ['0DTE (3 contracts)', 'ES upgrade', 'Butterflies', 'Box Spreads', 'Diagonals', 'All previous'],
        tickers: ['ES', 'CL', 'GC', 'LE', 'HE', 'ZC', 'ZS', 'ZW', '6E', '6B', 'All previous'],
        target: '10-13% monthly',
        nextPhase: '�75,000'
      },
      4: {
        title: 'Phase 4: Professional (�75k+)',
        strategies: ['0DTE (4+ contracts)', 'Full ES positions', 'Weekly 112 stacking', 'All strategies unlocked'],
        tickers: ['All products available - see PDF Pages 22-24'],
        target: '10-12% monthly sustainable',
        nextPhase: 'Portfolio Margin at �111k'
      }
    };
    
    const info = phaseInfo[phase];
    if (info) {
      let html = '<h4>' + info.title + '</h4>';
      html += '<p><strong>Available Strategies:</strong></p><ul>';
      info.strategies.forEach(s => html += '<li>' + s + '</li>');
      html += '</ul>';
      html += '<p><strong>Qualified Tickers:</strong> ' + info.tickers.join(', ') + '</p>';
      html += '<p><strong>Monthly Target:</strong> ' + info.target + '</p>';
      if (info.nextPhase) {
        html += '<p><strong>Next Phase at:</strong> ' + info.nextPhase + '</p>';
      }
      if (results.apiMode) {
        html += '<p><strong>Mode:</strong> ?? API (Real-time data from TastyTrade)</p>';
      }
      document.getElementById('phaseContent').innerHTML = html;
    }
  }
  
  function updateCharts(results) {
    // BP Allocation Chart
    if (results.allocationTable) {
      const bpData = [];
      const bpLabels = [];
      
      results.allocationTable.table.forEach(row => {
        if (row.currentBP > 0) {
          bpLabels.push(row.strategy);
          bpData.push(row.currentBP);
        }
      });
      
      const availableBP = Math.max(0, 100 - results.userData.bpUsed);
      bpLabels.push('Available');
      bpData.push(availableBP);
      
      const bpCanvas = document.getElementById('bpChart');
      if (bpCanvas) {
        if (bpChart) bpChart.destroy();
        
        bpChart = new Chart(bpCanvas, {
          type: 'bar',
          data: {
            labels: bpLabels,
            datasets: [{
              label: 'BP %',
              data: bpData,
              backgroundColor: ['#3498db', '#e74c3c', '#f39c12', '#27ae60', '#9966ff', '#95a5a6']
            }]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: { 
                display: true, 
                text: 'Phase ' + (results.phase || 1) + ' Buying Power Allocation' + 
                      (results.apiMode ? ' (Live)' : '')
              }
            },
            scales: {
              x: { max: 100, beginAtZero: true }
            }
          }
        });
      }
    }
    
    // Concentration Chart
    if (results.concentrationStatus) {
      const groups = ['A1', 'A2', 'B1', 'C1', 'D1', 'E', 'F'];
      const concentrationData = groups.map(g => 
        results.concentrationStatus[g]?.current || 0
      );
      
      if (concentrationData.some(d => d > 0)) {
        const concCanvas = document.getElementById('concentrationChart');
        if (concCanvas) {
          if (concentrationChart) concentrationChart.destroy();
          
          concentrationChart = new Chart(concCanvas, {
            type: 'doughnut',
            data: {
              labels: ['Equity Index', 'Equity ETF', 'Metals', 'Energy', 'Agriculture', 'Bonds', 'Currency'],
              datasets: [{
                data: concentrationData,
                backgroundColor: ['#ff6384', '#36a2eb', '#ffcd56', '#4bc0c0', '#9966ff', '#ff9f40', '#c9cbcf']
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                title: { 
                  display: true, 
                  text: 'Concentration by Group (Max 2 each, 3 for Phase 4)' 
                }
              }
            }
          });
        }
      }
    }
  }
  
  function updateOptionalSections(results) {
    const phase = results.phase || 1;
    
    // SPAN credits (Phase 4 only)
    if (results.spanCredits?.totalSaved > 0 && phase === 4) {
      document.getElementById('spanSection').style.display = 'block';
      let spanHtml = '<ul>';
      results.spanCredits.credits.forEach(c => {
        spanHtml += '<li>' + c.tickers + ': ' + c.reduction + 
          ' reduction = �' + c.bpFreed + '</li>';
      });
      spanHtml += '</ul><strong>Total BP Freed: �' + results.spanCredits.totalSaved + '</strong>';
      document.getElementById('spanContent').innerHTML = spanHtml;
    }
    
    // Weekly staggering (Phase 2+ only)
    if (results.staggering && results.userData.dayOfWeek === 'Wednesday' && phase >= 2) {
      document.getElementById('staggeringSection').style.display = 'block';
      document.getElementById('staggeringContent').innerHTML = 
        '<p>Week ' + results.staggering.currentWeek + ': ' + results.staggering.sizing + '</p>' +
        '<p>Product: ' + results.staggering.product + '</p>' +
        '<p><strong>Recommendation: ' + results.staggering.recommendation + '</strong></p>';
    }
    
    // Tickers to search (phase-specific) - only for manual mode
    if (results.tickersToSearch?.length > 0 && !results.apiMode) {
      document.getElementById('tickerSearchSection').style.display = 'block';
      let searchHtml = '<p>Execute searches for these Phase ' + phase + ' qualified tickers:</p><ul>';
      results.tickersToSearch.forEach(ticker => {
        searchHtml += '<li><strong>' + ticker + '</strong>: Price, Range, IV Rank, Option Chain</li>';
      });
      searchHtml += '</ul>';
      document.getElementById('tickerSearchContent').innerHTML = searchHtml;
    }
    
    // Data quality report
    if (results.dataCompleteness && (!results.dataCompleteness.valid || results.dataCompleteness.warnings?.length > 0)) {
      document.getElementById('dataQuality').style.display = 'block';
      let qualityHtml = '<ul>';
      
      if (results.dataCompleteness.missingTickers?.length > 0) {
        qualityHtml += '<li>Missing Tickers: ' + results.dataCompleteness.missingTickers.join(', ') + '</li>';
      }
      if (results.dataCompleteness.missingFields?.length > 0) {
        qualityHtml += '<li>Missing Fields: ' + results.dataCompleteness.missingFields.join(', ') + '</li>';
      }
      if (results.dataCompleteness.warnings?.length > 0) {
        results.dataCompleteness.warnings.forEach(w => {
          qualityHtml += '<li>' + w + '</li>';
        });
      }
      
      if (results.apiMode) {
        qualityHtml += '<li><strong>API Mode: Data collection should be automatic</strong></li>';
      }
      
      qualityHtml += '</ul>';
      document.getElementById('dataQualityContent').innerHTML = qualityHtml;
    }
  }
  
  // Initial load
  if (window.frameworkResults) {
    updateDashboard(window.frameworkResults);
  } else {
    document.getElementById('warnings').innerHTML = 
      '<div class="warning">Waiting for framework execution...</div>';
  }
});
</script>

</body>
</html>
// END OF TOM KING TRADING FRAMEWORK v17.2

// ============================================================
// AUTO-EXECUTE SECTION - RUNS IMMEDIATELY WHEN LOADED
// ============================================================

console.log('\n🚀 TOM KING TRADING FRAMEWORK v17 - READY');
console.log('============================================================\n');

// Check for stored credentials but allow manual override
if (typeof API_CREDENTIALS !== 'undefined' && API_CREDENTIALS.CLIENT_SECRET) {
    console.log('✅ Stored credentials detected');
    console.log('');
    console.log('📋 EXECUTION OPTIONS:');
    console.log('   1. AUTO MODE - Connect to TastyTrade API automatically');
    console.log('   2. MANUAL MODE - Provide account details for testing scenarios');
    console.log('   3. TEST MODE - Use simulated data');
    console.log('');
    console.log('💡 To use MANUAL MODE for testing, provide account details in format:');
    console.log('   £[amount] | [positions] | [BP%] | [Day Date Time] | VIX [level] | [PM Y/N]');
    console.log('');
    console.log('📝 Example for testing:');
    console.log('   £45000 | ES LT112 (85 DTE, 6420, +5%) | 32% | Friday Jan 10 10:15 AM EST | VIX 15.2 | No');
    console.log('');
    console.log('🔄 Waiting for input or will auto-connect to API in 10 seconds...');
    console.log('============================================================\n');
    
    // Note: This auto-execute is commented out to allow manual input
    // Uncomment the section below to enable automatic API connection
    
    /*
    // AUTO-EXECUTE VERSION (currently disabled for manual testing)
    (async () => {
        try {
            console.log('🔄 Connecting to API automatically...');
            const apiContext = await initializeAPIMode(
                API_CREDENTIALS.CLIENT_SECRET,
                API_CREDENTIALS.REFRESH_TOKEN,
                'production'
            );
            
            if (apiContext) {
                // Display account status
                console.log('📊 ACCOUNT STATUS:');
                console.log(`   Account: ${apiContext.api.accountNumber}`);
                console.log(`   Net Liq: £${apiContext.accountStatus.netLiq.toLocaleString()}`);
                console.log(`   Buying Power: £${apiContext.accountStatus.buyingPower.toLocaleString()}`);
                console.log(`   Phase: ${apiContext.userData.phase}`);
                console.log(`   Positions: ${apiContext.userData.currentPositions}\n`);
                
                // Display market data
                console.log('📈 MARKET DATA:');
                console.log(`   ES: ${apiContext.searchedData.ES.currentPrice}`);
                console.log(`   SPY: ${apiContext.searchedData.SPY.currentPrice}`);
                console.log(`   VIX: ${apiContext.searchedData.VIX.current} (${apiContext.searchedData.VIX.regime.description})\n`);
                
                // Build framework input
                const userInput = [
                    `£${Math.round(apiContext.accountStatus.netLiq)}`,
                    apiContext.userData.currentPositions,
                    `${((apiContext.accountStatus.buyingPower / apiContext.accountStatus.netLiq) * 100).toFixed(1)}%`,
                    new Date().toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        month: 'numeric', 
                        day: 'numeric',
                        hour: 'numeric',
                        minute: 'numeric',
                        timeZone: 'America/New_York'
                    }) + ' EST',
                    `VIX ${apiContext.searchedData.VIX.current}`,
                    apiContext.accountStatus.netLiq > 111000 ? 'Yes' : 'No'
                ].join(' | ');
                
                // Execute pattern analysis
                console.log('🔍 Running pattern analysis...\n');
                const results = typeof analyzePatterns === 'function' 
                    ? analyzePatterns(userInput, apiContext.searchedData)
                    : executeFramework(userInput, apiContext.searchedData);
                
                // Display recommendations
                if (results && results.recommendations) {
                    console.log('💡 RECOMMENDATIONS:');
                    console.log(results.recommendations);
                }
                
                // Check for Friday 0DTE opportunity
                const now = new Date();
                const isFriday = now.getDay() === 5;
                const hour = now.getHours();
                const minute = now.getMinutes();
                const after1030 = hour > 10 || (hour === 10 && minute >= 30);
                
                if (isFriday && after1030) {
                    console.log('\n📅 FRIDAY 0DTE OPPORTUNITY DETECTED');
                    if (results.strikeRecommendation) {
                        // Prepare order for manual submission
                        const orderDetails = await apiContext.orderBuilder.prepare0DTESpread(
                            results.strikeRecommendation.direction || 'CALL',
                            results.strikeRecommendation.strikes || { short: 5500, long: 5530 },
                            5.00
                        );
                        
                        console.log('\n📋 ORDER PREPARED FOR MANUAL SUBMISSION:');
                        console.log(`   Strategy: ${orderDetails.strategy}`);
                        console.log(`   Direction: ${orderDetails.direction}`);
                        console.log(`   Strikes: ${orderDetails.strikes.short}/${orderDetails.strikes.long}`);
                        console.log(`   Target Credit: £${orderDetails.targetCredit}`);
                        console.log(`   BP Impact: £${orderDetails.bpEffect}`);
                        console.log('\n' + orderDetails.instructions);
                    }
                }
                
                // Cleanup
                if (apiContext.dxlink) apiContext.dxlink.disconnect();
                if (apiContext.accountStreamer) apiContext.accountStreamer.disconnect();
                
                console.log('\n✅ Framework execution complete!');
                
            } else {
                throw new Error('API initialization returned null');
            }
            
        } catch (error) {
            console.error('\n❌ API Error:', error.message);
            console.log('\n📝 Falling back to MANUAL MODE');
            console.log('Please provide your account information:');
            console.log('Format: £[amount] | [positions] | [BP%] | [Day Date Time] | VIX [level] | [PM Y/N]');
            console.log('Example: £45000 | ES LT112 (85 DTE, 6420, +5%) | 32% | Friday Jan 10 10:15 AM EST | VIX 15.2 | No');
        }
    })();
    */
    
} else {
    console.log('📝 MANUAL MODE - No stored credentials found');
    console.log('Please provide your account information:');
    console.log('Format: £[amount] | [positions] | [BP%] | [Day Date Time] | VIX [level] | [PM Y/N]');
    console.log('Example: £45000 | ES LT112 (85 DTE, 6420, +5%) | 32% | Friday Jan 10 10:15 AM EST | VIX 15.2 | No');
}

// ============================================================
// MANUAL INPUT PROCESSOR
// ============================================================

// This function handles manual account input for testing scenarios
function processManualInput(userInput) {
    console.log('\\n📝 MANUAL MODE ACTIVATED');
    console.log('Processing provided account information...\\n');
    
    try {
        // Execute framework with provided manual input
        const results = executeFramework(userInput);
        
        if (results.success) {
            console.log('✅ Analysis Complete!');
            console.log('\\n💡 RECOMMENDATIONS:');
            console.log(results.recommendations || 'No specific recommendations at this time.');
            
            // Check for 0DTE opportunities
            if (results.strikeRecommendation && results.userData.dayOfWeek === 'Friday') {
                console.log('\\n📅 FRIDAY 0DTE OPPORTUNITY:');
                console.log(results.strikeRecommendation.recommendation);
                if (results.strikeRecommendation.strikes) {
                    console.log(`Strikes: ${results.strikeRecommendation.strikes.short}/${results.strikeRecommendation.strikes.long}`);
                }
            }
            
            // Display HTML dashboard if available
            if (results.htmlDashboard) {
                console.log('\\n📊 HTML Dashboard generated');
                console.log('Dashboard includes: Account status, position health, pattern analysis, recommendations');
            }
            
            return results;
        } else {
            console.log('❌ Analysis failed:', results.error);
            return null;
        }
        
    } catch (error) {
        console.error('❌ Error processing manual input:', error.message);
        console.log('\\nPlease check your input format:');
        console.log('£[amount] | [positions] | [BP%] | [Day Date Time] | VIX [level] | [PM Y/N]');
        return null;
    }
}

// ============================================================
// TOGGLE FOR FUTURE AUTO/MANUAL MODES  
// ============================================================

// Configuration object for future enhancement
const FRAMEWORK_CONFIG = {
    MODE: 'MANUAL',  // 'AUTO', 'MANUAL', or 'TEST'
    AUTO_EXECUTE_API: false,  // Set to true to enable automatic API connection
    ENABLE_MANUAL_OVERRIDE: true,  // Always allow manual input even with API credentials
    DEFAULT_ENVIRONMENT: 'production',  // 'production' or 'sandbox'
    
    // Future enhancement: Toggle between modes
    toggleMode: function(newMode) {
        this.MODE = newMode;
        console.log(`Framework mode switched to: ${newMode}`);
    },
    
    // Future enhancement: Enable/disable auto-execute
    setAutoExecute: function(enabled) {
        this.AUTO_EXECUTE_API = enabled;
        console.log(`Auto-execute API: ${enabled ? 'ENABLED' : 'DISABLED'}`);
    }
};

console.log('\\n⚙️  FRAMEWORK CONFIGURATION:');
console.log(`   Mode: ${FRAMEWORK_CONFIG.MODE}`);
console.log(`   Auto-execute API: ${FRAMEWORK_CONFIG.AUTO_EXECUTE_API ? 'ENABLED' : 'DISABLED'}`);
console.log(`   Manual override: ${FRAMEWORK_CONFIG.ENABLE_MANUAL_OVERRIDE ? 'ENABLED' : 'DISABLED'}`);
console.log('\\n📋 Ready for manual account input in format:');
console.log('   £[amount] | [positions] | [BP%] | [Day Date Time] | VIX [level] | [PM Y/N]');
console.log('\\n💡 Test scenarios you can try:');
console.log('   • Small account: £35000 | none | 0% | Friday Jan 10 10:15 AM EST | VIX 15.2 | No');
console.log('   • Phase 2: £45000 | ES LT112 (85 DTE, 6420, +5%) | 32% | Friday Jan 10 10:15 AM EST | VIX 15.2 | No');
console.log('   • High VIX: £60000 | SPY STRANGLE (45 DTE, 2.80, -8%) | 25% | Monday Jan 13 2:30 PM EST | VIX 28.5 | No');
console.log('   • Large account: £80000 | Multiple positions | 45% | Wednesday Jan 8 11:45 AM EST | VIX 12.3 | Yes');
