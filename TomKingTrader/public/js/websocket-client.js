/**
 * WebSocket Client for Real-time Market Data\n * Tom King Trading Framework v17\n * \n * This client connects to the TomKingTrader WebSocket server\n * and handles real-time market data updates\n */\n\nclass MarketDataClient {\n    constructor(options = {}) {\n        this.wsUrl = options.wsUrl || `ws://${window.location.hostname}:3001`;\n        this.apiUrl = options.apiUrl || '/api';\n        this.ws = null;\n        this.isConnected = false;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 5;\n        this.reconnectDelay = 1000;\n        \n        // Event listeners\n        this.listeners = {\n            'connected': [],\n            'disconnected': [],\n            'market_data': [],\n            'streaming_status': [],\n            'error': []\n        };\n        \n        // Market data cache\n        this.marketData = new Map();\n        this.lastUpdate = null;\n        \n        console.log('📊 MarketDataClient initialized', { wsUrl: this.wsUrl });\n    }\n    \n    /**\n     * Connect to WebSocket server\n     */\n    connect() {\n        try {\n            console.log('🔗 Connecting to WebSocket server...');\n            \n            this.ws = new WebSocket(this.wsUrl);\n            \n            this.ws.onopen = () => {\n                console.log('✅ WebSocket connected');\n                this.isConnected = true;\n                this.reconnectAttempts = 0;\n                this.emit('connected', { timestamp: new Date() });\n            };\n            \n            this.ws.onmessage = (event) => {\n                this.handleMessage(event);\n            };\n            \n            this.ws.onclose = (event) => {\n                console.log('🔌 WebSocket disconnected', event.code, event.reason);\n                this.isConnected = false;\n                this.emit('disconnected', { code: event.code, reason: event.reason });\n                \n                if (event.code !== 1000) { // Not a clean close\n                    this.handleReconnect();\n                }\n            };\n            \n            this.ws.onerror = (error) => {\n                console.error('🚨 WebSocket error:', error);\n                this.emit('error', { error });\n            };\n            \n        } catch (error) {\n            console.error('🚨 Failed to connect to WebSocket:', error);\n            this.handleReconnect();\n        }\n    }\n    \n    /**\n     * Handle incoming WebSocket messages\n     */\n    handleMessage(event) {\n        try {\n            const message = JSON.parse(event.data);\n            \n            switch (message.type) {\n                case 'market_data':\n                    this.handleMarketData(message.data);\n                    break;\n                case 'streaming_status':\n                    this.handleStreamingStatus(message.data);\n                    break;\n                case 'streaming_error':\n                    this.handleStreamingError(message.data);\n                    break;\n                default:\n                    console.log('📨 Unknown message type:', message.type, message);\n            }\n            \n        } catch (error) {\n            console.error('🚨 Failed to parse WebSocket message:', error);\n        }\n    }\n    \n    /**\n     * Handle market data updates\n     */\n    handleMarketData(data) {\n        const { updates, timestamp, source } = data;\n        \n        // Update local cache\n        Object.entries(updates).forEach(([symbol, quote]) => {\n            this.marketData.set(symbol, {\n                ...quote,\n                lastUpdate: new Date(timestamp)\n            });\n        });\n        \n        this.lastUpdate = new Date(timestamp);\n        \n        // Emit to listeners\n        this.emit('market_data', {\n            updates,\n            timestamp: new Date(timestamp),\n            source,\n            totalSymbols: this.marketData.size\n        });\n        \n        console.log(`📊 Market data update: ${Object.keys(updates).length} symbols from ${source}`);\n    }\n    \n    /**\n     * Handle streaming status updates\n     */\n    handleStreamingStatus(data) {\n        console.log('📡 Streaming status update:', data);\n        this.emit('streaming_status', data);\n    }\n    \n    /**\n     * Handle streaming errors\n     */\n    handleStreamingError(data) {\n        console.error('🚨 Streaming error:', data);\n        this.emit('error', data);\n    }\n    \n    /**\n     * Handle reconnection with exponential backoff\n     */\n    handleReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            console.error('🚨 Max reconnection attempts reached');\n            return;\n        }\n        \n        this.reconnectAttempts++;\n        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n        \n        console.log(`🔄 Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        \n        setTimeout(() => {\n            this.connect();\n        }, delay);\n    }\n    \n    /**\n     * Subscribe to market data for symbols via REST API\n     */\n    async subscribeToSymbols(symbols) {\n        try {\n            const response = await fetch(`${this.apiUrl}/streaming/subscribe`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ symbols })\n            });\n            \n            const result = await response.json();\n            \n            if (result.success) {\n                console.log('✅ Subscribed to symbols:', result.data.subscribed);\n                return result.data;\n            } else {\n                console.error('❌ Failed to subscribe:', result.error);\n                return null;\n            }\n            \n        } catch (error) {\n            console.error('🚨 Subscribe request failed:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * Unsubscribe from symbols via REST API\n     */\n    async unsubscribeFromSymbols(symbols) {\n        try {\n            const response = await fetch(`${this.apiUrl}/streaming/unsubscribe`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ symbols })\n            });\n            \n            const result = await response.json();\n            \n            if (result.success) {\n                console.log('✅ Unsubscribed from symbols:', result.data.unsubscribed);\n                return result.data;\n            } else {\n                console.error('❌ Failed to unsubscribe:', result.error);\n                return null;\n            }\n            \n        } catch (error) {\n            console.error('🚨 Unsubscribe request failed:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * Get streaming status via REST API\n     */\n    async getStreamingStatus() {\n        try {\n            const response = await fetch(`${this.apiUrl}/streaming/status`);\n            const result = await response.json();\n            \n            if (result.success) {\n                return result.data;\n            } else {\n                console.error('❌ Failed to get status:', result.error);\n                return null;\n            }\n            \n        } catch (error) {\n            console.error('🚨 Status request failed:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * Get cached market data\n     */\n    getMarketData(symbols = null) {\n        if (!symbols) {\n            // Return all data\n            const result = {};\n            this.marketData.forEach((data, symbol) => {\n                result[symbol] = data;\n            });\n            return result;\n        }\n        \n        // Return specific symbols\n        const result = {};\n        symbols.forEach(symbol => {\n            const data = this.marketData.get(symbol);\n            if (data) {\n                result[symbol] = data;\n            }\n        });\n        \n        return result;\n    }\n    \n    /**\n     * Add event listener\n     */\n    on(event, callback) {\n        if (this.listeners[event]) {\n            this.listeners[event].push(callback);\n        } else {\n            console.warn(`Unknown event: ${event}`);\n        }\n    }\n    \n    /**\n     * Remove event listener\n     */\n    off(event, callback) {\n        if (this.listeners[event]) {\n            const index = this.listeners[event].indexOf(callback);\n            if (index > -1) {\n                this.listeners[event].splice(index, 1);\n            }\n        }\n    }\n    \n    /**\n     * Emit event to listeners\n     */\n    emit(event, data) {\n        if (this.listeners[event]) {\n            this.listeners[event].forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error(`🚨 Error in ${event} listener:`, error);\n                }\n            });\n        }\n    }\n    \n    /**\n     * Disconnect from WebSocket\n     */\n    disconnect() {\n        if (this.ws) {\n            this.ws.close(1000, 'Client disconnect');\n            this.ws = null;\n        }\n        this.isConnected = false;\n        console.log('👋 Disconnected from WebSocket server');\n    }\n    \n    /**\n     * Get connection status\n     */\n    getStatus() {\n        return {\n            connected: this.isConnected,\n            reconnectAttempts: this.reconnectAttempts,\n            symbolsTracked: this.marketData.size,\n            lastUpdate: this.lastUpdate\n        };\n    }\n}\n\n/**\n * Real-time Market Data Display Component\n */\nclass MarketDataDisplay {\n    constructor(containerId, client) {\n        this.container = document.getElementById(containerId);\n        this.client = client;\n        this.updateInterval = null;\n        \n        if (!this.container) {\n            console.error('Container element not found:', containerId);\n            return;\n        }\n        \n        this.setupEventListeners();\n        this.createDisplay();\n        this.startPeriodicUpdate();\n    }\n    \n    setupEventListeners() {\n        this.client.on('connected', () => {\n            this.updateConnectionStatus('connected');\n        });\n        \n        this.client.on('disconnected', () => {\n            this.updateConnectionStatus('disconnected');\n        });\n        \n        this.client.on('market_data', (data) => {\n            this.updateMarketData(data.updates);\n        });\n    }\n    \n    createDisplay() {\n        this.container.innerHTML = `\n            <div class=\"market-data-display\">\n                <div class=\"header\">\n                    <h3>Real-time Market Data</h3>\n                    <div class=\"status\" id=\"connection-status\">Connecting...</div>\n                </div>\n                <div class=\"controls\">\n                    <button id=\"subscribe-btn\" onclick=\"this.subscribeToDefaultSymbols()\">Subscribe to Default Symbols</button>\n                    <button id=\"refresh-btn\" onclick=\"this.refreshDisplay()\">Refresh</button>\n                </div>\n                <div class=\"market-data-table\" id=\"market-data-table\">\n                    <div class=\"table-header\">\n                        <div>Symbol</div>\n                        <div>Last</div>\n                        <div>Bid</div>\n                        <div>Ask</div>\n                        <div>Spread</div>\n                        <div>Last Update</div>\n                    </div>\n                    <div id=\"market-data-rows\"></div>\n                </div>\n            </div>\n        `;\n    }\n    \n    updateConnectionStatus(status) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            statusElement.textContent = status === 'connected' ? 'Connected' : 'Disconnected';\n            statusElement.className = `status ${status}`;\n        }\n    }\n    \n    updateMarketData(updates) {\n        const rowsContainer = document.getElementById('market-data-rows');\n        if (!rowsContainer) return;\n        \n        Object.entries(updates).forEach(([symbol, quote]) => {\n            let row = document.getElementById(`row-${symbol}`);\n            \n            if (!row) {\n                row = document.createElement('div');\n                row.id = `row-${symbol}`;\n                row.className = 'table-row';\n                rowsContainer.appendChild(row);\n            }\n            \n            const spread = quote.ask && quote.bid ? (quote.ask - quote.bid).toFixed(4) : 'N/A';\n            const lastUpdate = new Date().toLocaleTimeString();\n            \n            row.innerHTML = `\n                <div class=\"symbol\">${symbol}</div>\n                <div class=\"last\">${quote.last?.toFixed(2) || 'N/A'}</div>\n                <div class=\"bid\">${quote.bid?.toFixed(2) || 'N/A'}</div>\n                <div class=\"ask\">${quote.ask?.toFixed(2) || 'N/A'}</div>\n                <div class=\"spread\">${spread}</div>\n                <div class=\"time\">${lastUpdate}</div>\n            `;\n            \n            // Add flash effect for updates\n            row.classList.add('updated');\n            setTimeout(() => row.classList.remove('updated'), 1000);\n        });\n    }\n    \n    async subscribeToDefaultSymbols() {\n        const symbols = ['SPY', 'QQQ', 'VIX', 'IWM'];\n        await this.client.subscribeToSymbols(symbols);\n    }\n    \n    refreshDisplay() {\n        const marketData = this.client.getMarketData();\n        this.updateMarketData(marketData);\n    }\n    \n    startPeriodicUpdate() {\n        this.updateInterval = setInterval(() => {\n            this.refreshDisplay();\n        }, 1000); // Update every second\n    }\n    \n    destroy() {\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n        }\n    }\n}\n\n// Example usage:\n/*\n// Initialize client\nconst client = new MarketDataClient();\n\n// Set up event listeners\nclient.on('connected', () => {\n    console.log('Connected to market data stream');\n});\n\nclient.on('market_data', (data) => {\n    console.log('Market data update:', data);\n});\n\n// Connect to server\nclient.connect();\n\n// Subscribe to symbols\nclient.subscribeToSymbols(['SPY', 'QQQ', 'VIX']).then(() => {\n    console.log('Subscribed successfully');\n});\n\n// Create display (optional)\nconst display = new MarketDataDisplay('market-data-container', client);\n*/\n\n// Make available globally\nwindow.MarketDataClient = MarketDataClient;\nwindow.MarketDataDisplay = MarketDataDisplay;